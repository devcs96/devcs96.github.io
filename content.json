{"pages":[{"title":"all-categories","text":"","link":"/all-categories/index.html"},{"title":"all-tags","text":"","link":"/all-tags/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Item1. 생성자 대신에 정적 팩토리 메소드를 구현하라","text":"정적 팩토리 메소드(static factory method)란 ? 클래스의 instance를 반환해주는 메소드 클래스의 인스턴스를 얻는 전통적인 방식은 public constructor 생성자 방식보다는 정적 팩토리 메소드를 사용하여 instance를 만들면 다음과 같은 장단점이 있다. 장점 이름을 가질 수 있다. 생성자 방식은 별도로 이름을 지정할 수 없다. 하지만 정적 팩토리 메소드 방식은 직관적으로 naming을 하여, 코드 가독성이 증가한다. 12345678910// 생성자 방식BigInteger(int param, Random random){ // return random prime }// static factory method 방식BigInteger.createRandomPrime(){ //return rnadom prime} 호출될때마다 인스턴스를 새로 생성하지는 않아도 된다. static method이기 때문에 인스턴스를 new 해서 생성하지 않고 클래스로 바로 호출 가능하다. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.즉 , 반할 객체의 클래스를 선택할 수 있는 유연성이 있다. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 정적 팩토리 method를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. 단점 상속을 하려면 public,protected 생성자를 제공해야한다. 즉 , 정적 팩터리 메소드만 제공하면 하위 클래스를 만들 수없다.","link":"/2021/07/15/2021-07-15-item1/"},{"title":"Item2. 생성자에 매개변수가 많다면 빌더를 고려해라","text":"객체 생성 방법 중 static factory method 와 constructor 를 통한 객체 생성 방법은 선택적 매개변수가 많을 때, 대응이 어렵다. 점층적 생성자 패턴(Telescoping constructor pattern) 여러개의 생성자를 만들어서, 필요한 매개변수 조합을 선택하여 객체를 만드는 방식을 점층적 생성자 패턴이라고 한다. 위 방식은 매개변수 개수가 많아질수록 가독성이 매우 떨어진다.예를 들면 다음과 같다. 123456789101112131415161718192021222324252627282930313233// 점층적 생성자 패턴(telescoping constructor pattern)public Class NutritionFacts{ private final int serviceSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public NutritionFacts(int serviceSize, int servings){ this(servingSize,servings,0); } public NutritionFacts(int serviceSize, int servings,int calories){ this(servingSize,servings,calories,0); } public NutritionFacts(int serviceSize, int servings,int calories, int fat){ this(servingSize,servings,calories,fat,0); } public NutritionFacts(int serviceSize, int servings,int calories, int fat, int sodium , int carbohydrates ){ this.servingSize = servingSize; this.servings = servings; this.calories = calories; this.fat = fat; this.sodium = sodium; this.carbohydrate = carbohydrate; } /* 위와 같이 생성자를 계속 추가함으로 , 선택 매개변수를 받는 조합을 선택하여 객체를 만든다. 가독성도 떨어지고, 코드의 길이가 불필요하기 길어진다. */} 자바빈즈 패턴(JavaBeans pattern) 매개변수가 없는 생성자로 객체를 우선 만든 뒤에,setProperty1,2…. 방식으로 원하는 매개변수 값을 설정하는 방식이다. 1234567891011121314151617181920212223242526272829303132333435363738// JavaBeansPatternpublic class NutritionFacts { private int serviceSize = -1; private int servings = -1; private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public NutritionFacts() { } public void setServiceSize(int serviceSize) { this.serviceSize = serviceSize; } public void setServings(int servings) { this.servings = servings; } public void setCalories(int calories) { this.calories = calories; } public void setFat(int fat) { this.fat = fat; } public void setSodium(int sodium) { this.sodium = sodium; } public void setCarbohydrate(int carbohydrate) { this.carbohydrate = carbohydrate; } public static void main(String[] args) { NutritionFacts nutritionFacts = new NutritionFacts(); nutritionFacts.setServings(120); nutritionFacts.setFat(20); //set~ }} 점층적 생성자 패턴 방식에 비해 확실히 코드의 가독성은 증가하였다.하지만 객체 하나를 만드려면 여러 메소드를 호출해야하고,중간중간에 사용자가 원하지 않는 상태의 객체가 생긴다는 단점이 있다.이를 책에서는 “일관성이 무너진 상태”로 불변객체로 만들수가 없다고 한다. 단점을 완화하고자 객체 생성이 끝난 뒤에 freeze 메소드를 통해 객체를 수동으로 변경이 불가능하도록 만들 수 있다. 빌더패턴(Builder Pattern) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Builder patternpublic class NutritionFacts { private final int serviceSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; // 생성할 클래스 안에 static class로 builder를 만든다. public static class Builder{ // 필수 매개변수라고 가정한다. private final int servingSize; private final int serving; // 선택 매개변수 - 기본값으로 초기화한다. private int calories = 0; private int fat = 0; private int sodium =0; private int carbohydrate =0; public Builder(int servingSize, int serving) { this.servingSize = servingSize; this.serving = serving; } public Builder calories(int val){ // 1. 매개 변수에 값을 할당하고 calories = val; // 2. 자기 자신(Builder)을 반환하여 chaining 형태로 메소드가 호출될수 있게한다. return this; } public Builder fat(int val){ fat = val; return this; } public Builder sodium(int val){ sodium = val; return this; } public Builder carbohydrate(int val){ carbohydrate =val; return this; } public NutritionFacts build(){ // 3. build 메소드 호출을 통해, 생성하고자하는 객체의 생성자에 빌더를 넣어준다. return new NutritionFacts(this); } } //4. 빌더 안에 세팅된 값을 할당해준다. public NutritionFacts(Builder builder) { serviceSize = builder.servingSize; servings = builder.serving; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; }} 정리를 하면, 생성할 class의 static class로 builder를 만들고, builder 안에서 property 를 설정할 수 있는 메소드를 정의하고, 메소드의 반환값을 builder로 하여,method들이 연쇄적으로 호출될 수 있게한다. 이를 메소드 체이닝 또는 Fluent API 라고 부른다. 어쩄거나 위의 방식을 통해 생성한 객체는 다음과 같이 만들 수 있다. 123456public static void main(String[] args) { NutritionFacts nutritionFacts = new Builder(280, 240) .calories(100) .sodium(35) .build();} 빌더 패턴의 장점은 가독성이 뛰어나고, 불변객체를 만들수 있다. 또한 계층적 구조에도 활용 가능하여, 확장이 용이하다. 12345678910111213141516171819202122232425262728293031// 계층적구조에 활용하는 빌더패턴public abstract class Pizza { public enum Topping {HAM,ONION,PEPPER}; final Set&lt;Topping&gt; toppings; /*** * 자식 클래스에서 상속받을 Builder 를 정의한다. * self()메소드를 통해 Builder를 반환하여 메소드 체이닝 형태로 호출 가능하다. * addToping method는 default method로 부모 객체에서 정의하였다. */ abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt;{ EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping){ toppings.add(Objects.requireNonNull(topping)); return self(); } abstract Pizza build(); protected abstract T self(); } Pizza(Builder&lt;?&gt; builder){ toppings = builder.toppings.clone(); }} 123456789101112131415161718192021222324252627282930public class MyPizza extends Pizza{ public enum Size {SMALL,MEDIUM,LARGE}; private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt;{ /*부모 빌더를 상속받아서 addTopping 메소드로, topping enum 값을 추가할 수 있으며, 자식 빌더에서는 size enum값을 생성자로 받게하여,builder 생성시에 피자의 사이즈를 설정할 수 있다. */ private final Size size; public Builder(Size size) { this.size = Objects.requireNonNull(size); } @Override Pizza build() { return new MyPizza(this); } @Override protected Builder self() { return this; } } MyPizza(Builder builder) { super(builder); size = builder.size; }} 12345678910111213141516171819202122232425262728293031323334public class Calzone extends Pizza{ private final boolean sauceInside; /*** * 마찬가지로 부모빌더를 상속하였는데, boolean property를 추가하여 구현하였다. */ public static class Builder extends Pizza.Builder&lt;Builder&gt;{ private boolean sauceInside = false; public Builder sauceInside(){ sauceInside = true; return this; } @Override Pizza build() { return new Calzone(this); } @Override protected Builder self() { return this; } } Calzone(Builder builder){ super(builder); sauceInside = builder.sauceInside; }} 12345678public static void main(String[] args) { Pizza pz1 = new MyPizza.Builder(MyPizza.Size.SMALL) .addTopping(Topping.ONION).build(); Pizza pz2 = new Calzone.Builder() .addTopping(Topping.HAM).sauceInside().build();} 정리 : 생성자나 정적 팩토리 메소드가 처리해야할 매개변수가 많다면 빌더패턴을 선택하는게 코드 가독성 측면과 불변객체를 안전하게 만들 수 있다는 측면에서 더 바람직하다.","link":"/2021/07/17/2021-07-16-item2/"},{"title":"Item3. private 생성자나 열거 타입으로 singleton임을 보증하라","text":"singleton : instance를 오직하나만 생성할 수 있는 class singleton을 만드는 대표적인 2개의 방법은 다음과 같다. private 으로 감춰두고, 유일한 instance에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해둔다. 12345678910111213// How to Make singleton Object public class Elvis{ // Elvis class를 통해 public static 으로 Elvis인스턴스를 접근할 수 있게함 public static final Elvis INSTANCE = new Elvis(); // private 생성자로 외부에서 생성자 접근 불가능하게 막음 // Elvis 인스턴스가 초기화될때 한번만 호출된다. private Elvis(){};} public , protected 생성자가 없으므로, 외부에서 접근이 막아서, 객체를 생성하는 것을 막는다. static method는 당연히 class 로딩시점에 딱 한번 메모리에 할당되고, final은 필드 초기값이 저장되면 도중에 수정이 안되는 상수와 유사한 개념으로 동작하므로, 최초로 static 호출하고 난뒤에는 singleton 객체를 보장해줄 수 있다. reflection api를 통해 private 생성자도 외부에서 호출이 가능함 (권한이 있는 client 경우) 이와 관련된 내용은 Item 65에서 소개하고 있다. static factory method를 public static 멤버로 제공한다. 123456789public class Elvis{ // private으로 외부에서 접근을 막고, 정적 팩토리 메소드를 통해서만 접근이 가능하도록 한다. private static final Elvis instance = new Elvis(); private Elvis(){}; //static factory method public static Elvis getInstance(){ return instance; }} getInstance method는 new 객체를 생성해반환하는 것이 아니라, 이미 만들어진 instance의 참조를 넘김으로, 마찬가지로 singleton을 보장한다. 원소가 하나인 열거타입을 사용한다. 123public enum Elvis{ Instance;} 이제 세 방법의 장단점을 비교해보자 public 필드 방식의 장점 해당 클래스가 singleton임이 API에 명백하게 표현됨. 코드 간결성 static factory method 방식의 장점 API를 바꾸지 않고도 singleton이 아니게 변경이 가능하다 java Supplier API에 활용가능 12//Elvis::getInstance Supplier&lt;Elvis&gt; enum type 방식의 장점 코드 간결성이 제일 뛰어나고, reflection 공격에서도 제 2의 instance가 생기는 것을 막아준다. effective java 에서는 enum type을 선언하여 싱글톤 객체를 만드는 것을 권하고 있다.단 만드려는 instance가 enum class 외의 class를 상속해야 한다면, 해당 방법은 당연히 사용이 불가능함으로, static factory method 방법을 고려하면 되겠다.","link":"/2021/07/18/2021-07-19-item3/"},{"title":"Item4. 인스턴스화를 막을려면 private생성자를 이용하라","text":"static method,static field만을 담은 유틸리티성 클래스의 객체 생성을 막으려면 어떻게 해야할까? java.lang.Math, java.util.Array 와 같은 class는 주로 static method, static field만을 담은 class이다. 이러한 class들은 객체를 만드는 것이 목적이 아니라, class의 static method, field를 이용하는 것이 주 목적이다. 객체를 만드는 것이 목적이 아니기 때문에, API를 이용하는 client가 객체를 생성하는 것을 막는 게 바람직하다. “추상클래스로 만드는 방법은 바람직하지 못하다. client가 해당 class를 상속받아서 객체를 만들면 그만이기 때문이다” 그렇다면 객체의 생성을 막는 방법은 무엇일까? singleton 패턴에서 자주사용하는 것처럼 private 생성자를 이용 하면 된다. 예를 들면 다음과 같다. 1234567891011121314public class UtilityClass{ /* 기본 생성자가 생성되는 것을 막고, 외부에서 생성자를 호출할 수 없도록 private constructor를 만든다. */ private UtilityClass(){ } public static void doSomeThing(){ // utiliy Method } } 추가로 위 방식은 상속을 불가능하게 하는 효과도 가지고 있다, 모든 생성자는 명시적 또는 묵시적으로 부모class의 생성자를 호출하는데 1234constructor(){ super(parent); // ~} 이를 private 로 막아버리면 자식 class가 부모class에게 접근할 방법이 막혀버린다. 정리: class에 utility 성 static method,field만 담아둔다면 client가 객체를 생성할 이유가 없으므로, 설계상 객체를 막아두는게 바람직하다. 객체의 생성을 막는 방법으로는 생성자를 private로 만들면 된다.","link":"/2021/07/20/2021-07-20-item4/"},{"title":"Factory Pattern (a.k.a Factory class)","text":"Factory Class란?객체 생성의 책임을 가지고 있는 class이다.*정확히는 Design Pattern은 아니다. Factory 패턴을 이해하기 위해 예시를 가지고 왔다. 피자 가게를 운영한다고 가정해보자 1234567891011121314151617Pizza orderPizza(String type){ Pizza pizza; if (type.equals(&quot;cheese&quot;){ pizza = new CheesePizza(); }) if (type.equals(&quot;greek&quot;){ pizza = new GreekPizza(); }) if (type.equals(&quot;pepperoni&quot;){ pizza = new Pepperoni(); }) pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza;} 고객으로부터 주문을 받아, 피자 객체를 만든다고 하면 피자 타입에 따라 다른 객체를 생성해주어야 할 것이다. 위 코드에서 변경되는 부분은 객체를 생성하는 부분으로, 별도로 캡슐화할 수 있다. 123456789101112131415public class SimplePizzaFactory{ public Pizza createPizza(String type){ Pizza pizza=null; if (type.equals(&quot;cheese&quot;){ pizza = new CheesePizza(); }) if (type.equals(&quot;greek&quot;){ pizza = new GreekPizza(); }) if (type.equals(&quot;pepperoni&quot;){ pizza = new Pepperoni(); }) return pizza; }} 이처럼 객체를 생성해주는 class를 Factory라고 부른다. 사실 Factory Pattern은 엄밀히 말하면 디자인 패턴은 아니라고 한다. 어쨌거나 이렇게 객체를 생성하는 책임을 Factory Class로 캡슐화하였을때 어떤 장점이 있을까? 여러 Client에서 사용이 가능하다. 객체 생성의 책임이 Factory class로 분리되었음으로 객체 생성관련하여 변경이 생겼을때는 한 곳만 수정하면 된다. 여기서 effective Java Item5 내용을 추가하면 \"Item5. 자원을 직접 명시하지 말고, DI를 통해 객체를 주입받자\" 최종적으로 수정된 코드는 다음과 같다. 123456789101112131415161718public class PizzaStore{ SimplePizzaFactory factory;// 생성자를 통해 Factory 를 주입받는다. public PizzaStore(SimplePizzaFactory factory){ this.factory = factory; }// 객체 생성의 책임은 Factory Class에 있다. Client는 단지 이를 이용하여 원하는 인스턴스를 만들어 낸다. public Pizza orderPizza(String type){ Pizza pizza; pizza = factory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); }} Reference Head First Design Patterns: A Brain-Friendly Guide (Head First Design Patterns: A Brain-Friendly Guide)","link":"/2021/07/21/2021-07-21-Factory-pattern/"},{"title":"Dao의 점진적인 Refactorying을 통해 알아보는 객체지향설계원칙","text":"간단정리chapter1에서는 Spring FrameWork의 관심사인 Object 설계와 구현 및 동작원리에 초점을 두고 있다. Dao 설계를 이상적인 설계인 ‘변경이 용이한 구조’를 만들기 위해 순차적으로 코드를 Refactorying 하여서 가장 이상적인 설계를 설명하고 이와 밀접히 관련되어 있는 스프링의 주요 개념인 IoC(Inversion of Control) 개념을 소개한다. 순수 JDBC를 통한 Database Connection 123456789101112131415161718192021222324252627282930313233343536373839404142public class UserDao_V1 { public void add(User user) throws ClassNotFoundException, SQLException { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection c = DriverManager.getConnection( &quot;jdbc:mysql://localhost:3306/spring_study?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8 &quot;,&quot;root&quot;,&quot;1234&quot;); PreparedStatement ps = c.prepareStatement( &quot;insert into users(id,name,password) values(?,?,?)&quot; ); ps.setString(1,user.getId()); ps.setString(2,user.getName()); ps.setString(3,user.getPassword()); ps.executeUpdate(); ps.close(); c.close(); } public User get(String id) throws ClassNotFoundException, SQLException { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection c = DriverManager.getConnection( &quot;jdbc:mysql://localhost:3306/spring_study?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8 &quot;,&quot;root&quot;,&quot;1234&quot;); PreparedStatement ps = c.prepareStatement( &quot;select * from users where id = ?&quot; ); ps.setString(1,id); ResultSet rs = ps.executeQuery(); rs.next(); User user = new User(); user.setId(rs.getString(&quot;id&quot;)); user.setName(rs.getString(&quot;name&quot;)); user.setPassword(rs.getString(&quot;password&quot;)); rs.close(); ps.close(); c.close(); return user; }} 순수 JDBC를 통한 Connection 의 문제는 다음과 같이 정리할 수 있다. 과도한 중복코드 너무 많은 관심사가 하나의 method안에 있다.ex) DB Connection을 어떡할것인지, 리소스 처리를 어떡할것인지관심사의 분리는 별도의 class로 모듈화 함으로 분리될 수 있다.책에서는 순차적으로 중복된 code를 제거하기 위해 method extraction 을 소개하고 있다. 123456// UserDao_V2 private Connection getConnection() throws ClassNotFoundException, SQLException { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); return DriverManager.getConnection( &quot;jdbc:mysql://localhost:3306/spring_study?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8 &quot;, &quot;root&quot;, &quot;1234&quot;); } method 추출을 통해 중복된 코드를 하나의 method로 분리하였다.중복된 코드를 줄임으로서 얻는 장점은 변경의 원인도 중복이 아닌 한곳이라는 것이다. 즉 변경이 생겼을떄 한곳만 변경하면 된다. 여기서 나아가 변화에 용이한 구조를 만들기 위해 상속구조를 소개하였다. DB Connection 정보를 추상화하여, Client들 별로 사용하고 싶은 DB Connection을 구현한다. ex) UserDao의 DB connection을 A,B,C,D사에게 넘겨주고, 구현은 알아서 하고, UserDao는 DB Connection의 구체구현을 몰라도 그냥 DB Connection이 반환되었구나 라고 알면된다는 소리다. 1234567891011public abstract class UserDao{ // 추상 클래스를 만들어 add,get 은 구현하고 connection은 하위 클래스에게 구현의 책임을 맡긴다. public abstract Connection getConnection() throws ClassNotFoundException,SQLException; public void add(User user) throws ClassNotFoundException,SQLException{ // default method 구현 } public void get(String id) throws ClassNotFoundException,SQLException{ // default method 구현 }} 위 코드의 주요 장점은 확장성이다. 새로운 DB Connection을 구현하고 싶다면 그냥 상속받아서 구현하면 된다. 위와 같이 부모class에서 기본적인 logic흐름이 있고, 그 일부를 추상 method나 overrding가능한 protected method로 만들고 자식class에서 구현해서 사용하는 방법을 Template Method Pattern이라고 한다. 자세한 내용은 Design Pattern 카테고리에 별도로 첨부하였다 하지만 DB연결방식을 하위class로 그 외Data Access 로직을 상위 class로 잡은 상속 구조에도 단점이 있다. 변화의 이유 , 시기, 주기가 다르다.ex) 데이터를 어떻게 전처리 할 것인지 로직이 변경되어도 DB Connection을 얻는 로직은 변경되지 않는다. 이러한 문제를 책에서는 상속구조가 아닌 별도의 class로 관심사를 분리하는 형태로 접근하였다. 12345678910111213141516171819202122232425262728public class UserDao_V3 { private SimpleConnectionMaker simpleConnectionMaker = new SimpleConnectionMaker();// 1. Data를 어떻게 추가할 것인가에 대한 관심 public void add(User user) throws ClassNotFoundException, SQLException { Connection c = simpleConnectionMaker.makeNewConnection(); // ~ }}// 2. DB 연결에 대한 관심 public class SimpleConnectionMaker { public Connection makeNewConnection() throws ClassNotFoundException, SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection c = DriverManager.getConnection( &quot;jdbc:mysql://localhost:3306/spring_study?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8 &quot;,&quot;root&quot;,&quot;1234&quot;); return c; };}````관심사를 별도의 class로 분리하였지만, 상속구조에서 가졌던 기능 확장이 다시 불가능해졌다. 예를 들면 DB 연결 method명이 변경되면 일일히 Dao 에서 변경해야 한다. 또한 UserDao Class가 어떤 DB connection을 받는지 알아야 한다. ```javaMariaDBConnectionMaker.makeNewConnection();MysqlDBConnectionMaker.makeNewConnection();OracleDBConnectionMaker.makeNewConnection(); 정리를 하면 UserDao가 DB connection을 가지고 오는 class에 대해 너무 많이 알면, 종속적으로 되기 때문에 DB connection이 변경되면 같이 변경된다. 이를 소프트웨어공학에서는 SDP(stable dependency principle) 을 따르지 않는다고 하는데, 변경될 가능성이 큰 구체 class를 의존하는 것을 말한다. 책에서는 class를 분리하면서도 UserDao가 DB Connection에 대해 종속적이지 않는 구조를 만들기 위해 다음과 같이 추상화 계층을 만들었다. 위 구조는 구체 class인 B의 공통적인 틀을 정의하는 추상클래스를 도출하고, 하위 구현방법은 B의 구체 class에서 구현하였다.그리고 B와 의존성 관계에 있는 A class는 B의 추상클래스에 의존함으로써, B의 구체 class의 서비스 로직이 변경된다고 하더라도 영향받지 않는다. 책에서도 마찬가지로 DB연결정보를 인터페이스를 통해 공통적인 성격을 추상화하고,UserDao는 추상화한 인터페이스에 접근하여 실제로 DB연결정보가 어떻게 구현되어있는지는 종속적이지 않도록 구조를 변경하였다 12345678910111213141516171819202122232425262728// UserDao_V4// 추상화를 통해 인터페이스를 만듦public interface ConnectionMaker { public Connection makeNewConnection() throws ClassNotFoundException, SQLException;}public class DconnectionMaker implements ConnectionMaker { @Override public Connection makeNewConnection() throws ClassNotFoundException, SQLException { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection c = DriverManager.getConnection( &quot;jdbc:mysql://localhost:3306/spring_study?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8 &quot;,&quot;root&quot;,&quot;1234&quot;); return c; }}public class UserDao_V4 {// UserDao는 구체 class가 아닌 안정된 인터페이스에 종속적으로 변경 private ConnectionMaker connectionMaker; public UserDao(ConnectionMaker connectionMaker) { this.connectionMaker = new DconnectionMaker(); } public void add(User user) throws ClassNotFoundException, SQLException { Connection c = connectionMaker.makeNewConnection(); }} 위와 같이 구조 변경을 통해서 이제 확장성까지 갖추게 되었다. 다른 DB연결정보로 확장하고 싶으면 UserDao에서 new Dconnection() 대신 new xConnection(); 으로 변경해주면 된다. 하지만 바로 이부분이 문제이다. 1234567public class UserDao_V4 { private ConnectionMaker connectionMaker; public UserDao(ConnectionMaker connectionMaker) { // UserDao에서 구체적인 하위 class를 명시해야 한다. this.connectionMaker = new DconnectionMaker(); }} UserDao에서 대부분의 종속성은 제거하였지만, 생성자에서 외부 객체를 주입받는 과정에서 어떤 객체를 사용할지 구체클래스를 명시를 하고 있다. 즉 어떤 연결정보를 사용할지에 따라 DconnectionMaker인지, 다른 connectionMaker인지 UserDao에서 명시해야 한다는 단점이 있다. 1ConnectionMaker connectionMaker = new DconnectionMaker(); 위 관계는 class사이의 관계가 만들어진것이 아니라 객체사이에 관계가 맺어진것으로 class사이의 관계와는 구분해야 한다. class사이의 관계는 클래스 명이 type으로 드러나야하는 반면 object사이의 관계는 다형성 특징을 통해 해당 class를 알지 못하더라도, 해당 class가 구현한 interface를 사용했다면 그 class의 object를 부모 type으로 받아서 사용할 수 있다. 어쨌거나, 어느 DB 커넥션을 사용할지는 UserDao Client의 관심으로 object 사이의 관계를 설정해주어야 한다. 현재 UserDao를 main method 에서 사용하므로, 사용하는 client는 main이라고 할 수 있다. 1234567891011121314151617181920public class UserDao_V5 { private ConnectionMaker connectionMaker; public UserDao(ConnectionMaker connectionMaker) { this.connectionMaker =connectionMaker; } // ~~~}// UserDao Client가 어느 DB연결을 쓸지 결정하여 UserDao에게 DI해준다. public class UserDaoTest { public static void main(String[] args) { ConnectionMaker connectionMaker = new DconnectionMaker(); // Client가 오브젝트 사이의 의존관계를 설정해준다. UserDao userDao = new UserDao(connectionMaker); }} 이제 관심사를 분리하였으며, 확장도 가능한 구조로 변경을 완료하였다.만약에 DB연결정보를 변경한다면 다음과 같이 UserDao에 손대지 않고 변경이가능하다. 123456789public class UserDaoTest { public static void main(String[] args) { //Dconnection말고 NConnection으로 변경해주세요 //Dconnection -&gt; Nconnection ConnectionMaker connectionMaker = new NconnectionMaker(); UserDao userDao = new UserDao(connectionMaker); }} 정리하면 위와 같은 최종구조를 갖는다. 위 구조는 디자인 패턴에서 전략 패턴(startegy pattern)에 속한다. 자세한 전략패턴에 대한 설명은 별도로 정리해두었다. (전략패턴) 위 구조는 객체 지향 설계 원칙 중에 하나인 OCP (SOLID의 O, Open closed Principle) 을 구현했다고 할 수 있는데, OCP(Open Closed Principle,개방폐쇄원칙)는 모듈이 변경에는 닫혀있고, 확장에는 열려 있어야 한다. 여기서 점진적으로 발전시킨 UserDao class는 변경에는 닫혀있다. “코드에 어떠한 수정없이 DB연결정보를 확장시킬수 있다” 라는 측면에서 OCP를 준수하였다라고 말할 수 있다. 책에서는 OCP를 준수했다는 것을 높은 응집도(coherence)와 낮은 결합도(coupling)를 갖는다고도 표현한다. 간략하게 정리하면 다음과 같다. - 응집도(Coherence) : 모듈 내부의 요소들이 관련되어 있는 정도, 높은 응집도를 갖는다는 것은 모듈의 내부 요소들이 하나의 책임과 관련이 있고, 변경의 원인이 하나라는 의미. 즉 관심사가 하나다. - 결합도(Coupling): 모듈간의 서로 상호 의존하는 정도 , 낮은 결합도를 갖는 다는 것은 다른 모듈에게 변화를 요구하지 않고, 변경이 전파되지 않는다는 것을 의미. 위와 같이 Dao를 v1~v5까지 refactorying 하면서 ocp를 준수하도록 설계하였다.그렇다면 이와 관련되어있는 spring의 IoC개념은 무엇일까?간단하게 설명하면 program의 제어 흐름이 뒤바뀐 것이다. 자세한 내용은 다음 포스팅에서 살펴보도록 하겠다.","link":"/2021/07/20/2021-07-20-spring-01/"},{"title":"item6. 불필요한 객체 생성을 피하자","text":"똑같은 기능을 하는 객체를 매번 생성하는 것보다 하나의 객체를 재사용하는 것이 메모리 측면에서 더 좋다. 예를 들면 아래의 코드는 매번 실행될떄마다 JVM 메모리의 Heap 영역에 객체가 저장되고, 그 객체를 가르키는 참조값인 newObj가 반환된다. 1String newObj = new String(&quot;object&quot;); 그렇다면 String literal을 사용하는 것은 위 방식과 무슨 차이를 가지고 있을까? 1String newObj = &quot;object&quot;; JVM은 String literal을 JVM Heap 영역안의 string constant pool area에 저장한다. string literal을 사용하게 되면 JVM은 다음과 같이 동작한다. string constant pool area에 같은 content를 가진 object가 있는지 확인한다. 있다면 새로운 객체를 만들지 않고, 해당 object의 참조값을 반환한다.없으면 새로운 객체를 만들어 string constant pool area에 저장하고 그 참조값을 반환한다. == 연산자를 사용해 객체의 주소값을 비교해보면 다음과 같은 결과를 볼 수 있다. 123456789101112131415161718192021public class StringExamples{ public static void main(String[] args) { //Creating string objects using literals String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; System.out.println(s1 == s2); //Output : true //Creating string objects using new operator String s3 = new String(&quot;abc&quot;); String s4 = new String(&quot;abc&quot;); System.out.println(s3 == s4); //Output : false }} (reference to string contant pool : https://javaconceptoftheday.com/how-the-strings-are-stored-in-the-memory/ ) 정리해서 말하면 불필요하게 new를 하면 쓸데없이 JVM의 메모리만 갉아먹는다는 소리다. 물론 GC가 참조되지 않는 객체는 메모리에서 내리긴 하겠지만, literal 방식에 비해서 성능이 떨어진다. 따라서 생성자 대신 static factory method를 제공하는 경우, static factory method를 사용하면 불필요한 객체 사용을 피할 수 있다. 123456// 예시코드 String = &quot;true&quot;;// 생성자방식Boolean rs1 = Boolean(String);// static factory method; Boolean rs2 = Boolean.valueOf(String); static method를 통해 instance 생성이전에 class loading 시점에서 memory공간이 할당되고 초기화됨으로, 불필요한 객체 생성을 피할수 있다.","link":"/2021/07/22/2021-07-22-item6/"},{"title":"Item5. 자원을 직접 명시하지 말고, DI를 통해 객체를 주입받자","text":"의존관계에 있는 class를 직접 명시하는 방식(static field)은 변경에 유연성을 가지기 힘들다. 그렇다면 어떤 구조가 적합할까? 많은 class는 다른 class들과 의존관계를 갖는다.이때 정적 유틸리티성 class로 의존관계를 맺는 것을 자주 볼 수 있다 (Item4)예를 들면 아래의 Spellchecker class는 Dictionary class와 의존관계를 가진다. 1234567891011public class SpellChecker // 정적 유틸리티성 클래스를 통해서 의존관계를 맺는다. private static final Dictionary dictionary = ...; private SpellChecker(){}; public static boolean isValid(String word){ /// }; public static List&lt;String&gt; suggestion(String typo){ /// }} 또는 singleton으로 구현되어 있는 경우도 자주 볼 수 있다. 12345678910111213public class SpellChecker { private final Dictionary dictionary = new Dictionary(); // private 생성자를 통해서 외부에서 객체 생성을 막고 private SpellChecker(){}; // class로딩시점에 딱한번 초기화되는 static method로 instance를 호출할 수 있게 한다. public static SpellChecker INSTANCE = new SpellChecker(); public static boolean isValid(String word){ /// }; public static List&lt;String&gt; suggestion(String typo){ /// }} 위 두 방식의 단점은 변경이 용이하지 않다는 점이다.예를 들면 Dictionary Class를 한국어용 사전, 영어용 사전…기타 등등 으로 요구사항에 변경이 생길 수도 있다. 사용하는 class에 따라 동작이 달라지는 class는 위 singleton,static 유틸리티성 class 방식이 적합하지 않다. 그렇다면 변경에 용이한 구조는 어떻게 설계해야할까? 123456789101112131415public class SpellChecker { private final Dictionary dictionary; // 상위Type에 의존하여 주입받는다. public SpellChecker(Dictionary koreanDictionary){ this.dictionary = Objects.requireNonNull(koreanDictionary); } public static boolean isValid(String word){ /// }; public static List&lt;String&gt; suggestion(String typo){ /// }} Dictionary를 상속 계층구조로 잡고 하위 계층구조로 여러가지 종류의 사전이 있었을때, 외부 사전 class를 주입받을 때, 상위 type에 의존하도록 주입하는 방식이다. 이처럼 구현하면 instance를 생성하려고 할떄 원하는 하위 type으로 넘겨받아서 객체를 생성하면된다. 12345SpellChecker spellChecker1 = new SpellChecker(koreanDictionary);SpellChecker spellChecker2 = new SpellChecker(englishDictionary);//예시코드spellChecker1.translate(&quot;...&quot;)// 안녕하세요spellChekcer2.translate(&quot;...&quot;)// Hello 책에서 사용하고 있는 말을 그대로 강조하여 쓰면, 다음과 같다. 의존 객체주입(Dependency Injection) 방식 : “인스턴스를 생성할 떄,생성자에 필요한 자원을 넘겨주는 방식” 의존 객체 주입 방식은 생성자, 정적팩터리,빌더패턴에 똑같이 응용이 가능하다. 의존 객체 주입 패턴의 변형으로 , 생성자에 자원 팩터리를 넘겨주는 방식이 있다 DI 패턴을 이용한 Framework 는 대표적으로 Spring이 매우 매우 유명하다. *Factory란 호출할떄마다 특정타입의 인스턴스를 반복해서 만들어주는 객체를 말하며, 디자인패턴을 말한다. 자세한 내용 참조 (Design Pattern/Factory method Pattern) Java 8 에서 나온 Supplier&lt;T’&gt; Interface가 Factory Method를 표현한 예다. Factory Method 관련해서는 책 뒷부분에서 추가로 살펴볼 예정이다. 정리: class가 다른 class와 의존관계를 가지고, 다른 class의 type에 따라 class의 동작에 영향을 준다면, singleton pattern 과 static class 사용은 지양하고, 필요한 class를 생성자에 넘겨주어 주입받는 방식 (DI) 을 사용함으로서 class의 변경 용이성, 테스트 용이성 , 재사용성을 개선하자","link":"/2021/07/21/2021-07-21-item5/"},{"title":"brower javascript test하기(Mocha,NodeJs)","text":"Nodejs의 express framework를 사용하여 Backend개발을 하면서 단위 테스트는 mocha를 활용하였다. 서버 코드는 mocha로 테스트를 진행하였는데, browser(client) 쪽 javascript 도 mocha (javascript test framework)가 지원한다고 한다. 기본 템플릿은 다음과 같다 유의할점은 command line interfcae를 지원해주지 않고, html 을 통해서 테스트 결과를 확인할 수 있다. mocha.setup(‘{mocha interface style}’) ex) mocha.setup(‘bdd’),mocha.setup(‘tdd’)를 통해 테스트 인터페이스 스타일을 지정하고, test할 client javascript file을 import한다. 이떄, javsacript module 시스템을 브라우저에서 하려면type=”module”을 명시해야 한다. internet explorer는 아예 지원되지 않으니 참고하자. https://developer.mozilla.org/ko/docs/orphaned/Web/JavaScript/Guide/Modules javascript에서 module loading 방식은 여러개가 있다. 아래에 간략하게 정리하였다. 1. AMD(Asynchronous module definition) module loader AMD는 네트워크를 통해서 모듈을 받아야하는 브라우저 환경에서 javascript 환경에 유연하다. 비동기적으로 모듈을 import 할 수 있다. define syntax를 사용한다. 2. CommonJs module loader module.export , require syntax 로 모듈을 export, import 한다. 필요한 모든 파일이 로컬 디스크에 있다는 전제로 한다. 즉 serverside javascript 환경을 전제로 한다. 3. ECMAScript 6 (ES6) ES6부터 javascript module을 기본적으로 지원한다. export, import ~ from “path.js” syntax로 모듈을 export,import한다. Typescript에서는 ES6방식의 syntax를 지원한다. (Reference to CommonJS vs AMD : https://d2.naver.com/helloworld/12864) 실제로는 Commonjs 와 AMD방식을 모두 지원하는 module bundler (ex) webpack , browserify ) 를 통해 의존관계에 있는 모듈들을 엮어서 하나의 bundle 파일로 만드는 방식을 자주 사용한다. 아래의 테스트 환경은 node js에서 작성한 코드를 browserify라는 module bundler를 사용하여 의존관계가 있는 모듈들을 하나의 파일로 엮었다. (test_bundle~.js ) (Reference to browserify module bundler : https://github.com/browserify/browserify ) 1234567891011121314151617181920212223242526&lt;!-- test.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;script&gt;var exports = {};&lt;/script&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Mocha Tests&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/mocha/mocha.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mocha&quot;&gt;&lt;/div&gt; &lt;script src=&quot;https://unpkg.com/chai/chai.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/mocha/mocha.js&quot;&gt;&lt;/script&gt; &lt;script class=&quot;mocha-init&quot;&gt; mocha.setup('bdd'); mocha.checkLeaks(); &lt;/script&gt; &lt;script type=&quot;module&quot; src=&quot;./bundle_testCalculator.js&quot;&gt;&lt;/script&gt; &lt;script class=&quot;mocha-exec&quot;&gt; mocha.run(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819// calculator.tsclass Calculator{ constructor(){ } public static add(num1:number,num2:number) :number{ return num1+num2; } public static minus(num1:number,num2:number):number{ return num1-num2; } public static multiply(num1:number,num2:number):number{ return num1*num2; } public static divide(num1:number,num2:number):number{ return num1/num2; }}export {Calculator}; 테스트에 사용할 샘플 코드를 작성하였다. 간단하게 계산기 기능을 구현한 class이다. 123456789101112131415161718192021222324252627// testCalculator.tsimport * as assert from &quot;assert&quot;;import {describe,it} from &quot;mocha&quot;;import {Calculator} from &quot;./calculator&quot;;describe(&quot;test Calculator on browser&quot;,()=&gt;{ // -- testcase --- const num1=20; const num2=30; // ----------- it(&quot;should add number&quot;,():void=&gt;{ assert.strictEqual(Calculator.add(num1,num2),num1+num2); }) it(&quot;should minus number&quot;,():void=&gt;{ assert.strictEqual(Calculator.minus(num1,num2),num1-num2); }) it(&quot;should multiply number&quot;,():void=&gt;{ assert.strictEqual(Calculator.multiply(num1,num2),num1*num2); }) it(&quot;should divide number&quot;,():void=&gt;{ assert.strictEqual(Calculator.divide(num1,num2),num1/num2); }) it(&quot;실패할 테스트입니다.&quot;,()=&gt;{ assert.strictEqual(Calculator.add(num1,num2),num1*num2); })}) live server로 해당 html 을 열어보면 테스트 결과가 출력되는 것을 확인할 수 있다.","link":"/2021/07/22/2021-07-22-mocha-1/"},{"title":"Template method pattern","text":"Template Method Pattern이란? SuperClass에서 수행할 알고리즘의 각 단계를 미리 정의해두고 , 그 중 하나 이상의 단계를 SubClass에서 구현하는 디자인 패턴 예시를 들어 template method pattern 을 이해하기 위해서 예시를 가지고 왔다. 커피를 아래의 일련의 알고리즘에 따라 만든다고 가정하였다. 1234567891011121314151617181920public class Coffee { void prepareRecipe(){ boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); } private void addSugarAndMilk() { System.out.println(&quot; adding sugar and milk &quot; ); } private void pourInCup() { System.out.println(&quot; pour in cup ~ &quot; ); } private void brewCoffeeGrinds() { System.out.println(&quot; filtering coffee &quot; ); } private void boilWater() { System.out.println(&quot; boiling water &quot; ); }} 이제 위의 알고리즘에 따라 커피를 만들 수 있다. 그런데 만약 홍차를 만들어 달라는 추가요청이 들어왔다. 1234567891011121314151617181920public class Tea { void prepareRecipe(){ boilWater(); steepTeaBag(); pourInCup(); addLemon(); } private void addLemon() { System.out.println(&quot; adding lemon &quot; ); } private void pourInCup() { System.out.println(&quot; pour in cup ~ &quot; ); } private void steepTeaBag() { System.out.println(&quot; steeping tea bag&quot; ); } private void boilWater() { System.out.println(&quot; boiling water &quot; ); }} 알고리즘을 수정하여 차를 만들었다. 그런데 만약 이외에도 스무디,음료수 … 각종각색의 음료수 주문이 들어온다고 하면 매번 똑같이 class를 만드는 것은 너무 낭비이다. 위에 커피와 차 class만 보더라도 중복되는 코드가 많다. 다음과 같이 super class에서 일련의 알고리즘이 수행될 순서를 정해두고, 공통된 부분은 default method로 구현한다. sub class마다 로직이 다른 것은 sub class가 상속받아 구현할 수 있도록 한다. 1234567891011121314151617181920public abstract class CaffeineBeverage {// sub class에서 상속받아 overriding 불가능하도록 final로 선언// 일련의 절차들을 정의해두고 ,sub class마다 다양한 행위를 하는 부분은 추상화 method로 선언 final void prepareRecipe(){ boilWater(); brew(); pourInCup(); addCondiments(); } private void boilWater() { System.out.println(&quot; boiling water &quot; ); } private void pourInCup() { System.out.println(&quot; pour in cup ~ &quot; ); }// abstract protected void brew(); abstract protected void addCondiments();} 1234567891011121314151617181920public class Tea extends CaffeineBeverage{ @Override protected void brew() { } @Override protected void addCondiments() { }}public class Coffee extends CaffeineBeverage{ @Override protected void brew() { } @Override protected void addCondiments() { }} 알고리즘을 super class에서 수행될 순서를 정의해두고, tea , coffee 는 각 수행될 단계를 구체화 한다. 이를 IoC를 이용한 디자인 패턴이라고도 한다 (reference - toby’s spring 3.1 )제어의 흐름을 tea,coffe가 가져가는게 아닌 beverage superclass가 제어의 흐름을 가져가기 때문이다. 어쨌거나 위 코드의 장점은 중복코드가 제거되었고, 확장이 용이하다. 마지막으로, 책에서 정의하는 template method pattern을 인용하면 다음과 같다. template method pattern에서는 알고리즘의 골격을 정의합니다. 알고리즘의 여러 단계 중 일부는 subClass에서 구현할 수 있습니다. 이를 이용하면 알고리즘의 구조는 그대로 유지하면서 subclass에서 특정단계를 overriding할 수 있습니다. Reference Head First Design Patterns: A Brain-Friendly Guide (Head First Design Patterns: A Brain-Friendly Guide)","link":"/2021/07/24/2021-07-24-Template-method-pattern/"},{"title":"Merge Sort","text":"merge sort(합병정렬) 은 크기가 N인 입력을 1/n 크기로 분할하고, 각각에 대해 재귀적으로 다시 합병정렬을 수행한 후,n개의 정렬된 부분은 합병하는 정렬 알고리즘이다. 대부분 n은 2로, 2-way 병합정렬을 수행한다. 합병정렬 알고리즘은 분할정복(divide &amp; conquer) 알고리즘에 속한다. 분할정복알고리즘은 보통 주어진 집합의 데이터를 작은 부분집합들로 나누어서(divide) , 부분집합에서 문제를 해결하고 (conquer) , 부분집합들을 합쳐서 문제를 푸는 (combine) 3가지 단계로 이루어 진다. 보통 재귀적으로 푼다. 병합정렬의 경우 , combine하는 작업이 conquer 과정과 일치한다. 즉 combine하는 과정에서 배열을 정렬하며 문제를 해결한다. 파이썬으로 구현해본 mergeSort는 다음과 같다. 이미 정렬된 2개의 배열을 병합하는 과정은 필요가 없으므로 중간에 arr[mid] 값이 arr[mid+1]값보다 작은 경우에는 병합과정이 수행되지 않도록 구현되어 있다. 자바 버젼은 파이썬 버젼과 syntax외에는 흐름 자체는 큰 차이는 없으나, 정렬결과를 임시적으로 저장할 배열을 미리 초기화해두는 점만 유의하면 되겠다. (code참조) Python Version. 123456789101112131415161718192021222324252627282930313233343536def merge_sort(arr,lt,rt): # 하나의 부분집합은 이미 정렬된 부분집합으로 보고 반환한다. if(lt&gt;=rt): return #절반으로 부분집합을 나누어 각각에 대해 다시 재귀적으로 호출한다. mid = (lt+rt)//2; merge_sort(arr,lt,mid); merge_sort(arr,mid+1,rt); p1 = lt; p2 = mid+1; #combine 과정 (정렬된 두개의 리스트를 합친다) ## 최적화 : arr[mid] 값이 arr[mid+1] 보다 작다면 이미 정렬되어있다는 의미므로 굳이 아래의 정렬과정을 반복할필요가없다. if(arr[mid] &lt;= arr[mid+1]): return; tmp = []; while p1&lt;=mid and p2&lt;=rt: if(arr[p1] &gt;= arr[p2]): tmp.append(arr[p2]); p2+=1; else: tmp.append(arr[p1]); p1+=1; if(p1&lt;=mid): tmp += arr[p1:mid+1]; else: tmp += arr[p2:rt+1]; arr[lt:rt+1] = tmp;if __name__==&quot;__main__&quot;: arr = [1,4,7,24,6,8,21,12,63]; print(&quot;before merge_sort : {}&quot;.format(arr)); merge_sort(arr,0,len(arr)-1); print(&quot;after merge_sort : {}&quot;.format(arr)); Java version. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MergeSort { /*** * @param arr = 정렬할 배열 * @param lt = 분할 및 병합할 시작위치 * @param rt = 분할 및 병합할 마지막위치 * @param buff = 임시적으로 정렬된 결과를 담을 배열 */ public static void mergeSort(int[] arr,int lt, int rt,int[] buff){ if(lt&gt;=rt){ return; } int mid = (lt+rt)/2; // 1. divide mergeSort(arr,lt,mid,buff); mergeSort(arr,mid+1,rt,buff); int index = lt; int p1 = lt; int p2 = mid+1; if(arr[mid] &lt;= arr[mid+1]){ return; } // 2. combine /*** * mid을 중심으로 2개의 정렬된 배열을 병합하는 과정 * p1(lt)가 p2(mid+1) 를 계속해서 비교해서 더 작은값을 임시배열에 삼입한다. * p2가 rt(병합할 배열의 마지막 위치)값을 넘은경우, p1에 남은 요소가 있으면 * 해당 값들을 임시배열에 삼입. 반대의 경우 (p1이 mid값을 넘은 경우)도 동일하게 * p2에 남은 요소가 있다면 해당 값들을 임시배열에 삼입 */ while(p1&lt;=mid || p2&lt;=rt) { if( p2 &gt; rt || (p1&lt;=mid &amp;&amp; arr[p1]&lt;arr[p2] )){ buff[index++] = arr[p1++]; } else{ buff[index++] = arr[p2++]; } } for(int i = lt ; i &lt;= rt ; i++){ arr[i] = buff[i]; } } public static void main(String[] args){ int[] arr = {1,4,7,24,6,8,21,12,63}; /* 중간에 정렬결과를 저장할 buffer를 만든다. method안에서 buffer를 만들게 되면 계속해서 메모리 공간이 잡힘으로, 정렬전에 미리 공간을 할당하고, 정렬후에는 GC 대상이 되도록 null값을 할당한다. */ int[] buff = new int[arr.length]; System.out.println(&quot;Arrays.toString(arr) = &quot; + Arrays.toString(arr)); mergeSort(arr,0,arr.length-1,buff); System.out.println(&quot;Arrays.toString(arr) = &quot; + Arrays.toString(arr)); buff = null; }} 시간,공간복잡도merge sort의 시간복잡도는 worst case에도 O(NlogN)의 시간복잡도를 가지며, 입력의 크기 만큼의 임시 버퍼를 만들어주어야 함으로, O(N)의 공간 복잡도를 가진다.","link":"/2021/07/24/2021-07-24-merge-sort-DESKTOP-QF32SHN/"},{"title":"IoC(inversion of control)의 개념","text":"간단정리IoC(Inversion of Control)란?프로그램의 제어흐름을 뒤바꾸는 것이다.개발자가 직접 객체간의 관계설정이나 객체의 생명주기를 조절하는 것이 아니라, container와 같은 다른 대상이 이를 제어하는 것을 말한다. Framework가 IoC가 적용된 기술이다. 정확히 말하면 spring framework는 IoC를 효율적으로 적용한 것이지, spring 없이도 IoC를 구현할 수 있다. framework vs library의 차이점 Framework는 IoC가 적용된 기술이다. 프로그램의 제어흐름을 Framework가 가져간다. Library는 개발자가 직접 제어흐름을 조절한다. 이 userDaoTest class가 어떤 객체를 선택할지 결정해주어 생성해주기 때문에, 가장 단순한 IoC Framework라고 할 수 있다.다만 test용 class는 객체 생성을 담당하는 것과는 거리가 멀기 때문에, Factory Class로 변경하였다. Factory는 객체의 생성을 담당하는 class로 Desgin Pattern에서 포스팅하였다.*주의사항:Factory는 엄밀히 말하면 디자인 패턴이 아니다. 123456789101112131415161718public class DaoFactory { // 어떤 DB연결정보를 구현한 객체를 사용할지 결정하여, 해당 객체를 DI받은 객체를 돌려준다. public UserDao userDao(){ ConnectionMaker connectionMaker = new DconnectionMaker(); UserDao userDao = new UserDao(connectionMaker); return userDao; }}public class UserDaoTest { public static void main(String[] args) { //Factory class를 통해 DI받은 userDao 객체를 만들어서 사용한다. UserDao userDao = new DaoFactory().userDao(); }} 위 구조에서 Dao의 명세가 달라진 여러 class로 확장을 한다고 가정하면 다음과 같을 것이다. 제어의 흐름을 DaoFactory가 가져가고, UsetDao class가 어떤 객체를 주입받을지 결정한다. 이런 측면에서 작은 IoC Framework라고 할 수 있다. 123456789101112public class DaoFactory_V1 { public UserDao userDao(){ UserDao userDao = new UserDao(new DconnectionMaker()); return userDao; } public AccountDao accountDao(){ return new AccountDao(new DconnectionMaker()); }} 중복된 코드는 다음과 같이 method extraction을 통해서 변경의 원인이 일어나는 곳을 한곳으로 만들 수 있겠다. 1234567891011121314public class DaoFactory_V2 { // method extraction public ConnectionMaker connectionMaker(){ return new DconnectionMaker(); } public UserDao userDao(){ return new UserDao(connectionMaker()); } public AccountDao accountDao(){ return new AccountDao(connectionMaker()); }} 다음 포스팅에서는 드디어 스프링이 제공하는 IoC에 대해서 살펴보려고 한다.","link":"/2021/07/24/2021-07-24-spring-02/"},{"title":"Merge Sort","text":"merge sort(합병정렬) 은 크기가 N인 입력을 1/n 크기로 분할하고, 각각에 대해 재귀적으로 다시 합병정렬을 수행한 후,n개의 정렬된 부분은 합병하는 정렬 알고리즘이다. 대부분 n은 2로, 2-way 병합정렬을 수행한다. 합병정렬 알고리즘은 분할정복(divide &amp; conquer) 알고리즘에 속한다. 분할정복알고리즘은 보통 주어진 집합의 데이터를 작은 부분집합들로 나누어서(divide) , 부분집합에서 문제를 해결하고 (conquer) , 부분집합들을 합쳐서 문제를 푸는 (combine) 3가지 단계로 이루어 진다. 보통 재귀적으로 푼다. 병합정렬의 경우 , combine하는 작업이 conquer 과정과 일치한다. 즉 combine하는 과정에서 배열을 정렬하며 문제를 해결한다. 파이썬으로 구현해본 mergeSort는 다음과 같다. 이미 정렬된 2개의 배열을 병합하는 과정은 필요가 없으므로 중간에 arr[mid] 값이 arr[mid+1]값보다 작은 경우에는 병합과정이 수행되지 않도록 구현되어 있다. 자바 버젼은 파이썬 버젼과 syntax외에는 흐름 자체는 큰 차이는 없으나, 정렬결과를 임시적으로 저장할 배열을 미리 초기화해두는 점만 유의하면 되겠다. (code참조) Python Version. 123456789101112131415161718192021222324252627282930313233343536def merge_sort(arr,lt,rt): # 하나의 부분집합은 이미 정렬된 부분집합으로 보고 반환한다. if(lt&gt;=rt): return #절반으로 부분집합을 나누어 각각에 대해 다시 재귀적으로 호출한다. mid = (lt+rt)//2; merge_sort(arr,lt,mid); merge_sort(arr,mid+1,rt); p1 = lt; p2 = mid+1; #combine 과정 (정렬된 두개의 리스트를 합친다) ## 최적화 : arr[mid] 값이 arr[mid+1] 보다 작다면 이미 정렬되어있다는 의미므로 굳이 아래의 정렬과정을 반복할필요가없다. if(arr[mid] &lt;= arr[mid+1]): return; tmp = []; while p1&lt;=mid and p2&lt;=rt: if(arr[p1] &gt;= arr[p2]): tmp.append(arr[p2]); p2+=1; else: tmp.append(arr[p1]); p1+=1; if(p1&lt;=mid): tmp += arr[p1:mid+1]; else: tmp += arr[p2:rt+1]; arr[lt:rt+1] = tmp;if __name__==&quot;__main__&quot;: arr = [1,4,7,24,6,8,21,12,63]; print(&quot;before merge_sort : {}&quot;.format(arr)); merge_sort(arr,0,len(arr)-1); print(&quot;after merge_sort : {}&quot;.format(arr)); Java version. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MergeSort { /*** * @param arr = 정렬할 배열 * @param lt = 분할 및 병합할 시작위치 * @param rt = 분할 및 병합할 마지막위치 * @param buff = 임시적으로 정렬된 결과를 담을 배열 */ public static void mergeSort(int[] arr,int lt, int rt,int[] buff){ if(lt&gt;=rt){ return; } int mid = (lt+rt)/2; // 1. divide mergeSort(arr,lt,mid,buff); mergeSort(arr,mid+1,rt,buff); int index = lt; int p1 = lt; int p2 = mid+1; if(arr[mid] &lt;= arr[mid+1]){ return; } // 2. combine /*** * mid을 중심으로 2개의 정렬된 배열을 병합하는 과정 * p1(lt)가 p2(mid+1) 를 계속해서 비교해서 더 작은값을 임시배열에 삼입한다. * p2가 rt(병합할 배열의 마지막 위치)값을 넘은경우, p1에 남은 요소가 있으면 * 해당 값들을 임시배열에 삼입. 반대의 경우 (p1이 mid값을 넘은 경우)도 동일하게 * p2에 남은 요소가 있다면 해당 값들을 임시배열에 삼입 */ while(p1&lt;=mid || p2&lt;=rt) { if( p2 &gt; rt || (p1&lt;=mid &amp;&amp; arr[p1]&lt;arr[p2] )){ buff[index++] = arr[p1++]; } else{ buff[index++] = arr[p2++]; } } for(int i = lt ; i &lt;= rt ; i++){ arr[i] = buff[i]; } } public static void main(String[] args){ int[] arr = {1,4,7,24,6,8,21,12,63}; /* 중간에 정렬결과를 저장할 buffer를 만든다. method안에서 buffer를 만들게 되면 계속해서 메모리 공간이 잡힘으로, 정렬전에 미리 공간을 할당하고, 정렬후에는 GC 대상이 되도록 null값을 할당한다. */ int[] buff = new int[arr.length]; System.out.println(&quot;Arrays.toString(arr) = &quot; + Arrays.toString(arr)); mergeSort(arr,0,arr.length-1,buff); System.out.println(&quot;Arrays.toString(arr) = &quot; + Arrays.toString(arr)); buff = null; }} 시간,공간복잡도merge sort의 시간복잡도는 worst case에도 O(NlogN)의 시간복잡도를 가지며, 입력의 크기 만큼의 임시 버퍼를 만들어주어야 함으로, O(N)의 공간 복잡도를 가진다.","link":"/2021/07/24/2021-07-24-merge-sort/"},{"title":"Observer pattern","text":"Observer Pattern은 한 객체(Subject)의 상태가 바뀌면 그 객체에 의존하는 다른 객체(Observer)에게 알려져, 자동으로 내용이 갱신되는 일대다 (One-To-Many ,One Subject to Many Observer ) 의존성을 정의한다. java 에서 built-in observer pattern을 일부 지원하지만 , observer pattern 을 이해하기 위해서 예시를 들고 왔다. 기상 모니터링 App을 만든다고 가정하였을때, 기상 스테이션이 온도,습도,압력센서를 통해 데이터를 받고,WeatherData 객체가 이 데이터를 여러 Display장비에 온도,습도,압력이 변하면 업데이트를 계속해서 해주는 상황이라고 가정하자. 이 경우에 WeatherData 객체가 Subject 객체가 될 것이고, Observer 객체들은 여러 Display 객체라고 볼 수 있을 것이다. observer pattern의 핵심 Class Diagram을 살펴보면 상태가 계속 변하는 subject객체에 interface를 두어, observer를 등록,해제, oberser에게 상태변화를 알리는 공통적인 method를 둔다. subject 객체의 상태를 알림받는 observer 객체에서 interface를 두어, observer의 변화시, 변화에 따른 logic을 처리하는 method를 둔다. subject,observer는 인터페이스 추상화 계층을 통해서 coupling되어 있다. 즉 , 하위 구현 class가 어떻게 구현 되었는지는 관심도 없고 알 필요도 없다. (=loose coupling) 책에서 Observer Pattern 을 이해하기 쉽게 든 예는 신문사와 구독자간의 관계이다. 특정 주제를 계속해서 업데이트하는 신문사는 구독자에게 정보를 알려준다. 특정 신문사는 여러 구독자를 가진다 (One-to-Many relationship) 이 상황에서는 신문사가 Subject 객체, 구독자가 Observer 객체 라고 볼 수 있을 것이다. 어쩄거나 위의 기상 시스템 app을 예시로 observer pattern 을살펴보면 다음과 같다. 123456789101112public interface Subject { // Subject Object 의 상태변화를 추적하는 Observer object 등록 public void registerObserver(Observer o); // Subject Object 의 상태변화를 추적하는 Observer object 제거 public void removeObserver(Observer o); // Subject Object의 상태변화 발생시 Observer object에게 알림 public void notifyObservers();} subject interface에서는 이를 구현한 subject 객체의 상태 변화를 알리고, observer를 등록,해제하는 method 명세를 가지고 있다. 123public interface Observer { public void update(float temp,float humidity,float pressure);} observer interface에서는 subject 상태 변화를 듣고 있다가, 상태가 변화시에, 어떤 행동을 취하는 method 명세를 가지고 있다. 이제 각 인터페이스를 구현한 구체 class를 살펴보자 12345678910111213141516171819202122232425262728293031323334353637public class WeatherData implements Subject{ private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() { this.observers = new ArrayList(); } @Override public void registerObserver(Observer o) { this.observers.add(o); } @Override public void removeObserver(Observer o) { int index = this.observers.indexOf(o); if( index &gt;= 0){ observers.remove(index); } } @Override public void notifyObservers() { observers.stream().forEach((obs)-&gt;{ obs.update(temperature,humidity,pressure); }); } public void measurementChanged(){ notifyObservers(); } public void setMeasurements(float temperature,float humidity,float pressure){ this.temperature=temperature; this.humidity =humidity; this.pressure = pressure; measurementChanged(); }} 앞서 예시를 들었던 것처럼 여기서는 기상정보에 변화가 있었을때 이를 observer 객체에게 알려주는 시스템이다. 따라서 기상정보가 subject가 되고, 이를 display해주는 객체가 observer가 된다. setMeasurements method를 통해 기상변화가 있으면, notifyObserver method를 통해서 등록된 observer의 update method를 호출한다. 123456789101112131415161718192021222324252627// observer classpublic class CurrentConditionsDisplay implements Observer,DisplayElement{ private float temperature; private float humidity; private float pressure; private Subject weatherData; // 특정 subject class를 등록하고, subject class에서도 등록을 설정한다. public CurrentConditionsDisplay(Subject weatherData) { this.weatherData = weatherData; weatherData.registerObserver(this); } @Override public void display() { System.out.println(&quot; Current Condtioins : &quot; + temperature + &quot;/&quot;+ humidity + &quot;/&quot;+ pressure); } @Override public void update(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure =pressure; display(); }} 테스트 코드를 보면 subject , observer object에 서로 의존관계를 설정해두고(many-to-one) subject에 변화시에 자동적으로 observer object에 update logic이 실행된다. 123456789101112131415public class TestWeatherStation { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData); weatherData.setMeasurements(80,65,30.4f); weatherData.setMeasurements(40,25,20.4f); weatherData.setMeasurements(60,75,29.4f); } // --------output-------- // Current Condtioins : 80.0/65.0/30.4 // Current Condtioins : 40.0/25.0/20.4 // Current Condtioins : 60.0/75.0/29.4} Java 내장 Observer Pattern은 ?현재 java 에서 제공하고 있는 java.util.Observable 이 observer pattern을 구현하고 있지만, 현재 deprecated되어있다. 큰 원인은 not serializable (객체를 직렬화할수 없음) Not thread-safe (concurrent programming시, 안전하지않음) 대체하는 내장 library는 다음과 같으니, 추후에 observer pattern 구현시, 참고하자(https://docs.oracle.com/javase/9/docs/api/java/beans/PropertyChangeEvent.html ) Reference Head First Design Patterns: A Brain-Friendly Guide (Head First Design Patterns: A Brain-Friendly Guide)","link":"/2021/07/25/2021-07-25-observer-pattern/"},{"title":"Spring IoC container","text":"토비의 spring이전까지는 Spring 을 적용하지 않고, IoC에 대해서 살펴보았다.지금부터는 Spring이 IoC를 어떤형태로 구현하였는지 살펴보겠다.그전에 spring에서 사용하는 용어를 정리하면 다음과 같다. - Bean : spring이 제어권을 가지고 직접 만들고 , 관계를 설정하는 객체 - Bean Factory : Bean의 생성과 관계설정과 같은 제어를 담당하는 IoC 객체 (=이를 확장된 의미에서는 Application Context라고 한다.) Bean Factory vs Application Context (=IoC container,Spring container) Bean Factory : Bean을 생성하고 관계를 설정하는 IoC의 기본기능. Application Context : application 전반에 걸쳐 모든 구성 요소의 제어를 담당하는 IoC 엔진 (Bean Factory에 Spring이 제공하는 application 지원 기능이 포함되었다고 생각하면 된다.) 으로, application context는 Bean Factory를 상속받는다. 이전시간까지 만들었던 IoC기능을 하던 DaoFactory class를 spring의 IoC 설정정보로 변경하면 다음과 같다. 1234567891011121314151617import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;// application context가 사용할 설정 정보임을 명시@Configurationpublic class DaoFactory { // spring bean 객체를 만드는 method임을 명시 , method이름이 Bean이 된다. @Bean public ConnectionMaker connectionMaker(){ return new DconnectionMaker(); } @Bean public UserDao userDao(){ return new UserDao(connectionMaker()); }} 이제 위 설정정보를 기반으로 application context(=IoC 역할을 해주는 객체)를 다음과 같이 만들 수 있다. 1234567891011public static void main(String[] args) { ApplicationContext applicationContext = new // AnnotationConfigApplicationContext(&quot;설정정보.class&quot;); AnnotationConfigApplicationContext(DaoFactory.class); // getBean(bean이름,bean.class); UserDao dao = applicationContext.getBean(&quot;userDao&quot;, UserDao.class); System.out.println(&quot;dao = &quot; + dao);} ApplicationContext는 interface type이고 그 구체 type으로는 여러 종류가 있다. 여기는 annotation기반으로 설정정보를 만들었음으로, AnnotationConfigApplication을 사용하였다. 위 코드의 흐름을 요약하면 annotation기반의 설정정보를 통해서 IoC 역할(=bean객체의 생명주기 및 의존성 관리)을 담당하는 application context를 만들었고, application context는 설정정보에 @Bean을 보고 bean 목록을 만들어둔다.client가 getBean(“@Bean Method명”,”bean.class”);을 호출하면 이 목록에 해당 bean이 있는지 확인하고 있다면 , @Bean method를 호출해서 Bean 객체를 반환받아 넘겨준다. 그렇다면 기존의 IoC Container와 spring application context간에는 무슨 차이점이 있을까?spring application context에서는 싱글톤으로 하나의 bean 객체만 반환한다. 떄문에 spring application context를 singleton registry라고도 부르기도 한다. 123456789101112131415public static void main(String[] args) { DaoFactory daoFactory = new DaoFactory(); UserDao userDao1 = daoFactory.userDao(); UserDao userDao2 = daoFactory.userDao(); System.out.printf(&quot;same userDao : %b &quot;,userDao1 == userDao2 ); // false ApplicationContext applicationContext = new AnnotationConfigApplicationContext(DaoFactory.class); UserDao spring_dao1 = applicationContext.getBean(&quot;userDao&quot;, UserDao.class); UserDao spring_dao2 = applicationContext.getBean(&quot;userDao&quot;, UserDao.class); System.out.printf(&quot;same bean obj : %b&quot; , spring_dao1 == spring_dao2); // true} 왜 spring은 singleton으로 bean 객체를 관리하는 것일까?spring은 thread-based concurrent server다.client reqeuest가 오면 , network layer에서 I/O demultiplexing을 통해서 어느 TCP socket으로 client request를 mapping한지 결정할것이다. (당연히 Http는 잘 알겠지만, TCP 위에서 동작하는 application layer protocol이다. )thread기반 concurrent 서버에서는 master thread가 listen file descriptor를 통해 client 요청을 기다리면서 blocking 되었다가, client 요청이 오면 이를 accept하고 peer thread를 만들어 준 뒤, connected file descriptor를 넘겨주고, peer thread가 client request에 mapping되어 client 요청을 수행하고, 응답한뒤, kernel에서 thread resource를 reaping한다. 위와 같은 상황에서 client 요청이 수천개가 들어오면 각각의 peer thread가 모두 동일한 객체를 new해서 생성한다고 하면 서버에 부하가 상당 할 것이다.","link":"/2021/07/25/2021-07-25-spring-03/"},{"title":"Kubernetes의 등장원인과 장점 , Kubernates의 구성요소","text":"kubernetes란?container화된 서비스를 관리하기 위한 오픈소스 platform 쿠버네티스가 등장한 이유는? 가상화 도입 이전에기존에 app 배포할떄는 여러 app을 물리서버에서 실행하여 배포하였다. 각 app이 사용할 수 있는 resource를 제한할수 없는 방법도 없었으며, hardware, os 구성을 별도로 가져가지 못했다. 가상화 도입 이후에는 하나의 물리서버에서 여러개의 VM 실행이 가능해졌으며, VM instance는 Hypervisor에 의해 hw resource 할당량을 제한받고, (정확히 말하면 가상화 방법도 type1, type 2 방식이 있다. ) guestOS 선택까지 가능함으로 각 VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성 요소를 실행하는 하나의 완전한 소프트웨어 기반의 컴퓨터라고도 볼 수 있다. container 기술 도입이후에는, 각 container가 별도의 GuestOS를 갖는 것이 아닌 하나의 hostOS를 공유하고, application binary code을 올린다.따라서 각각의 cotainer자체는 process라고도 볼 수 있으며, linux kernel function 인 namespace와 cgroup function을 통해서 process를 다른 process로부터 격리시킬 수 있다. namespaces : 별도의 파일 시스템, PID, net … 을 격리시킨다. (namespace를 격리시켜, 중복포트binding 등 충돌 방지) cgroup : 메모리 , cpu , network 등 리소스에 대한 할당량 제어 실제 app 은 (매우 단순한 app은 하나의 container에서 돌아가긴 하겠지만) 대부분의 경우 여러 container에 걸쳐서 돌아가며, 필요한 경우 여러 서버 host에 배포되는데, 이떄 쿠버네티스가 container의 상태 및 일정등을 지속적으로 관리한다. 예를 들어 하나의 container가 의도치 않게 down된다면 다른 container를 대신하여 띄워야 할 것이다. 이처럼 쿠버네티스는 분산시스템을 관리하기 위한 framework를 제공한다. 쿠버네티스의 장점을 요약해보면 다음과 같다. load balancing : container에 트래픽이 많으면 container를 배포하여 트래픽을 분산시킵니다. storage orchestration Automated rollouts and rollbacks : 배포된 container의 원하는 상태를 명시하면, 현재 상태를 원하는 상태로 변경 가능합니다, 예를 들면 새로운 컨테이너를 만들면 기존 컨테이너의 리소스를 새로운 컨테이너로 모두 할당하는 형태로 상태 변경이 가능합니다. Automatic bin packing : container화 된 작업을 실행하는데사용할 수 있는 kubernete cluster node를 제공하고, container가 필요로 하는 CPU와 메모리를 노드에 맞추어서 가장 잘 사용할 수 있도록 해준다. self-healing : 실패한 container을 재시작하고, container를 교체하는 작업등을 수행한다. 본격적으로 쿠버네티스 구성요소에 대해 알아보기전에 자주쓰이는 pod라는 용어를 정의하면 다음과 같다. Pod : kubernete cluster node에서 실행 중인 container의 집합 우선 기본적으로 kubernete가 실행되면 최소 하나 이상의 worker node로 이루어진 cluster node를 얻는다. worker node는 app의 구성요소인 파드(Pod)를 host한다. 즉, 장얘가 발생하더라도 여러개의 node가 있어 서비스가 지속 가능한 구조라는 뜻이다. kubernete component 는 크게 2가지 component로 구성된다.1. control plane component : cluster에 대한 전반적인 결정을 수행하고, cluster envent를 감지하고 반응한다.2. node component : 동작중인 pod를 유지시키고, kubernetes run time 환경을 제공한다. Control Plane component kube-apiserver : kubernetes api를 노출시키는 역할로 end-user가 control plane component에 명령어를 내릴 수 있게 해준다.주로 kubectl과 같은 CLI를 통해 명령어 질의를 날릴 수 있다. etcd : 모든 cluster data를 담는 key-value 저장소 (주요 저장소로 쓰려면 백업 필수 ) kube-scheduler : 모든 cluster data를 담는 key-value 저장소 (주요 저장소로 쓰려면 백업 필수 ) kube-scheduler : Node가 배정되지 않은 새로 생성된 pod를 감지하고 , kubernete에서 구현하고 있는 scheduling algorithm에 따라 pod를 실행할 Node를 결정 kube-controller-manager : controller(API 서버를 통해 cluster의 상태를 감시하고, 현재 상태를 원하는 상태로 이행시키는 control loop ) 를 구동시킴 cloud-controller-manager : cloud별 controller logic을 포함 (aws,gcp 등 third party company에서 제공하는 전용 controller를 실행하는 역할이다.) Node component kubelet : cluster의 각 노드에서 실행되는 에이전트 kubelet-proxy: cluster의 각 노드에서 실행되는 네트워크 프록시로, kubernetes 서비스 구현부이다. 즉, Pod에서 실행중인 app을 외부에 노출시키기 위한 네트워크 서비스이다. container runtime : container 실행을 담당하는 소프트웨어로 대표적으로 지원하는 런타임으로는 Docker가 있다. Reference Kubernetes Public Documentation : https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/","link":"/2021/07/27/2021-07-27-kubernetes-01/"},{"title":"Express Middleware concept","text":"middleware 는 request, response 의 중간에 위치하며, requst,response에 필요한 작업을 수행한다. router,error handler 모두 middleware의 일종이다. syntax middleware 는 app.use(middleware) 형태로 실행된다. middleware 의 parameter는 req,res,next이다. express는 middleware를 위에서 아래로 순차적으로 실행하면서, 요청 url에 맞는 middleware를 실행하고 , next() 호출시 다음 middleware로 요청이 넘어간다. 만약 next() 호출되지 않으면 다음 middleware로 요청이 넘어가지 않는다. 12345// 기본 middleware 사용법 app.use((req,res,next)=&gt;{ console.log(&quot;router exectued!&quot;); next();}) 위 middleware는 모든 요청에 대해 호출되는 middleware이고특정 url에 대해 수행되는 middleware는 다음과 같이 수행될 수 있다. 123456789101112131415// GET,POST app.use(&quot;/request-url&quot;,(req,res,next)=&gt;{ console.log(&quot;router exectued!&quot;); next();})// POSTapp.post(&quot;/request-url&quot;,(req,res,next)=&gt;{ console.log(&quot;router exectued!&quot;); next();})// GETapp.get(&quot;/request-url&quot;,(req,res,next)=&gt;{ console.log(&quot;router exectued!&quot;); next();}) 또한 하나의 요청 url에서 여러개의 router 수행이 가능하다 예를 들면 아래와 같이 호출하면 final_router 호출전에 router1,2의 로직을 수행된다. (주로 로그인여부확인 로직이 들어간다.) 1234// multiple router example// router1 contain next();// router2 contain next();app.get(&quot;/multiple-routers&quot;,router1,router2,final_router); 보통 모든 middleware에서 요청 url을 찾을 수 없을떄를 대비하기 위해, 가장 아래 middleware에 error handling 용 middleware를 두어 처리한다. 123456app.use((err,req,res,next)=&gt;{ console.log(`${err} occured !`); // error 처리 로직 res.send(404)})","link":"/2021/07/28/2021-07-28-express-middleware/"},{"title":"spring Core Technology - IoC","text":"1.1. Introduction to the Spring IoC Container and Beans *spring 공식 reference를 보고 정리한 글입니다.Spring IoC application context (=spring container)가 bean 객체를 생성하면서 bean 객체가 의존하고 있는 다른 object를 생성하여 주입해준다(Dependency Injection), 이는 개발자가 직접 객체의 생명주기를 관리하는 게 아니라 , spring container가 bean 객체의 생명주기,종속성관리를 해주는 것임으로, 제어의 역전(Inversion of Control,IoC)라고 부른다. Bean 객체의 생명주기 및 종속성 관리는 Bean Factory가 수행하는 역할이고, application context는 Bean Factory interface의 sub-type으로 다음과 같은 추가 기능을 갖는다. spring AOP 관련된 추가 기능 Message resource handling Event publication Application-layer specific contexts 그렇다면 application context는 어떻게 Bean 객체를 생성 및 관리하는 것일까?xml 또는 annotation 이 달린 java code (@Configuration) 로 Configuration Meta Data를 개발자가 설정하면 application context는 여기에 설정된 메타 데이터를 보고 Bean 객체를 관리한다. Spring Container1org.springframework.context.ApplicationContext spring container는 위에서 설명했던 것처럼 java code 또는 xml file 기반의 설정파일을 보고 Bean 객체의 생성과 이들간의 종속성을 주입해준다. org.springframework.context.ApplicationContext 의 구현체는 여러 종류가 있다. Stand-alone applications의 경우 ClassPathXmlApplicationContext 또는 FileSystemXmlApplicationContext 를 사용하는 것이 대부분이다. Configuration Meta Data spring 2.5 부터는 annotation 기반의 metadata 설정파일을 지원해주기 시작하였고, (@Configuration) 이전에는 xml 기반으로 metadata 설정파일을 사용하였다. syntax를 보면 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;beanId&quot; class=&quot;bean.class&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 위와 같이 beans tag 안에 등록할 bean을 정의한다. id attribute에는 bean Name , class attribute에는 bean classpath를 기입한다. Spring Container Initialization spring container는 configuration meta data 를 생성자로 받아, 만든다. 1ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); 만약 annotation 기반의 설정파일인 경우에는 1AnnotationConfigApplicationContext 를 사용한다. services.xml 을 살펴보면, bean tag에 id=”petStore” , class=”org.springframework.samples.jpetstore.services.PetStoreServiceImpl” 임을 볼 수 있는데, 이는 petStore bean 이름을 가지고 있고, 해당 class path은 org.springframework.samples.jpetstore.services.PetStoreServiceImpl 이며,property로는 accountDato, itemDao 을 가지고 있고 해당 property의 bean 이름이 각각 accountDato, itemDao 라는 것을 뜻한다. 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- services --&gt; &lt;bean id=&quot;petStore&quot; class=&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;property name=&quot;itemDao&quot; ref=&quot;itemDao&quot;/&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt; 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;itemDao&quot; class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt; Composing XML-based Configuration Metadata위 코드는 여러개의 xml file 을 configuration meta data로 가지고 있다. 이는 다음과 같이 하나의 xml file 에서 import tag를 통해 다른 xml 설정파일을 불러들일 수도 있다. 12345678&lt;beans&gt; &lt;import resource=&quot;services.xml&quot;/&gt; &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt; &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt; &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt; &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;&lt;/beans&gt; Reference Spring Public Documentation : https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core","link":"/2021/07/27/2021-07-27-spring-core-01/"},{"title":"Denpendency Injection &amp; Dependency Lookup","text":"Dependency InjectionSpring IoC의 동작원리는 주로 DI(Dependency Injection)이다. Spring 공식 Doc보면, IoC를 DI라고 표현하기도 한다. Dependency Injection의 정의는 다음과 같다. Dependency Injection : program run time 시에 의존관계를 맺는 대상인 dependent object 와 , 그것을 사용하는 주체인 client object를 연결시켜주는 작업 DI는 정리하면 다음과 같은 3 조건을 충족시키는 작업을 말한다. class model(class diagram)에는 의존관계가 들어나지 않음 , 즉 client가 Interface에 의존하고 있어야 한다. run time시 의존관계는 container와 같은 다른 주체가 결정한다. 의존관계는 사용할 dependent object의 reference를 외부에서 주입해줌으로서, 만들어진다. Dependency LookUpSpring이 제공하는 IoC방법은 DI만 존재하는 것이 아니다. Dependency Lookup(의존관계 검색) 도 Spring 에 제공하는 IoC 방법 중에 하나이다. Depedency Lookup(DL)은 DI와 다르게, 스스로 의존관계를 찾는다 . client는 자신이 사용할 객체를 결정하거나 , 생성하진 않지만 (이는 DI Container에 의해 수행됨) 생성자나 method를 통해 생성된 객체를 주입받는게 아니라, 직접 DI Container에게 달라고 요청하는 것이다. 두번쨰로 DL 은 호출 주체가 Spring bean 일 필요는 없지만, DI의 경우 Container 에서 object 주입을 해주기 때문에 호출 주제도 Spring Bean이여야 한다는 차이점이 있다.(당연히 , DI를 원하는 object는 당연히 spring bean 으로 등록되어 있어야 한다.) 이전에 살펴보았던 application context(=DI Container,IoC container,Bean Factory의 확장형) 에서 getBean() method가 Dependency LookUp에 사용되는 method이다. 123ApplicationContext applicationContext = new AnnotationConfigApplicationContext(DaoFactory.class);// Dependency Lookup : getBean() , 스스로 DI Container에게 객체를 달라고 요청한다. UserDao spring_dao1 = applicationContext.getBean(&quot;userDao&quot;, UserDao.class);","link":"/2021/07/28/2021-07-28-spring04/"},{"title":"Spring Configuration - Xml","text":"spring은 java annotaion 기반으로 DI 의존관계 설정 class를 만드는 것 이외에도 , xml을 활용하여 DI 의존관계 설정 class를 만드는 것을 지원한다. xml의 이용할 경우 별도의 compile이 필요하지 않다는 장점을 가지고 있다. annotaion의 @Configuration 이 &lt;beans&gt; tag, @Bean 이 &lt;bean&gt; tag와 대응된다. @Bean에서 bean이름이 될 method name은 xml에서 &lt;bean&gt; tag 의 id attribute,@Bean에서 bean Class type은 xml에서 &lt;bean&gt; tag의 class attribute 가 된다. 예를 들어 1234@Bean public ConnectionMaker connectionMaker(){ return new DconnectionMaker();} 위 자바 코드는 아래의 xml 기반의 설정파일과 동일한 의미이다. 123&lt;beans&gt; &lt;bean id=&quot;connectionMaker&quot; class=&quot;com.springstudy...DconnectionMaker&quot;&gt;&lt;beans&gt; 다른 Bean 과의 관계설정은 xml에서 tag를 통해 이루어질 수 있다. property tag의 name attribute는 property 이름 , ref attribute는 setter method를 통해 주입해줄 bean 객체의 이름이다. 예를 들어 12345678public class UserDao{ private ConnectionMaker connectionMaker; public void setConnectionMaker(ConnectionMaker connectionMaker){ this.connectionMaker=connectionMaker; }} 위 자바 코드는 아래의 xml 기반의 설정파일과 동일한 의미이다. 123456&lt;beans&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.springstudy...UserDao&quot;&gt; &lt;!-- name : property 명 , ref : bean 객체 이름 --&gt; &lt;property name=&quot;connectionMaker&quot; ref=&quot;connectionMaker&quot; /&gt; &lt;/bean&gt;&lt;beans&gt; application context 를 xml 설정파일로 만드는 방법은 간단하다 다른 구체 class를 사용하면 된다. 1GenericXmlApplicationContext(&quot;applicationContext.xml&quot;); 최종적으로 현재 userDao 를 xml설정파일로 bean으로 등록하였다. 12345678910111213&lt;!-- applicationContext.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;bean id=&quot;connectionMaker&quot; class=&quot;com.springstudy.ioc.DconnectionMaker&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.springstudy.ioc.UserDao&quot;&gt; &lt;property name=&quot;connectionMaker&quot; ref=&quot;connectionMaker&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456public static void main(String[] args) { ApplicationContext context = new GenericXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = context.getBean(&quot;userDao&quot;, UserDao.class); System.out.println(&quot;userDao = &quot; + userDao);}","link":"/2021/07/28/2021-07-28-spring06-Xml-based-configuration/"},{"title":"플루이드의 토끼와 거북이 알고리즘","text":"플루이드의 토끼와 거북이 알고리즘은 Linked List에서 cycle 존재 유무와 cycle의 길이 및 , 시작점 을 확인할 수 있는 알고리즘으로 2개의 다른 속도로 움직이는 포인터를 사용한다. , (알고리즘 이름이 왜 토끼와 거북이인지 알 것 같다) 알고리즘은 크게 2 phase로 나뉜다.Phase 1. 다른 속도로 움직이는 두 pointer의 교차점을 찾고,Phase 2. cycle의 진입로를 찾는다.먼저 phase 1을 세부적으로 살펴보면, 다른속도로 움직이는 두개의 pointer를 선언한다. 12tortoise = head ## 한번에 하나의 노드를 이동하는 포인터hare = head ## 한번에 두개의 노드를 이동하는 포인터 두개의 pointer의 교차점을 찾을떄까지 각 pointer를 이동시킨다. 12345678910while hare != None and hare.next != None: tortoise = tortoise.next; # 느린 포인터는 한번에 하나의 노드씩 이동 hare = hare.next.next; #빠른 포인터는 한번에 두개 노드씩 이동 if tortoise == hare: ## 두 포인터가 교차점을 찾으면 phase 1목표달성 return tortoise; # == intersect ## cycle이 존재하지 않음 return None; 다음으로 phase 2 를 살펴보면, head를 가르키는 pointer와 , phase 1에서 찾은 두 pointer의 교차점을 가르키는 pointer 선언 12ptr1 = head;prt2 = intersect; 이제 두 포인터를 서로 만날때까지 한칸씩 앞으로 이동한다. 12345while ptr1 != ptr2: ptr1 = ptr1.next; ptr2 = ptr2.next;return ptr1; 두 포인터가 서로 만나는 지점이 cycle의 진입로이다. 만약에 cycle의 길이를 추가로 계산하고 싶다면 다음과 같이 얻을 수 있을것이다. 1234567self_ptr1=ptr1.next;cycle_length = 1;while self_ptr1 != ptr1: ptr1 = ptr1.next; cycle_length+=1; python version. 1234567891011121314151617181920212223#phase I def getIntersect(head): tortoise = head hare = head while hare != None and hare.next !=None: tortoise = tortoise.next; hare = hare.next.next; if( tortoise == hare ): return tortoise; return None#phase IIdef detectCycle(head): if head == None: return None intersect = getIntersect(head); if(intersect == None): return None; ptr1 = head; ptr2 = intersect while (ptr1 != ptr2): ptr1 = ptr1.next; ptr2 = ptr2.next; return ptr1; java version. (python과 약간의 문법빼고는 흐름 자체는 동일하다 ) 123456789101112131415161718192021222324252627282930public class Solution { public ListNode getIntersect(ListNode head){ ListNode tortoise = head; ListNode hare = head; while( hare != null &amp;&amp; hare.next != null){ tortoise = tortoise.next; hare = hare.next.next; if(tortoise == hare){ return tortoise; } } return null; } public ListNode detectCycle(ListNode head) { if(head == null){ return null; } ListNode inter = getIntersect(head); if(inter == null){ return null; } ListNode ptr1 = head; ListNode ptr2 = inter; while (ptr1 != ptr2){ ptr1=ptr1.next; ptr2=ptr2.next; } return ptr1; }} 시간복잡도 단일 반복문으로 O(n)의 시간복잡도를 갖는다공간복잡도 입력의 크기 n과 무관하게 상수개의 포인터 (4) 만을 선언하여 해결 가능하다. O(1)의 공간복잡도를 갖는다.","link":"/2021/07/30/2021-07-30-floyd-tort-hare-alg-DESKTOP-QF32SHN/"},{"title":"플루이드의 토끼와 거북이 알고리즘","text":"플루이드의 토끼와 거북이 알고리즘은 Linked List에서 cycle 존재 유무와 cycle의 길이 및 , 시작점 을 확인할 수 있는 알고리즘으로 2개의 다른 속도로 움직이는 포인터를 사용한다. , (알고리즘 이름이 왜 토끼와 거북이인지 알 것 같다) 알고리즘은 크게 2 phase로 나뉜다.Phase 1. 다른 속도로 움직이는 두 pointer의 교차점을 찾고,Phase 2. cycle의 진입로를 찾는다.먼저 phase 1을 세부적으로 살펴보면, 다른속도로 움직이는 두개의 pointer를 선언한다. 12tortoise = head ## 한번에 하나의 노드를 이동하는 포인터hare = head ## 한번에 두개의 노드를 이동하는 포인터 두개의 pointer의 교차점을 찾을떄까지 각 pointer를 이동시킨다. 12345678910while hare != None and hare.next != None: tortoise = tortoise.next; # 느린 포인터는 한번에 하나의 노드씩 이동 hare = hare.next.next; #빠른 포인터는 한번에 두개 노드씩 이동 if tortoise == hare: ## 두 포인터가 교차점을 찾으면 phase 1목표달성 return tortoise; # == intersect ## cycle이 존재하지 않음 return None; 다음으로 phase 2 를 살펴보면, head를 가르키는 pointer와 , phase 1에서 찾은 두 pointer의 교차점을 가르키는 pointer 선언 12ptr1 = head;prt2 = intersect; 이제 두 포인터를 서로 만날때까지 한칸씩 앞으로 이동한다. 12345while ptr1 != ptr2: ptr1 = ptr1.next; ptr2 = ptr2.next;return ptr1; 두 포인터가 서로 만나는 지점이 cycle의 진입로이다. 만약에 cycle의 길이를 추가로 계산하고 싶다면 다음과 같이 얻을 수 있을것이다. 1234567self_ptr1=ptr1.next;cycle_length = 1;while self_ptr1 != ptr1: ptr1 = ptr1.next; cycle_length+=1; python version. 1234567891011121314151617181920212223#phase I def getIntersect(head): tortoise = head hare = head while hare != None and hare.next !=None: tortoise = tortoise.next; hare = hare.next.next; if( tortoise == hare ): return tortoise; return None#phase IIdef detectCycle(head): if head == None: return None intersect = getIntersect(head); if(intersect == None): return None; ptr1 = head; ptr2 = intersect while (ptr1 != ptr2): ptr1 = ptr1.next; ptr2 = ptr2.next; return ptr1; java version. (python과 약간의 문법빼고는 흐름 자체는 동일하다 ) 123456789101112131415161718192021222324252627282930public class Solution { public ListNode getIntersect(ListNode head){ ListNode tortoise = head; ListNode hare = head; while( hare != null &amp;&amp; hare.next != null){ tortoise = tortoise.next; hare = hare.next.next; if(tortoise == hare){ return tortoise; } } return null; } public ListNode detectCycle(ListNode head) { if(head == null){ return null; } ListNode inter = getIntersect(head); if(inter == null){ return null; } ListNode ptr1 = head; ListNode ptr2 = inter; while (ptr1 != ptr2){ ptr1=ptr1.next; ptr2=ptr2.next; } return ptr1; }} 시간복잡도 단일 반복문으로 O(n)의 시간복잡도를 갖는다공간복잡도 입력의 크기 n과 무관하게 상수개의 포인터 (4) 만을 선언하여 해결 가능하다. O(1)의 공간복잡도를 갖는다.","link":"/2021/07/30/2021-07-30-floyd-tort-hare-alg/"},{"title":"javascript 메모리 할당 방식 (primitive vs reference)","text":"javascript에서 primitive type 과 reference type의 memory 할당 방식 차이1var a; 다음과 같이 primitive type 변수를 선언하면 메모리 공간이 미리 할당되고, 변수에 값을 저장하면 1a = &quot;abcdefg&quot;; 다른 메모리 공간에 abcdefg string값이 저장이 되고, 그 메모리 주소가 a가 참조하는 메모리 공간에 저장된다. ex) 메모리주소 100번지에 abcdefg 값이 우선 저장이 되고, a가 참조하는 메모리 공간 200번지에 100번지 주소가 저장된다. 반면 reference type의 경우 primitve type과 메모리 할당방식이 조금 다르다. 12345var a = { property_1 : '1', property_2 : '2', // } 위 코드를 실행하면 실제 내부적으로 메모리 할당방식은 다음과 같다. 참조타입인 a변수의 메모리 공간이 선언된다. a변수의 property들을 담을 연속된 메모리 공간의 시작주소를 가르킬 메모리 공간이 할당된다. a변수의 property들의 value 값이 다른 메모리 공간에 저장이 되고, 그 메모리 주소가 해당 property의 메모리 공간(Heap area)에 저장된다. a변수가 참조하는 메모리 공간에 a변수의 property들을 담는 연속된 메모리 공간의 시작주소를 가르키는 메모리 공간의 주소가 저장된다. 정리하면 참조형 타입을 선언하면 그 참조형 타입의 속성들을 저장할 연속된 메모리 공간의 시작주소를 참조형 타입의 참조변수가 가지고, 그 이후부터는 primitive type과 동일하게 속성들의 값이 다른 메모리 공간에 할당되고 그 주소가 속성이 저장되는 메모리 주소의 값으로 할당된다. 즉 primitve type에 비해 한단계를 거쳐서 메모리 공간이 할당되는 형태이다. 참조형 객체 안에서 참조형 객체가 선언되는 경우도 동일하다 ex) 1234var a = { x:3, arr :[10,11] //참조형 데이터 } 1a.property_1 = &quot;new_1&quot;; 그렇다면 위 코드는 메모리상에서 어떻게 동작할까?a는 property가 연속해서 저장될 메모리 공간의 시작주소를 가르키는 건 변하지 않고,new_1이라는 값이 메모리 공간에 저장된 후, 그 메모리 공간의 주소값이 property_1이 참조하는 메모리공간의 값을 덮어씌운다. 참조형, 기본형 데이터의 값 복사 차이1234var a = 10; // 10이 100번지에 할당 (예시입니다.) 되고 변수 a의 메모리공간에 100번지 저장 var b = a; // 100번지가 변수 b의 메모리공간에도 저장a = 11; // b가 a를 가르키는 것이 아니기떄문에 a와는 무관 console.log(a != b) // true; 123456789var obj1 = {c:10,d:'ddd'};var obj2 = obj1; // property들의 시작주소를 가르키는 메모리공간이 //obj1이 참조하는 메모리공간에 저장됨 obj2.c = &quot;change!&quot;; // 다른 메모리공간에 값이 저장되고, // 그 주소를 property의 메모리공간이 저장한다. // 즉 객체형 참조변수는 property의 시작주소를 가르키는 // 메모리공간의 주소를 저장하고 있기때문에, // property값을 저장하는 메모리 공간은 계속 공유된다. console.log(obj2.c == obj1.c)// true 추가로 javascript data type에 대해 간략하게 정리하였다. Primitive Type(원시타입) Number String Boolean null undefined Symbol(ES6 추가) Reference Type(객체타입) Object Array Function RegExp … Reference 정재남 - 코어 자바스크립트 (http://www.yes24.com/Product/Goods/78586788)","link":"/2021/07/30/2021-07-30-javascript/"},{"title":"DataBase Connection을 추상화한 DataSource Interface 적용","text":"기존에 DB connection을 만들어주기 위하여, 직접 DB-specific한 DriverManager로부터 DB connection을 가져왔으나, 실제로 java에서는 DB connection을 가져오는 기능과 여러가지 부가적인 기능을 추상화한 DataSource interface가 존재한다. 1234567891011121314151617// javax.sql.DataSourcepublic interface DataSource extends CommonDataSource, Wrapper { /** * &lt;p&gt;Attempts to establish a connection with the data source that * this {@code DataSource} object represents. * * @return a connection to the data source * @exception SQLException if a database access error occurs * @throws java.sql.SQLTimeoutException when the driver has determined that the * timeout value specified by the {@code setLoginTimeout} method * has been exceeded and has at least tried to cancel the * current database connection attempt */ Connection getConnection() throws SQLException; spring 이 제공해주는 DataSource interface를 구현한 구체 class 중에서 test환경에서 간단히 사용할 수 있는 SimpleDriverDataSource를 사용하여, Dao Class를 refactorying 하였다. 1org.springframework.jdbc.datasource.SimpleDriverDataSource Dao class가 DB connection을 받으려면, datasource class를 spring bean 으로 등록해, DI 받을 수 있게 해야한다. 따라서 DataSource class를 먼저 spring bean으로 등록한다. 123456789@Beanpublic DataSource dataSource(){ SimpleDriverDataSource dataSource = new SimpleDriverDataSource(); dataSource.setDriverClass(com.mysql.jdbc.Driver.class); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring_study?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8 &quot;); dataSource.setPassword(&quot;1234&quot;); dataSource.setUsername(&quot;root&quot;); return dataSource;} 이후에는 Dao class가 setter 주입 방법을 통해 dataSource 객체를 주입받을 수 있게하여, run time object 관계를 만들어준다. 123456@Beanpublic UserDao userDao(){ UserDao userDao = new UserDao(); userDao.setDataSource(dataSource()); return userDao;} Dao class 도 instance variable 로 DataSource를 갖도록 변경한다. 12345678910111213public class UserDao {// -- DataSource 적용 이전 -- // private ConnectionMaker connectionMaker;// public UserDao(ConnectionMaker connectionMaker) {// this.connectionMaker =connectionMaker;// } private DataSource dataSource; public void setDataSource(DataSource dataSource){ this.dataSource=dataSource; } 아래와 같이 테스트 코드를 적용하면 잘 작동하는 것을 확인할 수 있다. 123456public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class); UserDao userDao = context.getBean(&quot;userDao&quot;, UserDao.class); System.out.println(&quot;userDao = &quot; + userDao);} 위에는 annotation 기반의 java코드로 spring bean으로 등록할 설정파일을 작성하였는데, 우리가 이전에 배운 xml 로 spring bean 을 등록해볼 수도 있다.주의할점은 DataSource 인터페이스의 경우 이전에 setter 주입을 해줄때, 다른 bean object의 참조값을 넘겨주는게 아니라, text를 적어주므로, ref attribute가 아닌 value attribute를 사용한다. 123456&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.SimpleDriverDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring_study?serverTimezone=UTC&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8g&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;&lt;/bean&gt; 마찬가지로 제대로 spring bean이 생성되는 지 테스트해본다.xml 기반의 설정파일을 이용함으로 Application Cotext interface의 구체class를 GenericXmlApplicationContext를 사용한다. 1234567public static void main(String[] args) { ApplicationContext context = new GenericXmlApplicationContext(DaoFactory.class); UserDao userDao = context.getBean(&quot;userDao&quot;, UserDao.class); System.out.println(&quot;userDao = &quot; + userDao);}","link":"/2021/07/31/2021-07-31-spring07-DataSource/"},{"title":"Quick Sort","text":"Quick sort는 기준 데이터인 pivot 을 설정하고, pivot보다 작은 값과 pivot보다 큰 값의 위치를 교환하고, 두 개의 포인터가 어긋나는 시점에 왼쪽에 위치한 포인터를 pivot과 교환해줌으로서, pivot의 왼쪽에는 pivot보다 작은 값들만 , pivot의 오른쪽에는 pivot보다 큰 값들만 위치하도록 한다.pivot의 왼쪽, 오른쪽 부분의 배열에 대해서 다시 재귀적으로 정렬을 수행하는 정렬 알고리즘이다. 퀵소트 알고리즘은 분할정복(divide &amp; conquer) 알고리즘에 속한다. 퀵소트 알고리즘에도 pivot을 어떻게 잡는 지에 대한 다양한 방법이 있지만, 가장 대표적인 호어 분할 방식으로 pivot을 잡으면 list에서 첫번째 데이터를 pivot으로 잡는다. 알고리즘은 다음과 같은 단계로 이루어진다. pivot 설정 왼쪽 pointer에서는 pivot보다 큰 값을 찾고, 오른쪽 pointer 에서는 pivot보다 작은 값을 찾는다. 만약 두 pointer 의 위치가 어긋나면 왼쪽에 위치한 pointer와 ( 더 작은 데이터 ) pivot 의 값을 교환한다. 3번 과정 이후에, pivot 을 기준으로 왼쪽, 오른쪽에 대해 다시 1번 과정을 재귀적으로 수행한다. 그렇지 않다면 두 pointer간의 값을 교환한다. 파이썬으로 구현한 퀵소트는 다음과 같다. 1234567891011121314151617181920212223242526272829def quickSort(arr,lt,rt): ## 배열의 원소가 하나 남으면 이미 정렬된 상태로 간주하고 종료한다. if(lt&gt;=rt): return; # pivot값을 설정한다. pivot = arr[lt]; left = lt+1; right= rt; while left&lt;=right: # 왼쪽에서부터 pivot값보다 작거나 같은 값을 찾는다. while left&lt;=rt and arr[left] &lt;= pivot: left+=1; # 오른쪽에서부터 pivot값보다 큰 값을 찾는다. while arr[right] &gt; pivot: right-=1; # 두 포인터가 엇갈리지 않았으면 교환한다 if(left&gt;right): arr[right] , arr[lt] = arr[lt], arr[right]; # 엇갈렸다면 왼쪽에 위치한 포인터, 작은값과 pivot을 교환한다. else: arr[left] , arr[right] = arr[right], arr[left] ## pivot을 기준으로 정렬된 두 파티션을 재귀적으로 다시 정렬을 수행한다. quickSort(arr,lt,right-1); quickSort(arr,right+1,rt);if __name__ ==&quot;__main__&quot;: array = [2,4,5,7,8,22,1,41,2,33,232,13]; quickSort(array,0,len(array)-1); print(array) 자바로 구현한 quick sort는 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Arrays;public class QuickSort { public static void quickSort(int[] arr, int lt, int rt ){ if(lt&gt;=rt){ return; } int pivot = partition(arr, lt, rt); quickSort(arr, lt,pivot-1); quickSort(arr,pivot+1, rt); } private static int partition(int[] arr, int lt, int rt) { int pivot = arr[lt]; int left = lt +1; int right = rt; while(left&lt;=right){ while (arr[left] &lt;= pivot &amp;&amp; left&lt;= rt){ left++; } while (arr[right] &gt; pivot){ right--; } if(left&gt;right){ swap(arr,right, lt); }else{ swap(arr,right,left); } } return right; } private static void swap(int[] arr, int idx1, int idx2) { int tmp = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = tmp; } public static void main(String[] args) { int[] arr = {2,4,5,1,32,2,4,21,1,3,232,13}; System.out.println(&quot;before sorting :&quot; + Arrays.toString(arr)); quickSort(arr,0,arr.length-1); System.out.println(&quot;after sorting :&quot; + Arrays.toString(arr)); }} 시간,공간복잡도퀵소트의 시간복잡도는 평균경우가 O(NlogN), 최악의 경우가 O(N^2)이다. (최악의 경우는 pivot이 매번 가장 작거나, 가장 클 경우로 사실 상 확률이 매우 적다. ) 공간복잡도는 O(1)으로 merge sort (O(N))보다는 효율적인 공간복잡도를 가지고 있다. Reference 퀵소트 설명사진: https://www.w3resource.com/csharp-exercises/searching-and-sorting-algorithm/searching-and-sorting-algorithm-exercise-9.php","link":"/2021/08/01/2021-08-01-quick-sort-DESKTOP-QF32SHN/"},{"title":"Quick Sort","text":"Quick sort는 기준 데이터인 pivot 을 설정하고, pivot보다 작은 값과 pivot보다 큰 값의 위치를 교환하고, 두 개의 포인터가 어긋나는 시점에 왼쪽에 위치한 포인터를 pivot과 교환해줌으로서, pivot의 왼쪽에는 pivot보다 작은 값들만 , pivot의 오른쪽에는 pivot보다 큰 값들만 위치하도록 한다.pivot의 왼쪽, 오른쪽 부분의 배열에 대해서 다시 재귀적으로 정렬을 수행하는 정렬 알고리즘이다. 퀵소트 알고리즘은 분할정복(divide &amp; conquer) 알고리즘에 속한다. 퀵소트 알고리즘에도 pivot을 어떻게 잡는 지에 대한 다양한 방법이 있지만, 가장 대표적인 호어 분할 방식으로 pivot을 잡으면 list에서 첫번째 데이터를 pivot으로 잡는다. 알고리즘은 다음과 같은 단계로 이루어진다. pivot 설정 왼쪽 pointer에서는 pivot보다 큰 값을 찾고, 오른쪽 pointer 에서는 pivot보다 작은 값을 찾는다. 만약 두 pointer 의 위치가 어긋나면 왼쪽에 위치한 pointer와 ( 더 작은 데이터 ) pivot 의 값을 교환한다. 3번 과정 이후에, pivot 을 기준으로 왼쪽, 오른쪽에 대해 다시 1번 과정을 재귀적으로 수행한다. 그렇지 않다면 두 pointer간의 값을 교환한다. 파이썬으로 구현한 퀵소트는 다음과 같다. 1234567891011121314151617181920212223242526272829def quickSort(arr,lt,rt): ## 배열의 원소가 하나 남으면 이미 정렬된 상태로 간주하고 종료한다. if(lt&gt;=rt): return; # pivot값을 설정한다. pivot = arr[lt]; left = lt+1; right= rt; while left&lt;=right: # 왼쪽에서부터 pivot값보다 작거나 같은 값을 찾는다. while left&lt;=rt and arr[left] &lt;= pivot: left+=1; # 오른쪽에서부터 pivot값보다 큰 값을 찾는다. while arr[right] &gt; pivot: right-=1; # 두 포인터가 엇갈리지 않았으면 교환한다 if(left&gt;right): arr[right] , arr[lt] = arr[lt], arr[right]; # 엇갈렸다면 왼쪽에 위치한 포인터, 작은값과 pivot을 교환한다. else: arr[left] , arr[right] = arr[right], arr[left] ## pivot을 기준으로 정렬된 두 파티션을 재귀적으로 다시 정렬을 수행한다. quickSort(arr,lt,right-1); quickSort(arr,right+1,rt);if __name__ ==&quot;__main__&quot;: array = [2,4,5,7,8,22,1,41,2,33,232,13]; quickSort(array,0,len(array)-1); print(array) 자바로 구현한 quick sort는 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Arrays;public class QuickSort { public static void quickSort(int[] arr, int lt, int rt ){ if(lt&gt;=rt){ return; } int pivot = partition(arr, lt, rt); quickSort(arr, lt,pivot-1); quickSort(arr,pivot+1, rt); } private static int partition(int[] arr, int lt, int rt) { int pivot = arr[lt]; int left = lt +1; int right = rt; while(left&lt;=right){ while (arr[left] &lt;= pivot &amp;&amp; left&lt;= rt){ left++; } while (arr[right] &gt; pivot){ right--; } if(left&gt;right){ swap(arr,right, lt); }else{ swap(arr,right,left); } } return right; } private static void swap(int[] arr, int idx1, int idx2) { int tmp = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = tmp; } public static void main(String[] args) { int[] arr = {2,4,5,1,32,2,4,21,1,3,232,13}; System.out.println(&quot;before sorting :&quot; + Arrays.toString(arr)); quickSort(arr,0,arr.length-1); System.out.println(&quot;after sorting :&quot; + Arrays.toString(arr)); }} 시간,공간복잡도퀵소트의 시간복잡도는 평균경우가 O(NlogN), 최악의 경우가 O(N^2)이다. (최악의 경우는 pivot이 매번 가장 작거나, 가장 클 경우로 사실 상 확률이 매우 적다. ) 공간복잡도는 O(1)으로 merge sort (O(N))보다는 효율적인 공간복잡도를 가지고 있다. Reference 퀵소트 설명사진: https://www.w3resource.com/csharp-exercises/searching-and-sorting-algorithm/searching-and-sorting-algorithm-exercise-9.php","link":"/2021/08/01/2021-08-01-quick-sort/"},{"title":"Decorator pattern","text":"Decorator Pattern은 객체에서 추가적인 요건을 동적으로 추가할 수 있다. 12Target target = new concreteTarget();target = new Condition(target); //마치 wrapper class처럼 감싸서 사용한다. Decorator 의 super class는 장식할 객체의 super class와 같다. Decorator 구현체는 Decorator 추상 class를 상속하여 기능을 추가할 수 있다. 한 객체를 여러 개의 Decorator 구현체로 감싸서 기능을 추가할 수 있다. Decorator는 장식할 객체에 어떤 행동을 위임하는 것외에도 추가적인 작업을 수행할 수 있다. Component는 장식할 객체의 추상 class로 Concrete Component에서 수행해야 할 공통적인 메소드, property를 가지고 있다. Decorator는 concrete component에 추가적인 작업을 동적으로 추가하는 Concrete Decorator의 추상 class이다. decorator pattern 을 이해하기 위해서 , 예시를 가지고 왔다.카페에서 음료수를 판다고 가정하였을떄, 음료수에 default가격이 있고, 거기에 휘핑크림이나 , mocha 추가하였을떄 추가금액이 붙는다고 가정하자. 이를 상속구조에서 super class에서 추가적인 요건(휘핑크림,모카.. etc)등을 가져간다고 하면 매 첨가물이 추가될떄마다 super class의 코드가 변경되고, subclass를 필요도 없는 method를 상속받을 수도 있다. (OCP에 적합하지 않은 설계) 반면 decorator pattern은 동적으로 행동을 설정할 수 있다. 12345678// Decorator가 장식할 객체의 추상 classpublic abstract class Beverage { String description = &quot;none&quot;; public String getDescription(){ return this.description; } public abstract double cost();} 1234567891011121314151617181920// 장식될 구현 classpublic class Espresso extends Beverage{ public Espresso() { this.description = &quot;espresso&quot;; } @Override public double cost() { return 1.99; }}public class HouseBlend extends Beverage{ public HouseBlend() { this.description = &quot;houseblend&quot;; } @Override public double cost() { return .89; }} 12345// Decorator의 부모 class는 장식할 객체의 부모 class와 같다. public abstract class CondimentDecorator extends Beverage{ public abstract String getDescription();} 123456789101112131415161718192021222324252627282930313233// Decorator 구현 class로 장식할 객체에 추가적인 요건을 동적으로 추가 할 수 있다. public class Mocha extends CondimentDecorator{ private Beverage beverage; public Mocha(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return .20 + beverage.cost(); } @Override public String getDescription() { return beverage.getDescription() + &quot; mocha&quot;; }}public class Whip extends CondimentDecorator{ private Beverage beverage; public Whip(Beverage beverage) { this.beverage =beverage; } @Override public double cost() { return .1 + beverage.cost(); } @Override public String getDescription() { return beverage.getDescription() + &quot; whip &quot;; }} 123456789101112131415161718192021222324public class Test { public static void main(String[] args) { Beverage espresso = new Espresso(); Beverage houseBlend = new HouseBlend(); espresso = new Mocha(espresso); espresso = new Whip(espresso); System.out.println(&quot;espresso.getDescription() = &quot; + espresso.getDescription()); System.out.println(&quot;espresso.cost() = &quot; + espresso.cost()); houseBlend = new Whip(houseBlend); System.out.println(&quot;houseBlend.getDescription() = &quot; + houseBlend.getDescription()); System.out.println(&quot;houseBlend.cost() = &quot; + houseBlend.cost()); } /*** espresso.getDescription() = espresso mocha whip espresso.cost() = 2.29 houseBlend.getDescription() = houseblend whip houseBlend.cost() = 0.99 ***/} decorator 적용 예시대표적으로 Java.io의 Reader/Writer stream이 Decorator pattern을 사용하여 구현되어 있다. Reference Head First Design Patterns: A Brain-Friendly Guide (Head First Design Patterns: A Brain-Friendly Guide)","link":"/2021/08/02/2021-08-02-decorator-pattern/"},{"title":"B Tree","text":"B Tree는 다수의 키를 가진 Node로 구성되어 다방향 탐색이 가능한 균형 트리이다. B Tree는 이진트리와 다르게, 하나의 노드에 다수개의 키를 저장할 수 있어, Tree의 높이를 낮추어 대용량 데이터 처리에 효율적임으로, 관계형 데이터베이스의 기본 자료구조로서 활용된다. ( 균형 트리란 ? 왼쪽,오른쪽 subtree의 높이 차이를 줄여, O(logN)의 시간복잡도를 가지고, 탐색,삼입,삭제 연산을 수행할수 있다. ) 대표적으로 AVL Tree, RB Tree, B tree…등이 있다. 차수가 M인 B트리는 다음과 같은 정의를 갖는다.(= 트리 노드의 최대 자식 노드의 개수가 M이며, 이떄 M은 2이상의 정수여야한다.) 모든 leef node는 동일한 깊이를 갖는다. 각 internal node의 자식수는 M/2 이상 , M 이하이다. Root Node의 자식수는 2 이상이다. Node의 key값들은 정렬된 상태를 유지한다. 탐색, 추가, 삭제연산 탐색연산 이진트리와 동일하게 노드의 키값들을 루트노드에서부터 비교하며 적절한 subtree를 찾아 내려간다. 다만 노드의 키가 정렬된 여러 개의키로 구성되어 있음으로, 각 노드에서 이진 탐색트리를 수행하여, 적절한 서브트리를 찾는다. 삼입연산 탐색과정을 거쳐, 새로운 키가 저장되야할 leef node를 찾고, 만약에 leef node에 새 키를 수용할 공간이 있으면, 정렬상태를 유지하도록 key를 삼입한다. 근데 만약에 M-1개의 키를 이미 가지고 있다면, 하나의 키가 추가되면 총 M개의 키에 차수의 개수는 M+1이 될 것이다. 따라서 Split연산을 통해서 M-1개의 키와 새로운 키 중에서 중간값이 되는 키를 부모노드로 올려보내고, 나머지 M-1개의 키들은 각각 위치에 맞게 저장한다. 위에 차수가 3인 B Tree에 45를 삼입하면 (25,35) Node에서 (25,35,45) 의 노드 키의 중간 키인 “35”를 부모노드로 올리고, 나머지인 25,45는 각각의 노드에 저장된다. 이러한 과정을 Split 연산이라고 한다. 삭제연산 B트리에서 삭제연산은 항상 Leef node에서 일어난다. 이진 탐색트리의 삭제연산과 동일하게 , 중위선행자 (왼쪽 서브트리의 최댓값) 또는 중위 후속자 (오른쪽 서브트리의 최솟값) 과 삭제할 키를 교환한 후에 Leef node에서 삭제를 수행한다. 삭제연산은 여러가지 Case를 고려해야 한다. 먼저 B tree의 정의를 다시보면 각 internal node의 자식수는 M/2 이상 , M 이하이다. 즉, 삭제 후에 M/2이상의 노드가 남아있어야 하며, M/2이하의 노드가 남았을 경우에는 underflow가 발생했다고 하며, 이동연산(Transfer) 을 통해 underflow가 발생한 좌우의 형제노드 중에서 key를 하나가져와도 B 트리의 정의에 위배되지 않는 형제노드로부터 1개의 key를 부모 노드를 통해 이동시키는 연산을 수행한다. 만약 두 형제노드 모두 1개의 key를 주는 경우에, B트리의 정의가 위반된다면 underflow가 일어난 노드와 그 형제노드를 나눠주는 부모노드의 키를 하나의 노드로 통합시키는 통합연산(Fusion) 수행한다. 위와 같이 차수가 3인 B tree가 있다고 가정할떄, 첫번째로 이동연산이 일어나는 경우를 살펴보았다.65를 삭제하면 65는 internal node임으로 중위후속자인 60과 swap 65를 leef node에서 삭제 underflow 발생, 형제노드에서 부모노드를 거쳐 key를 가져올 수 있는 지 확인 70 을 부모노드로 이동시키고, 60을 부모노드로부터 key로 받음 두번째로 통합연산이 일어나는 경우를 살펴보았다.70을 삭제하면, 70은 internal node임으로 중위후속자인 60과 swap 70을 leef node에서 삭제 underflow 발생하여, 형제노드에서 부모노드를 거쳐 key를 가져올 수 있는지 확인하였으나, 형제노드도 key를 가져오면 underflow발생함. 형제노드(80),underflow일어난 노드, 부모노드의 분기점 key(60)를 하나의 노드로 Fusion한다. Reference 이동, 통합연산 이미지 (http://booryq.blogspot.com/2015/11/here-science-behind-perfect-b-tree.html) split연산 이미지 (https://www.programiz.com/dsa/insertion-into-a-b-tree) 양성봉 저 - 파이썬과 함께하는 자료구조의 이해 (http://www.yes24.com/Product/Goods/57949931)","link":"/2021/08/03/2021-08-03-data-structure-btree/"},{"title":"B Tree","text":"B Tree는 다수의 키를 가진 Node로 구성되어 다방향 탐색이 가능한 균형 트리이다. B Tree는 이진트리와 다르게, 하나의 노드에 다수개의 키를 저장할 수 있어, Tree의 높이를 낮추어 대용량 데이터 처리에 효율적임으로, 관계형 데이터베이스의 기본 자료구조로서 활용된다. ( 균형 트리란 ? 왼쪽,오른쪽 subtree의 높이 차이를 줄여, O(logN)의 시간복잡도를 가지고, 탐색,삼입,삭제 연산을 수행할수 있다. ) 대표적으로 AVL Tree, RB Tree, B tree…등이 있다. 차수가 M인 B트리는 다음과 같은 정의를 갖는다.(= 트리 노드의 최대 자식 노드의 개수가 M이며, 이떄 M은 2이상의 정수여야한다.) 모든 leef node는 동일한 깊이를 갖는다. 각 internal node의 자식수는 M/2 이상 , M 이하이다. Root Node의 자식수는 2 이상이다. Node의 key값들은 정렬된 상태를 유지한다. 탐색, 추가, 삭제연산 탐색연산 이진트리와 동일하게 노드의 키값들을 루트노드에서부터 비교하며 적절한 subtree를 찾아 내려간다. 다만 노드의 키가 정렬된 여러 개의키로 구성되어 있음으로, 각 노드에서 이진 탐색트리를 수행하여, 적절한 서브트리를 찾는다. 삼입연산 탐색과정을 거쳐, 새로운 키가 저장되야할 leef node를 찾고, 만약에 leef node에 새 키를 수용할 공간이 있으면, 정렬상태를 유지하도록 key를 삼입한다. 근데 만약에 M-1개의 키를 이미 가지고 있다면, 하나의 키가 추가되면 총 M개의 키에 차수의 개수는 M+1이 될 것이다. 따라서 Split연산을 통해서 M-1개의 키와 새로운 키 중에서 중간값이 되는 키를 부모노드로 올려보내고, 나머지 M-1개의 키들은 각각 위치에 맞게 저장한다. 위에 차수가 3인 B Tree에 45를 삼입하면 (25,35) Node에서 (25,35,45) 의 노드 키의 중간 키인 “35”를 부모노드로 올리고, 나머지인 25,45는 각각의 노드에 저장된다. 이러한 과정을 Split 연산이라고 한다. 삭제연산 B트리에서 삭제연산은 항상 Leef node에서 일어난다. 이진 탐색트리의 삭제연산과 동일하게 , 중위선행자 (왼쪽 서브트리의 최댓값) 또는 중위 후속자 (오른쪽 서브트리의 최솟값) 과 삭제할 키를 교환한 후에 Leef node에서 삭제를 수행한다. 삭제연산은 여러가지 Case를 고려해야 한다. 먼저 B tree의 정의를 다시보면 각 internal node의 자식수는 M/2 이상 , M 이하이다. 즉, 삭제 후에 M/2이상의 노드가 남아있어야 하며, M/2이하의 노드가 남았을 경우에는 underflow가 발생했다고 하며, 이동연산(Transfer) 을 통해 underflow가 발생한 좌우의 형제노드 중에서 key를 하나가져와도 B 트리의 정의에 위배되지 않는 형제노드로부터 1개의 key를 부모 노드를 통해 이동시키는 연산을 수행한다. 만약 두 형제노드 모두 1개의 key를 주는 경우에, B트리의 정의가 위반된다면 underflow가 일어난 노드와 그 형제노드를 나눠주는 부모노드의 키를 하나의 노드로 통합시키는 통합연산(Fusion) 수행한다. 위와 같이 차수가 3인 B tree가 있다고 가정할떄, 첫번째로 이동연산이 일어나는 경우를 살펴보았다.65를 삭제하면 65는 internal node임으로 중위후속자인 60과 swap 65를 leef node에서 삭제 underflow 발생, 형제노드에서 부모노드를 거쳐 key를 가져올 수 있는 지 확인 70 을 부모노드로 이동시키고, 60을 부모노드로부터 key로 받음 두번째로 통합연산이 일어나는 경우를 살펴보았다.70을 삭제하면, 70은 internal node임으로 중위후속자인 60과 swap 70을 leef node에서 삭제 underflow 발생하여, 형제노드에서 부모노드를 거쳐 key를 가져올 수 있는지 확인하였으나, 형제노드도 key를 가져오면 underflow발생함. 형제노드(80),underflow일어난 노드, 부모노드의 분기점 key(60)를 하나의 노드로 Fusion한다. Reference 이동, 통합연산 이미지 (http://booryq.blogspot.com/2015/11/here-science-behind-perfect-b-tree.html) split연산 이미지 (https://www.programiz.com/dsa/insertion-into-a-b-tree) 양성봉 저 - 파이썬과 함께하는 자료구조의 이해 (http://www.yes24.com/Product/Goods/57949931)","link":"/2021/08/03/2021-08-03-data-structure-btree-DESKTOP-QF32SHN/"},{"title":"Execution Context ( ⊃ Hoisting 개념 )","text":"Execution Context(실행 컨텍스트)는 코드를 실행할떄 필요한 환경 정보들을 담은 객체이다. 동일한 환경에 있는 코드들을 실행할떄, 필요한 환경 정보들을 모아 context를 구성하고, 이를 call stack에 올렸다가, 가장 위에 쌓여있는 context와 관련있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다.(stack 자료구조에서 LIFO 을 생각하면 이해가 간편한다.) execution context 는 함수를 실행할떄 구성된다. +) ES6 부터는 let,const block scope가 추가되었다. 여기서 call stack이란, 현재 어떤 함수가 동작하고 있는지와 다음에 어떤 함수가 호출되어야 하는지를 제어하는 자료구조이다. 코드 예시를 들면 다음과 같다. 123456789101112var a = 1;function outer(){ console.log(a); function inner(){ console.log(a); //1. 3 var a = 3; } inner(); console.log(a); //2. 1}outer();console.log(a); // 위의 코드에서 call stack은 다음과 같이 형성된다. javascript engine이 코드(함수)를 실행할떄 해당 환경에 대한 정보를 수집하여서 execution context를 만들고 call stack에 담는 형태이다. 그렇다면 정확히 어떤 환경에 대한 정보들을 수집하여 call stack 에 담기게 되는 것일까? VariableEnvironment (environmentRecord 객체, outerEnvironmentReference 객체) LexicalEnvironment (environmentRecord 객체, outerEnvironmentReference 객체 ) ThisBinding Variable Environment책에 사진을 보면 LexicalEnvironment와 VariableEnvironment의 구성성분은 같아보이지만, 큰 차이점이 하나 있다.VariableEnvironment는 최초 실행 시의 snapshot을 유지한다. 이후에 값이 변경되는 것은 LexicalEnvironment 에서 follow-up한다. Lexical EnvironmentenvironmentRecordLexical Environment의 environmentRecord에는 현재 context의 식별자 정보를 담는다. 이떄 현재 context의 식별자 정보를 담을떄, 이를 간편하게 hoisting 이라고 한다. 정리를 하면 hoisting이란 식별자 정보를 실행 context의 맨 상단으로 끌어올리는 과정이다. 123456789101112131415// before hoistingconsole.log(a());console.log(b());console.log(c());function a(){ return 'a';}var b = function bb(){ return 'bb';}var c = function(){ return 'c';} 12345678910111213141516171819// after hoisting (예시 코드) // -------------- environmentRecord ---------------------function a(){ return 'a';}// 함수는 한꺼번에 끌어올려진다.var b;var c;// --------------------------------------------------------console.log(a());console.log(b());console.log(c());b = function bb(){ return 'bb';}c = function(){ return 'c';} 처음 실행 context가 생성되는 순간에, environmentRecord의 정보가 수집된다. ( 정확히는 hoisting 과는 다르겠지만, hoisting 으로 이해하여도 결과는 동일하다. ) outerEnvironmentReferenceouterEnvironmentReference 는 현재 execution context의 외부 식별자 정보를 담는다. 예를 들면 inner context에서 outerEnvironmentReference는 outer의 Lexical Environment 를 가르키고, outer context에서 outerEnvironmentReference는 전역 context를 가르킨다. outerEnvironmentReference는 scope(변수의 유효범위) chain 현상을 유도한다. 즉 inner context에서는 environmentRecord를 통해 inner context에서 식별자를 접근할 수 있고, outerEnvironmentReference를 통해 외부 outer context 식별자도 접근이 가능하다. 이때 주의할 점은 scope chain 구조적 특성에 따라, 여러 scope에서 동일한 식별자를 선언한 경우에는 무조건 scope chain상에서 가장 먼저 발견된 식별자에만 접근이 가능하다는 점이다. 1234567891011var a = 1;function outer(){ console.log(a); inner(); function inner(){ console.log(a); }}outer();// 1 // 1 반면 outer에서 inner context를 접근할 수는 없다. 12345678910var a = 1;function outer(){ inner(); function inner(){ var c = 10; console.log(a); } // console.log(c); ReferenceError: c is not defined}outer(); 정리를 하면 , execution context 가 변수의 유효범위 scope를 정의한다. Reference 정재남 - 코어 자바스크립트 (http://www.yes24.com/Product/Goods/78586788)","link":"/2021/08/03/2021-08-03-javascript-execution-context/"},{"title":"Topological Sort","text":"위상정렬 (Topological sort) 는 cycle이 없는 방향 그래프(Directed Acyclic Graph,DAG) 에서 정점들을 선형순서(간선의 방향을 거스리지 않도록)로 나열하는 것을 의미하며, 주어진 그래프내에서 여러 개의 위상 정렬 결과가 나올수도 있다. 대표적으로 위상정렬을 이용하는 예로 대학교 선수과목 수강 순서를 정할떄 이용할 수 있다. 위상 정렬 알고리즘의 수행과정은 다음과 같다. 그래프에서 진입 차수가 0 인 정점 v 를 출력하고, v와 연결된 간선을 제거한다. 다시 1번 과정을 거치며, 진입 차수가 0인 정점을 찾는다. 1234567891011121314151617181920212223from collections import deque;adj_list = [[1,3,4],[] ,[0,1] , [6] , [5] , [3,7] ,[7] , [8] , []];n= len(adj_list); path = [];## 진입 차수 계산entry = [0] * n; path = deque();for i in range(n): for j in adj_list[i]: entry[j]+=1;## 진입 차수가 0 인 정점들을 경로에 추가한다. for i in range(n): if(entry[i] == 0): path.append(i);## 진입 차수가 0 인 정점을 차례로 꺼내어, 연결된 간선의 개수를 감소시키고, ## 다시 진입 차수가 0인 정점을 경로에 추가한다. while path: cur = path.popleft(); print(cur,end=&quot;-&gt;&quot;) for i in adj_list[cur]: entry[i]-=1; if(entry[i] == 0): path.append(i); 위의 위상정렬 알고리즘은 순방향 방법으로 수행한것이고, 반대로 진출차수가 0인 정점을 역순으로 출력하는 역방향 방법으로 더 효율적으로 수행가능하다. 12345678910111213141516171819202122def dfs(v): visited[v] = True; for i in adj_list[v]: if not visited[i]: dfs(i); # 연결된 정점을 모두 방문하면 진출 차수가 0인 것으로 간주 s.append(v); if __name__ == &quot;__main__&quot;: adj_list = [[1],[3,4] ,[0,1] , [6] , [5] , [7] ,[7] , [8] , []]; N = len(adj_list); visited = [False] * N; s = []; # 모든 정점에 대해서 방문하지 않았다면 dfs수행 for i in range(N): if not visited[i]: dfs(i); # 진출 차수가 0 인 정점들을 역순으로 출력 print(s[::-1]); 역순으로 수행하였을떄 위상 정렬의 시간 복잡도는 정점의 개수(N)와 간선의 개수(M) 이라고 하였을 떄 O(N+M)의 시간복잡도를 갖는다. Reference 양성봉 저 - 파이썬과 함께하는 자료구조의 이해 (http://www.yes24.com/Product/Goods/57949931)","link":"/2021/08/07/2021-08-07-topological-sort-DESKTOP-QF32SHN/"},{"title":"Topological Sort","text":"위상정렬 (Topological sort) 는 cycle이 없는 방향 그래프(Directed Acyclic Graph,DAG) 에서 정점들을 선형순서(간선의 방향을 거스리지 않도록)로 나열하는 것을 의미하며, 주어진 그래프내에서 여러 개의 위상 정렬 결과가 나올수도 있다. 대표적으로 위상정렬을 이용하는 예로 대학교 선수과목 수강 순서를 정할떄 이용할 수 있다. 위상 정렬 알고리즘의 수행과정은 다음과 같다. 그래프에서 진입 차수가 0 인 정점 v 를 출력하고, v와 연결된 간선을 제거한다. 다시 1번 과정을 거치며, 진입 차수가 0인 정점을 찾는다. 1234567891011121314151617181920212223from collections import deque;adj_list = [[1,3,4],[] ,[0,1] , [6] , [5] , [3,7] ,[7] , [8] , []];n= len(adj_list); path = [];## 진입 차수 계산entry = [0] * n; path = deque();for i in range(n): for j in adj_list[i]: entry[j]+=1;## 진입 차수가 0 인 정점들을 경로에 추가한다. for i in range(n): if(entry[i] == 0): path.append(i);## 진입 차수가 0 인 정점을 차례로 꺼내어, 연결된 간선의 개수를 감소시키고, ## 다시 진입 차수가 0인 정점을 경로에 추가한다. while path: cur = path.popleft(); print(cur,end=&quot;-&gt;&quot;) for i in adj_list[cur]: entry[i]-=1; if(entry[i] == 0): path.append(i); 위의 위상정렬 알고리즘은 순방향 방법으로 수행한것이고, 반대로 진출차수가 0인 정점을 역순으로 출력하는 역방향 방법으로 더 효율적으로 수행가능하다. 12345678910111213141516171819202122def dfs(v): visited[v] = True; for i in adj_list[v]: if not visited[i]: dfs(i); # 연결된 정점을 모두 방문하면 진출 차수가 0인 것으로 간주 s.append(v); if __name__ == &quot;__main__&quot;: adj_list = [[1],[3,4] ,[0,1] , [6] , [5] , [7] ,[7] , [8] , []]; N = len(adj_list); visited = [False] * N; s = []; # 모든 정점에 대해서 방문하지 않았다면 dfs수행 for i in range(N): if not visited[i]: dfs(i); # 진출 차수가 0 인 정점들을 역순으로 출력 print(s[::-1]); 역순으로 수행하였을떄 위상 정렬의 시간 복잡도는 정점의 개수(N)와 간선의 개수(M) 이라고 하였을 떄 O(N+M)의 시간복잡도를 갖는다. Reference 양성봉 저 - 파이썬과 함께하는 자료구조의 이해 (http://www.yes24.com/Product/Goods/57949931)","link":"/2021/08/07/2021-08-07-topological-sort/"},{"title":"Kruskal algorithm - MST","text":"kruskal 알고리즘은 최소 신장 트리 (Minimum Spanning Tree,MST)를 구하는 알고리즘으로, 가장 적은 비용으로 Graph의 모든 노드를 연결하기 위해 사용하는 알고리즘으로, 그리디 알고리즘에 속한다 kruskal 알고리즘에 대해 배우기 전에 기본적으로 그래프에서 신장트리,연결성분등 용어를 알아야 원할하게 이해할 수 있다. 연결성분(Connected Component): 그래프에서 정점들이 서로 연결되어 있는 부분 신장트리(Spanning Tree) : 주어진 그래프가 하나의 연결 성분으로 구성되어 있을떄, 그래프의 모든 정점들을 cycle없이 연결하는 부분그래프 최소 신장 트리 (MST): 하나의 연결성분으로 이루어진 무방향 가중치 그래프 에서 간선의 가중치의 합이 최소인 신장트리 , 당연히 신장트리 임으로 cycle이 있어서는 안된다. kruskal 알고리즘의 수행과정은 다음과 같다. 가중치가 감소하지 않는 순서로 정렬한다. 정렬된 순서대로 Graph에 아래의 조건을 만족하면 추가한다. 가중치가 cycle을 만들지 않으면 신장트리 간선으로 선택한다. 위 수행과정에서 가중치가 작은 순서대로 신장트리 간선을 선택하는데, cycle을 형성하는 4번은 제외되었다. kruskal algorithm을 python으로 구현하면 다음과 같다. 12345678910111213141516171819202122232425262728293031323334353637383940414243from collections import deque;weights = [(0,1,9),(0,2,10),(1,3,10),(1,4,5), (1,6,3),(2,3,9),(2,4,7),(2,5,2), (3,5,4),(3,6,8),(4,6,1),(5,6,6) ] ##(간선A,간선B,가중치)#오름차순으로 가중치 정렬weights.sort(key = lambda t : t[2]);weights = deque(weights);mst= []; N = 7;# disjoint set (서로소 집합)p = [ i for i in range(N)];# 서로소를 구하기 위한 find,union 연산 # find : 노드의 집합의 루트 노드(=대표노드)를 찾는 연산 def find(u): if u != p[u]: # 경로 압축 (find연산을 수행하면서 루트까지 올라가는 경로 상의 각 노드의 부모노드를 루트노드로 갱신한다. ) p[u] = find(p[u]); return p[u];# union : 두 노드를 하나의 집합으로 합친다def union(u,v): root1 = find(u); root2 = find(v); p[root2] = root1; tree_edges=0;mst_cost=0;while tree_edges!=(N-1): #가중치가 가장 작은 간선을 선택하고, u,v,wt = weights.popleft(); # 해당 노드의 루트노드를 비교해 다르면 , 서로 다른 집합임을 확인 (cycle이 형성되지 않음을 확인 ) if find(u) != find(v): # 두 노드를 하나의 집합으로 합침 union(u,v); # 최소 신장트리의 간선으로 선택 mst.append((u,v)); mst_cost+=wt; tree_edges+=1;print(mst); java code는 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class KruskalMST { static class Edge{ int src; int destination; int weight; public Edge(int src, int destination, int weight) { this.src = src; this.destination = destination; this.weight = weight; } } static class Graph{ int vertices; ArrayList&lt;Edge&gt; allEdges = new ArrayList&lt;&gt;(); public Graph(int vertices) { this.vertices = vertices; } public void addEdge(int src, int dest , int weight){ Edge edge = new Edge(src,dest,weight); allEdges.add(edge); } public void kruskalMst(){ PriorityQueue&lt;Edge&gt; pq = new PriorityQueue&lt;&gt;(allEdges.size(), Comparator.comparingInt(o -&gt; o.weight)); for (int i = 0; i &lt; allEdges.size() ; i++){ pq.add(allEdges.get(i)); } int[] parent = new int[vertices]; makeSet(parent); ArrayList&lt;Edge&gt; mst = new ArrayList&lt;&gt;(); // int idx = 0; while (idx &lt; vertices-1){ Edge edge = pq.remove(); int x_set = find(parent,edge.src); int y_set = find(parent,edge.destination); // 부모가 동일하다면 cycle형성하는 것임 if(x_set == y_set){ // will create cycle }else{ // 그게 아니라면 최소 신장 트리에 추가 mst.add(edge); idx++; // 두 정점중에 하나를 부모로 만듦. union(parent,x_set,y_set); } } printGraph(mst); } public void printGraph(ArrayList&lt;Edge&gt; edgeList){ for (int i = 0; i &lt;edgeList.size() ; i++) { Edge edge = edgeList.get(i); System.out.println(&quot;Edge-&quot; + i + &quot; source: &quot; + edge.src + &quot; destination: &quot; + edge.destination + &quot; weight: &quot; + edge.weight); } } private void union(int[] parent, int x_set, int y_set) { int x_set_parent = find(parent,x_set); int y_set_parent = find(parent,y_set); parent[y_set_parent] = x_set_parent; } // 부모 vertex (node)를 반환 private int find(int[] parent, int src) { if(parent[src] != src){ return find(parent,parent[src]); } return src; } private void makeSet(int[] parent) { for(int i = 0 ; i &lt; vertices ; i ++ ){ parent[i] = i; } } } public static void main(String[] args) { int vertices = 6; Graph graph = new Graph(vertices); graph.addEdge(0, 1, 4); graph.addEdge(0, 2, 3); graph.addEdge(1, 2, 1); graph.addEdge(1, 3, 2); graph.addEdge(2, 3, 4); graph.addEdge(3, 4, 2); graph.addEdge(4, 5, 6); graph.kruskalMst(); }} 시간복잡도kruskal 알고리즘의 수행시간은 find-union algorithm의 시간복잡도와 거의 동일하다 (O(MlogN)) Reference https://www.hackerearth.com/practice/algorithms/graphs/minimum-spanning-tree/tutorial/ https://ko.wikipedia.org/wiki/%EC%84%9C%EB%A1%9C%EC%86%8C_%EC%A7%91%ED%95%A9_%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0 양성봉 저 - 파이썬과 함께하는 자료구조의 이해 (http://www.yes24.com/Product/Goods/57949931)","link":"/2021/08/08/2021-08-08-kruskal-DESKTOP-QF32SHN/"},{"title":"Kruskal algorithm - MST","text":"kruskal 알고리즘은 최소 신장 트리 (Minimum Spanning Tree,MST)를 구하는 알고리즘으로, 그리디 알고리즘에 속한다 kruskal 알고리즘에 대해 배우기 전에 기본적으로 그래프에서 신장트리,연결성분등 용어를 알아야 원할하게 이해할 수 있다. 연결성분(Connected Component): 그래프에서 정점들이 서로 연결되어 있는 부분 신장트리(Spanning Tree) : 주어진 그래프가 하나의 연결 성분으로 구성되어 있을떄, 그래프의 모든 정점들을 cycle없이 연결하는 부분그래프 최소 신장 트리 (MST): 하나의 연결성분으로 이루어진 무방향 가중치 그래프 에서 간선의 가중치의 합이 최소인 신장트리 , 당연히 신장트리 임으로 cycle이 있어서는 안된다. kruskal 알고리즘의 수행과정은 다음과 같다. 가중치가 감소하지 않는 순서로 정렬한다. 가중치가 가장 작은 간선이 cycle을 만들지 않으면 신장트리 간선으로 선택한다. 2번 과정을 N(정점의 개수)-1 개수의 간선이 선택될떄까지 반복한다. 위 수행과정에서 가중치가 작은 순서대로 신장트리 간선을 선택하는데, cycle을 형성하는 4번은 제외되었다. kruskal algorithm을 python으로 구현하면 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142from collections import deque;weights = [(0,1,9),(0,2,10),(1,3,10),(1,4,5), (1,6,3),(2,3,9),(2,4,7),(2,5,2), (3,5,4),(3,6,8),(4,6,1),(5,6,6) ] ##(간선A,간선B,가중치)#오름차순으로 가중치 정렬weights.sort(key = lambda t : t[2]);weights = deque(weights);mst= []; N = 7;# disjoint set (서로소 집합)p = [ i for i in range(N)];# 서로소를 구하기 위한 find,union 연산 # find : 노드의 집합의 루트 노드(=대표노드)를 찾는 연산 def find(u): if u != p[u]: # 경로 압축 (find연산을 수행하면서 루트까지 올라가는 경로 상의 각 노드의 부모노드를 루트노드로 갱신한다. ) p[u] = find(p[u]); return p[u];# union : 두 노드를 하나의 집합으로 합친다def union(u,v): root1 = find(u); root2 = find(v); p[root2] = root1; tree_edges=0;mst_cost=0;while tree_edges!=(N-1): #가중치가 가장 작은 간선을 선택하고, u,v,wt = weights.popleft(); # 해당 노드의 루트노드를 비교해 다르면 , 서로 다른 집합임을 확인 (cycle이 형성되지 않음을 확인 ) if find(u) != find(v): # 두 노드를 하나의 집합으로 합침 union(u,v); # 최소 신장트리의 간선으로 선택 mst.append((u,v)); mst_cost+=wt; tree_edges+=1;print(mst); 시간복잡도kruskal 알고리즘의 수행시간은 find-union algorithm의 시간복잡도와 거의 동일하다 (O(MlogN)) Reference https://www.hackerearth.com/practice/algorithms/graphs/minimum-spanning-tree/tutorial/ https://ko.wikipedia.org/wiki/%EC%84%9C%EB%A1%9C%EC%86%8C_%EC%A7%91%ED%95%A9_%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0 양성봉 저 - 파이썬과 함께하는 자료구조의 이해 (http://www.yes24.com/Product/Goods/57949931)","link":"/2021/08/08/2021-08-08-kruskal/"},{"title":"spring batch (1)","text":"배치 처리란? 일반적인 GUI를 가진 app은 사용자와 상호작용함 사용자와 상호작용없이 유한한 양의 데이터를 처리하는 것 (GUI없음) 배치 처리 적용 예시 ETL process (한 데이터 형식에서 다른 데이터 형식으로 전환 ), Data Migration 병렬 처리 배치 아키 텍쳐 배치 아키텍쳐는 위와 같이 구성 된다. application layer: 배치 처리 구축에 사용되는 모든 사용자 코드 batch core layer: 배치 도메인을 정의하는 모든 부분 ex) job,jobLauncher,step infrastructure layer : ItemReader, ItemWrite와 같이 실질적으로 File I/O를 수행하는 component와 배치처리 재시작과 관련된 여러 component 배치 도메인 특화 개념 Job : 중단이나 상호작용없이 처음부터 끝까지 처리되는 처리로 Job은 여러개의 step 으로 구성될수 있다. spring boot는 default로 application 이 띄워지는 시점에 Job을 찾아서 실행시켜준다. Step : Job을 구성하는 독립된 작업 단위로 병렬처리가 가능하다, tasklet 기반의 step 과 chunk 기반의 step 두 가지로 나뉜다. tasklet Step step이 중단될떄까지 execute method 가 계속해서 실행된다 (=&gt; 매번 execute마다 독립적인 transaction이 얻어진다. ) Chunk Step tasklet step 보다 복잡하며 주로 db tuple이나, file entry와 같은 item을 처리하는데 사용된다. ItemReader,ItemProcessor,ItemWriter로 구성된다. (ItemProcessor는 필수가 아님) Job Repository RDBMS를 사용해서 배치처리를 하는데 사용되는 여러 수치값을 관리한다 (배치 작업 처리 시작,종료시간,읽기/쓰기횟수 등 배치 관련 메타) 여러 배치 주요 component에 의해 공유 된다. Job Launcher Job.execute를 통해 Job을 실행하는 역할로 이외에도 파라미터 검증, Job 실행 가능여부 확인 등의 기능을 수행한다. 12345public interface JobLauncher { public JobExecution run(Job job, JobParameters jobParameters) throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException, JobParametersInvalidException;} *정리JobLauncher가 Job 실행 -&gt; Job을 구성하고 있는 각 step을 실행 -&gt; chunk 처리 상태에 따라 JobRepository가 StepExecution 상태 갱신 -&gt; 최종적으로 JobExecution 상태 갱신 JobInstance spring batch job의 논리적인 작업 실행 단위로, job의 이름과 job의 실행을 위해 제공되는 parameter 로 유일하게 존재한다 ex) 예를 들어 파라미터로 작업이 실행되는 날짜를 전달한다고 하면 해당 날짜의 배치 jobInstance가 생성된다. 123456789101112131415161718192021222324252627package org.springframework.batch.core;import org.springframework.util.Assert;import java.util.Locale;public class JobInstance extends Entity implements javax.batch.runtime.JobInstance { private final String jobName; public JobInstance(Long id, String jobName) { super(id); Assert.hasLength(jobName, &quot;A jobName is required&quot;); this.jobName = jobName; } public String getJobName() { return this.jobName; } public String toString() { return super.toString() + &quot;, Job=[&quot; + this.jobName + &quot;]&quot;; } public long getInstanceId() { return super.getId(); }} JobExecution spring batch Job의 실제 실행 , 즉 Job을 구동할떄마다 매번 새로운 JobExecution instance 가 생성된다. Job을 처음 실행하게 되면 JobInstance 와 JobExecution instance가 생성된다, 만약 해당 Job이 실패해서 재실행하면 동일한 JobInstance를 사용하고, JobExecution instance는 새롭게 생성된다.따라서 Job과 JobInstance JobExecution은 다음과 같은 관계를 가진다. (Job 1: JobInstance N ,JobInstance 1 : JobExecution N relationship) 123456789101112131415161718192021public class JobExecution extends Entity { private final JobParameters jobParameters; private JobInstance jobInstance; private volatile Collection&lt;StepExecution&gt; stepExecutions; private volatile BatchStatus status; private volatile Date startTime; private volatile Date createTime; private volatile Date endTime; private volatile Date lastUpdated; private volatile ExitStatus exitStatus; private volatile ExecutionContext executionContext; private transient volatile List&lt;Throwable&gt; failureExceptions; private final String jobConfigurationName; public void upgradeStatus(BatchStatus status) { this.status = this.status.upgradeTo(status); }// ... } Reference 마이클 미네랄 지음 | 서경석, 김성유느 이승룡 옮김 - 스프링 배치 완벽 가이드 (http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9791161755168) spring 공식 reference doc (https://spring.io/projects/spring-batch)","link":"/2021/11/01/2021-11-01-spring-batch-01/"},{"title":"TDD (테스트 주도 개발, Test Driven Development) 와 JUnit","text":"TDD란? 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법 테스트 코드가 기능 정의서처럼 기능함 테스트를 먼저 만들고, 테스트가 성공하도록 하는 코드를 만드는 식으로 진행하기 때문에, Test coverage 영역이 높아진다. 테스트를 작성하는 시간과, application 코드를 작성하는 시간의 간격이 짧아진다. TDD 예시) userDao 객체가 DB에 데이터가 비어있는 경우, EmptyResultDataAccessException 예외를 발생시켜야 한다. (기능을 먼저 정의하고, 이에따라 테스트 코드를 작성한다. ) 123456789101112@Testpublic void getUserFailure() throws SQLException, ClassNotFoundException { ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class); UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); dao.deleteAll(); assertEquals(dao.getCount(),0); assertThrows(EmptyResultDataAccessException.class,()-&gt;dao.get(&quot;unknown_id&quot;));} 위의 test코드는 당연히 fail하며, 테스트가 성공하도록 userDao getMethod를 수정한다. 123456789101112131415161718192021222324public User get(String id) throws SQLException { Connection c = dataSource.getConnection(); User user = null; PreparedStatement ps = c.prepareStatement( &quot;select * from users where id = ?&quot; ); ps.setString(1,id); ResultSet rs = ps.executeQuery(); if(rs.next()){ user = new User(); user.setId(rs.getString(&quot;id&quot;)); user.setName(rs.getString(&quot;name&quot;)); user.setPassword(rs.getString(&quot;password&quot;)); } rs.close(); ps.close(); c.close(); // user가 null일대는 db에 데이터가 없으므로 EmptyResultDataAccessException 반환 if (user == null){ throw new EmptyResultDataAccessException(1); } return user;} 테스트 재실행시, 테스트가 성공하며 단위 테스트와 코드 구현이라는 작업이 동시에 끝나게된다. JUNIT JUnuit framework는 테스트 메소드를 실행할떄 부가적으로 해주는 작업을 지원해준다. @BeforeEach : Junit이 제공하는 annotation인 @Test 메소드가 각각 실행되기전에 먼저 실행돼야 하는 메소드를 정의한다. (이외에도 AfterEach , AfterAll, BeforeAll이 있다. ) 12345678910111213141516171819public class UserDaoTest { // 멤버 변수로 추출 private UserDao dao; @BeforeEach private void setUp() { System.out.println(&quot;### BeforeEach executed ###&quot;); ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class); this.dao = context.getBean(&quot;userDao&quot;, UserDao.class); } @Test public void count(){...} @Test public void addAndGet(){...} @Test public void getUserFailure(){...} JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식(JUnit은 framework임으로, 개발자가 만든 코드를 주도적으로 실행한다. =&gt; 실행흐름을 framework가 가지고 있다. ) Test 클래스에서 다음과 같은 조건을 가진 method를 모두 찾는다. @Test annotation public void parameter 가 없음 Test class object 를 하나 만든다. @BeforeEach가 붙은 method 가 있으면, 실행한다. @Test 가 붙은 method를 하나 호출하고, 테스트 결과를 저장해둔다. @AfterEach가 붙은 method가 있으면, 실행한다. 나머지 test method에 대해서 2~5번 과정을 반복한다.(즉 하나의 test method당 하나의 test object를 만들어준다.) 모든 테스트 결과를 종합해서 돌려준다. test method당 test object를 생성하는 이유 테스트가 서로 영향을 끼치지 않고 독립적으로 실행됨을 확실히 보장해주기 위함. 예를 들면 , 다음과 같이 멤버 변수를 사용한다하더라도, 결국에는 test method간에 공유가 되지 않음으로, 독립적으로 실행가능하다. 12345678910111213141516171819202122public class Test { int value = 0; @org.junit.jupiter.api.Test public void addOne(){ this.value+=1; System.out.println(&quot;value = &quot; + value); } @org.junit.jupiter.api.Test public void addTwo(){ this.value+=2; System.out.println(&quot;value = &quot; + value); } /*** 실행결과 value = 1 value = 2 멤버변수가 공유가 된다면 실행결과가 1+2, 2+1이든 3이 나와야 한다. ***/} Fixture 테스트를 수행하는데 필요한 정보나 object 여러 테스트에서 반복적으로 사용됨으로 @Before 로 생성해두면 편리 1234567891011121314151617181920public class UserDaoTest { // Fixture : dao , users private UserDao dao; private User user; private User user1; private User user2; @BeforeEach private void setUp() { ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class); this.dao = context.getBean(&quot;userDao&quot;, UserDao.class); this.user = new User(&quot;kcs1&quot;, &quot;kcs1&quot;, &quot;spring1&quot;); this.user1 = new User(&quot;kcs2&quot;, &quot;kcs2&quot;, &quot;spring2&quot;); this.user2 = new User(&quot;kcs3&quot;, &quot;kcs3&quot;, &quot;spring3&quot;); } 테스트간 context 공유 application context는 생성에 많은 리소스가 소모됨으로, 한번만 생성해서 테스트간 공유하면 된다. JUnit은 매번 test class 의 object를 새로 만들기 떄문에 멤버변수로 application context를 만든다하더라도, 매번 새롭게 생성된다. 1234567891011121314151617181920212223242526public class Test { ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class); @BeforeEach public void setUp(){ System.out.println(&quot;this.context = &quot; + this.context); System.out.println(&quot;this = &quot; + this); } @org.junit.jupiter.api.Test public void test1(){ System.out.println(&quot; test1 &quot; ); } @org.junit.jupiter.api.Test public void test2(){ System.out.println(&quot; test2 &quot; ); } /*** 실행결과 : 멤버변수에 선언해도 JUnit 프레임워크 작동방식에 의해 매번 새로운 컨텍스트가 만들어진다. this.context = org.springframework.context.annotation.AnnotationConfigApplicationContext@5230aae3 this = com.springstudy.ioc.Test@550de339 this.context = org.springframework.context.annotation.AnnotationConfigApplicationContext@4c0bf5d7 this = com.springstudy.ioc.Test@254e54b1 ***/} 이와 같은 문제가 있기 떄문에, Junit은 test context를 지원해준다. test 실행이전에 딱 한번만 application context를 만들어준다. (test class간에도 context configuration이 같다면 공유된다.) 12345678910111213141516171819202122232425262728293031323334@SpringBootTest// test application context 사용@ContextConfiguration(locations = &quot;/applicationContext.xml&quot;)// test context가 자동으로 만들어줄 application context의 위치 지정public class UserDaoTest { @Autowired private ApplicationContext context; private UserDao dao; private User user; private User user1; private User user2; @BeforeEach public void setUp() { System.out.println(&quot;this.context = &quot; + this.context); System.out.println(&quot; this &quot; + this ); this.dao = context.getBean(UserDao.class,&quot;userDao&quot;); this.user = new User(&quot;kcs1&quot;, &quot;kcs1&quot;, &quot;spring1&quot;); this.user1 = new User(&quot;kcs2&quot;, &quot;kcs2&quot;, &quot;spring2&quot;); this.user2 = new User(&quot;kcs3&quot;, &quot;kcs3&quot;, &quot;spring3&quot;); } /*** 실행결과 : 같은 test application context가 공유된다. this.context = org.springframework.web.context.support.GenericWebApplicationContext@65dc110, this com.springstudy.ioc.UserDaoTest@6648d51b this.context = org.springframework.web.context.support.GenericWebApplicationContext@65dc110, this com.springstudy.ioc.UserDaoTest@4a79b3f9 this.context = org.springframework.web.context.support.GenericWebApplicationContext@65dc110, this com.springstudy.ioc.UserDaoTest@7afc1a1e ***/","link":"/2021/11/07/2021-11-07-TDD-JUNIT/"},{"title":"spring filter vs interceptor","text":"application 여러 로직에서 공통으로 포함되어 있는 로직을 공통 관심사 (cross-cutting concern)이라고 한다. 웹 앱과 관련된 (ex) 로그인 ) 공통 관심사를 처리하는데, 주로 servlet filter 나, spring interceptor를 사용한다. Servlet Filter filter가 호출된 뒤에, dispatcher sevlet이 호출된다.ex) 모든 client 요청 로깅 filter는 특정 url 패턴에만 호출되도록 설정가능하다.ex) 로그인 요청시 활용 가능 123* filter 작동 흐름 1Client -&gt; HTTP 요청 | WAS 영역 -&gt; servlet filter 호출 -&gt; dispatcher servlet 호출 -&gt; controller 호출 | filter를 통해 적절하지 않은 사용자 요청 ex) 비로그인 사용자 라고 판단되면, dispatcher servlet 호출을 안할수도 있다. 123* filter 작동 흐름 2Client -&gt; HTTP 요청 | WAS 영역 -&gt; servlet filter 호출 (비로그인 확인) filter chain : 여러개의 filter 를 추가하여 적용 가능하다. 123* filter chainClient -&gt; HTTP 요청 | WAS 영역 -&gt; filter A =&gt; filter B =&gt; .... javax.servlet내 filter 는 다음과 같은 spec을 가지며, 해당 인터페이스를 구현하고, servlet container에 등록하면, servlet container가 생성될때, 해당 필터의 init() 초기화 메소드를 호출하고, 싱글톤 객체로 생성 및 관리한다. 12345678910111213141516171819202122package javax.serveltpublic interface Filter{ // 필터 초기화 메소드, 서블릿 컨테 public default void init(FilterConfig filterConfig) throws ServletException {}/***The doFilter method of the Filter is called by the container each time a request/response pair is passed through the chain due to a client request for a resource at the end of the chain. The FilterChain passed in to this method allows the Filter to pass on the request and response to the next entity in the chain.***/// client 요청시마다 doFilter가 호출된다. public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;// servlet container가 종료될때 호출된다. public default void destroy() {}} servlet filter 예시 javax.servlet.Filter 명세를 구현한 사용자 filter 생성 doFilter 로직 구현 (filter.doFilter()를 호출해주어야, 다음 dispatcher servlet또는 다음순서의 filter 가 호출된다.) 사용자 filter 등록 FilterRegistrationBean을 spring bean 객체로 등록하는 방법, filter chain 내 filter 적용 순서 설정 가능 @ServletComponentScan @Webfilter(filterName = ‘’ , urlPatterns = “/*”) 12345678910111213141516171819202122232425262728293031323334353637// Filter 생성 @Slf4jpublic class LogFilter implements Filter { // servlet container 생성될떄 logFilter 객체가 생성되면서 호출됨 @Override public void init(FilterConfig filterConfig) throws ServletException { log.info(&quot;log filter init &quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { log.info(&quot;log filter doFilter&quot;); HttpServletRequest httpServletRequest = (HttpServletRequest) request; String requestURI = httpServletRequest.getRequestURI(); String uuid = UUID.randomUUID().toString(); try{ log.info(&quot;REQUEST [{}][{}]&quot;,uuid,requestURI); // 다음 필터 호출 or 다음 필터가 없다면 servlet dispatcher 호출 chain.doFilter(request,response); }catch (Exception e){ throw e; }finally { log.info(&quot;response [{}][{}]&quot;,uuid,requestURI); } } // servlet container 종료될떄, 호출됨 @Override public void destroy() { log.info(&quot;log filter destroy&quot;); }} 1234567891011121314151617// Filter 등록 @Configurationpublic class WebConfig { @Bean public FilterRegistrationBean logFilter(){ FilterRegistrationBean&lt;Filter&gt; filterFilterRegistrationBean = new FilterRegistrationBean&lt;&gt;(); filterFilterRegistrationBean.setFilter(new LogFilter()); // filter는 chain으로 적용 가능하기 때문에 순서를 적용해주어야 한다. filterFilterRegistrationBean.setOrder(1); // 적용할 url 패턴 filterFilterRegistrationBean.addUrlPatterns(&quot;/*&quot;); return filterFilterRegistrationBean; }} Spring Interceptor spring MVC 제공 기술 servlet filter 와 적용되는 순서가 다르다. dispatcher servlet과 controller 사이에서 호출된다. servlet filer와 마찬가지로 urlPattern 적용 가능 (마찬가지로 로그인 및 인증체크 모듈 개발에 용이하다. ) 123* Spring Interceptor 작동 흐름 1Client -&gt; HTTP 요청 | WAS 영역 -&gt; servlet filter 호출 -&gt; dispatcher servlet 호출 -&gt; spring interceptor 호출 -&gt;controller 호출 | spring interceptor도 똑같이 chain으로 구성할 수 있다. 12* Spring Interceptor Chain Client -&gt; HTTP 요청 | WAS 영역 -&gt; servlet filter 호출 -&gt; dispatcher servlet 호출 -&gt; spring interceptor A =&gt; spring interceptor B =&gt; ... | org.springframework.web.servlet.HandlerInterceptor 인터페이스를 구현함으로, 사용 가능하다. servlet filerd와 차이점 (=&gt; inteceptor가 지원해주는 기능이 더 많다.) 1.controller 호출 전 , 후 , 요청 완료 이후 총 3 단계로 세분화되어 있음 2.preHandler에서 handler(Controller) 정보를 받을 수 있음 3.postHandler에서 ModelAndView 정보를 받을 수 있음 12345678910111213141516171819package org.springframework.web.servlet;public interface HandlerInterceptor { // controller 호출 전 // handler == controller // return 값이 true인 경우에만 다음으로 진행된다. default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {return true;} // controller 호출 후 default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception { } // Http 요청 완료 이후 (뷰 렌더링 이후에 호출된다.) // handler에서 발생한 Exception을 parameter로 받을 수 있다. default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception { }} spring interceptor는 servlet filter 보다 세분화된 기능을 지원하며, handler에서 예외 발생시에는 postHandle은 호출되지 않고, afterCompletion method만 호출된다. 123* Spring Interceptor 작동 흐름 2 (handler에서 Exception 발생시 )Client -&gt; HTTP 요청 | WAS 영역 -&gt; servlet filter 호출 -&gt; dispatcher servlet 호출 -&gt; interceptor.preHandle() -&gt;controller호출 -&gt; Exception! -&gt; interceptor.afterCompletion() | spring interceptor 예시 org.springframework.web.servlet.HandlerInterceptor 명세를 구현한 interceptor 생성 preHandle,postHandle,afterCompletion 로직 구현 (interceptor.preHandle method의 return true 해주어야 controller 가 호출된다. ) 사용자 interceptor 등록 configuration class 가 WebMvcConfigurer implements 하도록 함 @Overide addInterceptors method 12345678910111213141516171819202122232425262728293031323334@Slf4jpublic class LogInterceptor implements HandlerInterceptor { private static final String LOG_ID =&quot;logId&quot;; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String requestURI = request.getRequestURI(); String uuid = UUID.randomUUID().toString(); request.setAttribute(LOG_ID,uuid); log.info(&quot;REQUEST [{}][{}][{}]&quot;,uuid,requestURI,handler); if(handler instanceof HandlerMethod){ HandlerMethod hm = (HandlerMethod) handler;// 호출할 컨트롤러 메소드의 모든 정보 } // handler 호출 return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { String requestURI = request.getRequestURI(); String logId = (String) request.getAttribute(LOG_ID); log.info(&quot;RESPONSE [{}][{}][{}]&quot;,LOG_ID,requestURI,handler); if(ex!=null){ log.error(&quot;ERROR&quot;,ex); } }} 12345678910111213@Configurationpublic class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LogInterceptor()) .order(1) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/css/**&quot;,&quot;/*.ico&quot;,&quot;/error&quot;); }} Reference 스프링 MVC 2편 - 백엔드 웹 개발 활용 기술 , 김영한(https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-2/dashboard)","link":"/2021/11/08/2021-11-08-filter-vs-interceptor/"},{"title":"spring error page 설정 , 예외 처리","text":"servlet의 예외 발생 방식 Exception response.sendError(http 상태코드, 오류 메시지 ) 1. Exception web app에서 예외 발생시 상황 사용자 요청별로 별도의 쓰레드 할당 특정 사용자 요청시 예외 발생 -&gt; try~catch 문으로 예외 처리를 해주지 않는 경우 WAS까지 예외가 전달된다. 123controller(예외 발생) -&gt; interceptor -&gt; dispatcher servlet -&gt; filter -&gt; WAS (예외 전달 ) WAS까지 예외가 전달될 경우, 사용자에게 다음과 같은 에러 화면이 전달된다. (에러 화면을 별도로 설정하지 않는 경우에는) 12## application.propertiesserver.error.whitelabel.enabled=false 2. response.sendError(httpStatusCode) response.sendError 호출시 바로 예외가 발생하지는 않으나, HttpServletResponse 객체 안에 에러 발생 상태가 저장된다. servlet container 가 응답전에 sendError 호출여부를 확인하고, 오류페이지 정보를 확인하고 등록된 오류페이지가 없다면 에러코드에 맞는 기본 오류페이지를 보여준다 서블릿 에러 화면 설정 1234567891011@Componentpublic class WebServerCustomizer implements WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; { @Override public void customize(ConfigurableWebServerFactory factory) { ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, &quot;/error-page/404&quot;); ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, &quot;/error-page/500&quot;); ErrorPage errorPageEx = new ErrorPage(RuntimeException.class, &quot;/error-page/500&quot;); factory.addErrorPages(errorPage404,errorPage500,errorPageEx); }} org.springframework.boot.web.server.ErrorPage class는 다음과 같은 생성자를 갖는다. HttpStatus code 또는 Exception.class (* 예외 클래스의 자식 클래스까지) 와 에러 발생시 redirect(재요청) 할 주소를 통해 ErrorPage class를 생성하고, ConfigurableWebServerFactory 의 addErrorpages(…ErrorPages) method를 통해 사용자 지정 ErrorPage를 등록할 수 있다. 정리하면 ErrorPage에 명시된 error가 발생하면, servlet Container는 해당 ErrorPage class에 등록된 path로 redirect한다. 1sendError(HttpStatusCode,msg) or Exception 발생 -&gt; ErrorPage(HttpStatusCode or Exception.class,path)의 path 확인 -&gt; 해당 path 로 redirect 123456789101112131415161718192021222324252627public class ErrorPage { private final HttpStatus status; private final Class&lt;? extends Throwable&gt; exception; private final String path; public ErrorPage(String path) { this.status = null; this.exception = null; this.path = path; } public ErrorPage(HttpStatus status, String path) { this.status = status; this.exception = null; this.path = path; } public ErrorPage(Class&lt;? extends Throwable&gt; exception, String path) { this.status = null; this.exception = exception; this.path = path; } //... 따라서 다음과 같이 redirect 할 주소에 controller를 만들어두고, 해당 controller에서 사용자가 보여줄 에러 화면.html으로 rendering 하도록 할 수 있다. 1234567891011121314151617181920@Slf4j@Controller@RequestMapping(&quot;/error-page&quot;)public class ErrorPageController { @GetMapping(&quot;/500&quot;) public String errorPage500(HttpServletRequest request, HttpServletResponse response){ // error 관련 속성도 접근 가능 Object errorState = request.getAttribute(RequestDispatcher.ERROR_EXCEPTION); // Dispatcher Type 조회 가능 log.info(&quot;dispatcher type : {}&quot; , request.getDispatcherType()); log.info(&quot;errorPage 500&quot;); return &quot;error-page/500&quot;; } @GetMapping(&quot;/404&quot;) public String errorPage404(HttpServletRequest request,HttpServletResponse response){ log.info(&quot;errorPage 404&quot;); return &quot;error-page/404&quot;; }} spring boot는 위와 같은 과정을 모두 기본으로 제공한다. ErrorPage 를 “/error”경로로 자동등록 즉, WAS까지 예외가 전달되거나, response.sendError()가 호출되면 모든 오류는 spring controller에 default로 등록되어 있는 BasicErrorController에 의해 “/error”로 내려준다. 12345@Controller@RequestMapping(&quot;${server.error.path:${error.path:/error}}&quot;)public class BasicErrorController extends AbstractErrorController {} Basic Controller의 처리 우선 순위는 다음과 같다. View template Static 에러 적용 대상이 없을 떄는 templates/error.html Reference 스프링 MVC 2편 - 백엔드 웹 개발 활용 기술 , 김영한(https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-2/dashboard)","link":"/2021/11/09/2021-11-09-spring-error-page/"},{"title":"spring api 에러 처리","text":"API 예외처리는 단순히 오류 페이지를 반환하는 것보다 서버간 통신 규약에 따라 오류 응답 스펙을 정해놓고, JSON (또는 XML등 ) 으로 데이터를 내려준다. API 예외 처리도 스프링 부트가 기본으로 제공하는 BasicErrorController 을 사용할 수 있긴하지만, 서버간 통신규약에 맞게 json을 반환하려면 customizing 할 수 있어야 한다. 아래 BasicErrorController 를 보면 기본 path가 /error 임을 알 수 있고, errorHtml() , error() method 2개가 있는데, accept 헤더를 text/html 인 경우에는 errorHtml() 가 호출되고, accept 헤더를 application/json으로 요청하면, error() method가 호출되면서 http message body내 json 데이터를 서버로부터 받을 수 있다. 123456789101112131415161718192021222324252627282930@Controller@RequestMapping(&quot;${server.error.path:${error.path:/error}}&quot;)public class BasicErrorController extends AbstractErrorController { // errorHtml method : html view 제공 @RequestMapping(produces = MediaType.TEXT_HTML_VALUE) public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections .unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model); } // error : json 반환 @RequestMapping public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { HttpStatus status = getStatus(request); if (status == HttpStatus.NO_CONTENT) { return new ResponseEntity&lt;&gt;(status); } Map&lt;String, Object&gt; body = getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.ALL)); return new ResponseEntity&lt;&gt;(body, status); }} 서버에서 예외를 발생시키면 다음과 같은 BasicErrorController의 에러 메세지를 확인할 수 있다. 123456{ &quot;timestamp&quot;: &quot;2021-11-17T15:17:47.090+00:00&quot;, &quot;status&quot;: 500, &quot;error&quot;: &quot;Internal Server Error&quot;, &quot;path&quot;: &quot;/api/members/ex&quot;} 예외 메세지 customizing - HandlerExceptionResolver spring MVC는 controller 밖으로 예외가 던져진 경우 , 예외를 해결하고 동작을 새로 정의할 수 있는 org.springframework.web.servlet.HandlerExceptionResolver 인터페이스를 제공한다. 12345678public interface HandlerExceptionResolver { @Nullable ModelAndView resolveException( HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex); // handler == controller , ex == exception from controller } 위 인터페이스를 아래와 같이 구현해서, 상태코드를 변경해주거나, 임의의 json값으로 반환할 수 있다. 123456789101112131415161718192021222324@Slf4jpublic class MyHandlerExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { try{ if(ex instanceof IllegalArgumentException){ log.info(&quot;IllegalArgumentException resolver to 400&quot;); response.sendError(HttpServletResponse.SC_NOT_FOUND,ex.getMessage()); // exception을 정상흐름으로 변경 =&gt; 상태 코드는 400으로 변경하고 빈 modelAndView 반환 return new ModelAndView(); // 빈 modelAndView가 반환되면 view가 렌더링 되지 않고, 정상흐름으로 처리 // view 넣어주면 view 렌더링 // null 반환시 , 다음 ExceptionResolver 를 찾고, 없다면 예외를 던짐 } }catch (IOException e){ log.error(&quot;resolver ex&quot;,e); } return null; }} 구현한 HandlerExceptionResolver는 아래와 같이 등록할 수 있다. 123456789101112@Configurationpublic class WebConfig implements WebMvcConfigurer { @Override public void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) { // handlerExceptionResolver 등록 resolvers.add(new MyHandlerExceptionResolver()); }} HandlerExceptionResolver 의 반환 값에 따른 DispatcherServlet의 동작방식은 다음과 같다. 빈 ModelAndView 를 반환하는 경우 : 뷰가 없으므로, 뷰를 렌더링하지 않고, 정상흐름으로 servlet이 반환된다. ModelAndView 지정해서 반환하는 경우 : ModelAndView에 Model또는 View를 넣는 경우에는 넣어준 뷰를 렌더링한다. null을 반환하는 경우 : 다음 ExceptionResolver를 찾아서 실행하고, 만약 처리할 수 있는 ExceptionResolver가 없으면 예외처리가 안되고, 기존에 발생한 예외를 servlet 밖으로 던진다. 정리를 하면 controller에서 터진 예외가 WAS까지 올라가지 않고, handlerExceptionResolver를 거침으로서, 예외 처리를 수행해줄수 있다는 것이 핵심이다. spring이 기본적으로 제공하는 handlerExceptionResolver 구현체는 다음과 같이 3종류가 있다. 1) ExceptionHandlerExceptionResolver 2) ResponseStatusExceptionResolver : HTTP 상태코드 지정 3) DefaultHandlerExceptionResolver : spring 내부 기본 예외 처리 ResponseStatusExceptionResolver 예외에 따라 HTTP 상태 코드를 지정해주는 역할을 수행한다. @ResponseStatus가 달려있는 예외를 처리해주거나, ResponseStatusException 예외를 처리해준다. 예를 들면 다음과 같이 예외에 @ResponseStatus가 달려있는 경우, ResponseStatusExceptionResolver가 처리해준다. 1234@ResponseStatus(code = HttpStatus.BAD_REQUEST , reason = &quot;잘못된 요청 오류&quot; )public class BadRequestException extends RuntimeException{} controller 에서 예외가 발생 하면 handlerExceptionResolver 가 작동한다고 했다. ResponseStatusExceptionResolver 는 spring이 기본으로 제공해주는 handlerExceptionResolver의 구현체 중 하나로서 , @ResponseStatus가 붙은 예외와 ResponseStatusException 예외를 처리해주는 것이다. 12345678910111213141516171819202122232425262728/** * A {@link org.springframework.web.servlet.HandlerExceptionResolver * HandlerExceptionResolver} that uses the {@link ResponseStatus @ResponseStatus} * annotation to map exceptions to HTTP status codes. * * &lt;p&gt;This exception resolver is enabled by default in the * {@link org.springframework.web.servlet.DispatcherServlet DispatcherServlet} * and the MVC Java config and the MVC namespace. * * &lt;p&gt;As of 4.2 this resolver also looks recursively for {@code @ResponseStatus} * present on cause exceptions, and as of 4.2.2 this resolver supports * attribute overrides for {@code @ResponseStatus} in custom composed annotations. * * &lt;p&gt;As of 5.0 this resolver also supports {@link ResponseStatusException}. * * @author Arjen Poutsma * @author Rossen Stoyanchev * @author Sam Brannen * @since 3.0 * @see ResponseStatus * @see ResponseStatusException */public class ResponseStatusExceptionResolver extends AbstractHandlerExceptionResolver implements MessageSourceAware {} ResponseStatusExceptionResolver 소스코드를 쭉 따라가보면 결국에는 다음과 같이 response.sendError(응답코드,메시지) 를 반환한다. 12345678910111213141516protected ModelAndView applyStatusAndReason(int statusCode, @Nullable String reason, HttpServletResponse response) throws IOException { if (!StringUtils.hasLength(reason)) { response.sendError(statusCode); } else { String resolvedReason = (this.messageSource != null ? this.messageSource.getMessage(reason, null, reason, LocaleContextHolder.getLocale()) : reason); response.sendError(statusCode, resolvedReason); } return new ModelAndView();} 추가로 다음과 같이 @ResponseStatus에 reason 속성을 message에서 찾아서 처리해줄 수도 있다. 123456@ResponseStatus(code = HttpStatus.BAD_REQUEST , reason = &quot;error.bad&quot; )public class BadRequestException extends RuntimeException{ // resources/messages.properties 아래 error.bad 값을 찾아 메세지로 넣어줌. } ResponseStatusExceptionResolver는 ResponseStatusException 을 처리해준다. 일종의 에러를 또 감싸주는 wrapper 에러라고 생각하면 편하다. 123456789@GetMapping(&quot;/api/response-status-ex2&quot;)public String responseStatusEx2(){ // 404 로 illeganArgumentException을 반환 throw new ResponseStatusException(HttpStatus.NOT_FOUND,&quot;error.bad&quot;,new IllegalArgumentException());} DefaultHandlerExceptionResolver spring 내부의 예외를 처리해준다. ex) parameter binding시점의 TypeMismatchException 를 400 오류로 반환해줌 ExceptionHandlerExceptionResolver 예외를 처리하고 싶은 controller에서 처리하고 싶은 예외를 @ExceptionHandler 로 지정해주고, 해당 controller에서 예외가 발생하면 ExceptionHandlerExceptionResolver가 호출되어, @ExceptionHandler가 붙은 메소드를 실행시켜준다. 처리하고 싶은 예외의 상속구조에 있는 자식 예외들도 동일하게 호출된다. 12345678910111213141516171819202122@RestController@Slf4jpublic class ExampleController { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(IllegalArgumentException.class) // IllegalArgumentException 또는 그 자식 예외가 들어올떄 실행된다. public ErrorResult illegalExHandler(IllegalArgumentException e){ log.error(&quot;[exceptionHandle] ex&quot;,e); return new ErrorResult(&quot;BAD&quot;,e.getMessage()); } @ExceptionHandler // 예외 class를 별도로 지정해주지 않는 경우에는 parameter의 예외를 처리해준다 즉 아래의 경우에는 UserException이 들어올떄 실행된다. public ResponseEntity&lt;ErrorResult&gt; userExHandle(UserException e){ log.error(&quot;[exceptionHandle] ex&quot;,e); ErrorResult errorResult = new ErrorResult(&quot;USER-EX&quot;, e.getMessage()); return new ResponseEntity&lt;&gt;(errorResult,HttpStatus.BAD_REQUEST); }} 위 방식의 단점은 controller에 예외처리코드와 controller 본연의 requestMapping 코드가 섞여있다. spring에서는 위와 같은 책임을 분리할 수 있는 방법도 제공하고 있다. @ControllerAdvice annotaion을 활용하면 에러코드 로직을 별개의 class로 분리할 수 있다. 대상 controller을 지정해주지 않으면 global 적용된다. 12345678910111213141516171819202122232425262728@Slf4j@RestControllerAdvice // public class ExControllerAdvice { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(IllegalArgumentException.class) public ErrorResult illegalExHandler(IllegalArgumentException e){ log.error(&quot;[exceptionHandle] ex&quot;,e); return new ErrorResult(&quot;BAD&quot;,e.getMessage()); } @ExceptionHandler public ResponseEntity&lt;ErrorResult&gt; userExHandle(UserException e){ log.error(&quot;[exceptionHandle] ex&quot;,e); ErrorResult errorResult = new ErrorResult(&quot;USER-EX&quot;, e.getMessage()); return new ResponseEntity&lt;&gt;(errorResult,HttpStatus.BAD_REQUEST); } @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler public ErrorResult exHandle(Exception e){ log.error(&quot;[exceptionHandle] ex&quot;,e); return new ErrorResult(&quot;EX&quot;,&quot;내부 오류&quot;); }} Reference 스프링 MVC 2편 - 백엔드 웹 개발 활용 기술 , 김영한(https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-2/dashboard)","link":"/2021/11/17/2021-11-17-spring-api-error/"},{"title":"spring type converter","text":"spring 은 converter 인터페이스를 제공하여, 개발자가 spring에 추가적인 type 변환이 필요하면 이를 구현해서 등록할 수 있도록 지원해준다. 1234567891011121314151617package org.springframework.core.convert.converter;/** * A converter converts a source object of type {@code S} to a target of type {@code T}. */@FunctionalInterfacepublic interface Converter&lt;S, T&gt; { /** * Convert the source object of type {@code S} to target type {@code T}. * @param source the source object to convert, which must be an instance of {@code S} (never {@code null}) * @return the converted object, which must be an instance of {@code T} (potentially {@code null}) * @throws IllegalArgumentException if the source cannot be converted to the desired target type */ @Nullable T convert(S source); 아래와 같이 구현하여 사용할 수 있다. 12345678910import org.springframework.core.convert.converter.Converter;@Slf4jpublic class IntegerToStringConverter implements Converter&lt;Integer,String&gt; { @Override public String convert(Integer source) { log.info(&quot;convert source ={}&quot;,source); return String.valueOf(source); }} 뿐만 아니라 문자를 객체로, 객체를 문자로 바꾸는 데 특화된 converter인 formatter 도 존재한다. 1234567891011121314151617181920@Slf4jpublic class MyNumberFormatter implements Formatter&lt;Number&gt; {//문자를 객체로 변경 @Override public Number parse(String text, Locale locale) throws ParseException { log.info(&quot;text = {}, locale = {}&quot;,text,locale); // &quot;1000&quot; -&gt; 1000 NumberFormat format = NumberFormat.getInstance(locale); return format.parse(text); }// 객체를 문자로 변경 @Override public String print(Number object, Locale locale) { log.info(&quot;text = {}, locale = {}&quot;,object,locale); return NumberFormat.getInstance(locale).format(object); }} ConversionService 위와 같은 개별 converter를 묶어서 편리하게 사용할 수 있는 기능을 제공해준다. 12345678910111213141516package org.springframework.core.convert;/** * A service interface for type conversion. This is the entry point into the convert system. * Call {@link #convert(Object, Class)} to perform a thread-safe type conversion using this system. */public interface ConversionService { boolean canConvert(@Nullable Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType); boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType); @Nullable &lt;T&gt; T convert(@Nullable Object source, Class&lt;T&gt; targetType); @Nullable Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType);} 예를 들면 다음과 같이 spring이 제공하는 기본 defaultFormattingConversionService 를 활용해 converter, formatter (문자에 특화된 converter)를 등록하고 사용가능하다. 123456789101112131415161718192021public class FormattingConversionServiceTest { @Test void formattingConversionService(){ DefaultFormattingConversionService defaultConversionService = new DefaultFormattingConversionService(); // 컨버터 등록 defaultConversionService.addConverter(new StringToIpPortConverter()); defaultConversionService.addConverter(new IpPortToStringConverter()); defaultConversionService.addFormatter(new MyNumberFormatter()); // 컨버터 사용 IpPort ipPort = defaultConversionService.convert(&quot;127.0.0.1:8000&quot;, IpPort.class); assertThat(ipPort).isEqualTo(new IpPort(&quot;127.0.0.1&quot;,8000)); assertThat(defaultConversionService.convert(1000, String.class)).isEqualTo(&quot;1,000&quot;); assertThat( defaultConversionService.convert(&quot;1,000&quot;, Long.class)).isEqualTo(1000l); }} Converter의 활용실제로 spring 에서 converter/formatter 사용시에는 다음과 같이 등록한다. 12345678910@Configurationpublic class WebConfig implements WebMvcConfigurer { @Override public void addFormatters(FormatterRegistry registry) { registry.addConverter(new StringToIpPortConverter()); registry.addConverter(new IpPortToStringConverter()); registry.addFormatter(new MyNumberFormatter()); }} controller에서 model 객체에 converting 할 객체를 담아서 보내면, thymeleaf template engine에서 등록된 converter를 사용해서 다음과 같이 convert 할수 있다. 이떄 converter를 사용하려면 { { converting 대상 } } 을입력한다. 또는 th:field로도 꺼내 사용할 수 있다. 1234&lt;!-- converter 사용 전--&gt; &lt;li&gt;${ipPort}: &lt;span th:text=&quot;${ipPort}&quot; &gt;&lt;/span&gt;&lt;/li&gt;&lt;!-- converter 사용 후 --&gt; &lt;li&gt;${{ipPort}}: &lt;span th:text=&quot;${{ipPort}}&quot; &gt;&lt;/span&gt;&lt;/li&gt; 참고사항아래와 같이 annotaion을 활용해서 지정해둔 패턴으로 객체를 문자로 , 문자를 객체로 변환해주는 formatter 사용을 지원해준다. 123456789@Datastatic class Form{ @NumberFormat(pattern = &quot;###,###&quot;) private Integer number; @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) private LocalDateTime localDateTime;}","link":"/2021/11/18/2021-11-18-spring-type-converter/"},{"title":"kotlin에서 null type 다루기","text":"코틀린에서 Null type 허용하는 방법12345fun test() { val name = &quot;dolly&quot;; name =null; // compile error} 변수에 null을 할당 가능하게 하려면 다음과 같이 변수의 타입을 정의할떄, 물음표를 추가하면 된다. 12345678class Person ( val first: String , // middle 변수에 null값이 들어갈수도있음. val middle: String? , val last: String) { val jkRolling = Person(&quot;Joanne&quot;,null,&quot;Rowling&quot;) val northWest = Person(&quot;North&quot;,null,&quot;West&quot;)} 코틀린은 nullable한 String? 이 null값이 아님이 보증이 되면 String type으로 smart cast 해준다. IDE 에서 찍어봐도 String? 가 null이 아님이 보장되자, String type으로 smart cast 되었음을 알려준다. 만약 변수를 val가 아닌, 중간에 값이 변경될 수 있는 var로 선언 되었다면 smart cast가 가능할까? 위와 같이 var를 사용한 경우에는 변수가 정의된 시점이후로 값이 변경되었을수도 있다고 가정을 하고, smart cast를 수행해주지 않는다. 따라서 이를 우회할려면 개발자가 명시적으로 단언 연산자 (not null assertion operator,!!) 를 사용해야한다. 12345var person = Person(last = &quot;chansoo&quot;, first = &quot;kim&quot;, middle = &quot;hello&quot;);if(person.middle != null){ val middleNameLength = person.middle!!.length; // null이 아님을 개발자가 보장 print(middleNameLength)} 위와 같은 상황에서는 안전 호출 연산자를 사용할 수 있다. 안전 호출 연산자는 null 이면 null을 반환해주고 null이 아닌 경우, 연산을 수행해준다. 여기서 문제는 결과 추론한 타입도 Nullable한 Int? 타입이다. (안전 호출 연산자 사용 -&gt; null or Int 값임으로 Int?로 결과 추론 ) 이떄는 엘비스 연산자를 사용하면 조금 더 유동적으로 코딩이 가능하다. 엘비스 연산자는 자신의 왼쪽에 위치한 식의 값을 확인해서 해당 값이 null 이라면 자신의 오른쪽에 위치한 값을 돌려준다. 1234person.middle?.length ?: 0// 안전연산자 -&gt; null or int // 엘비스 연산자 -&gt; null이나오면 0을반환 , 아니라면 int 반환// 어쩄거나 둘다 int 값임 코틀린에서는 안전 타입 변환 (safe cast) 연산자 (as?) 를 제공한다. 12val p1 = person as? Person;// p1 타입 :Person? person이라는 인스턴스가 Person으로 타입 변환을 하려고 하는데, Person이 아니라면ClassCastException 예외가 터질 것이다. 코틀린에서는 이를 유동적으로 처리할수 있게 안전타입 변환자를 통해 타입 변환에 실패하면 null을 반환하게 해준다. 12345val hello :String = &quot;fake person&quot;;val p1 = hello as? Person;// p1 타입 :Person?print(p1); // null을 반환해줌.","link":"/2021/12/04/2021-12-04-kotlin-null-type/"},{"title":"Item10. equals는 일반 규칙을 지켜 재정의하라","text":"Java에서 최상위 class인 Object의 final이 아닌 methode들 (equals, hashCode, toString ,clone, finalize)는 모두 overriding을 염두에 두고 설계된 것이라, overriding시 지켜야 하는 일반 규약이 명확하다. 1public boolean equals(Object obj); 이 중에서 equals method는 == 연산자와 마찬가지로 참조변수의 참조값을 비교하도록 정의되어 있는데, 다음과 같은 상황에서는 overriding 하지 않는 것이 좋다. 12345671. 각 인스턴스가 고유한 경우 ex) Thread와 같이 객체가 값을 표현하는 목적이 아닌 경우2. 인스턴스가 논리적으로 동일한지 검사할 일이 없는 경우3. 상위 class에서 재정의한 equals가 하위 클래스에도 적합한 경우 4. 클래스가 private 이거나, package-private이고, equals method가 호출될 일이 없는 경우 equals는 언제 overriding해야하는가? 두 객체가 참조값이 동일한지(물리적으로 동일한 주소값을 같는지) 가 아니라, 두 객체가 논리적으로 동일한지 값을 비교하고자 할떄 사용한다. 인스턴스가 둘 이상 만들어지는 값 클래스 equals method overriding시 규약12345678910111. 반사성 (reflexivity) : null이 아닌 모든 참조값 x에 대해 x.equal(x) == true2. 대칭성 (symmetry) : null이 아닌 모든 참조값 x,y에 대해 y.equals(x) == true -&gt; x.equals(y) == true3. 추이성 (transitivity) : null이 아닌 모든 참조값 x,y,z에 대해 x.equals(y) == true , y.equals(z) == true -&gt; x.equals(z) == true4. 일관성 (consistency) : null이 아닌 모든 참조값 x,y에 대해 x.equals(y) 를 반복해서 호출하면 항상 true or false5. null 아님 ( https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object) ) 상속구조에서 Equals method 정의12345678910111213141516171819@AllArgsConstructorpublic class Coffee { protected Integer temperature; // 커피 온도 protected Size size; // 커피 사이즈 Large,Medium,Small @Override public boolean equals(Object o) { if( !(o instanceof Coffee)){ return false; } Coffee coffee = (Coffee) o; return this.size.equals(coffee.size) &amp;&amp; this.temperature.equals(coffee.temperature); }} 12345678910111213141516171819public class Espresso extends Coffee { private Integer shotNum; public Espresso(Integer temperature, Size size , Integer shotNum) { super(temperature, size); this.shotNum = shotNum; } @Override public boolean equals(Object o) { if(!(o instanceof Espresso)){ return false; } return super.equals(o) &amp;&amp; ((Espresso) o).shotNum.equals(this.shotNum); }} 위와 같이 코드를 짜면, 자식 클래스에 새로운 값타입이 추가되서 자식에서 equals를 호출하게 되면 , 대칭성이 성립하지 않는다. 12345678910111213141516171819class CoffeeTest { @Test void testSymmetry() { Coffee coffeeA = new Coffee(25, Size.MEDIUM); Coffee coffeeB = new Coffee(25, Size.MEDIUM); assertThat(coffeeA.equals(coffeeB)).isEqualTo(coffeeB.equals(coffeeA)); } @Test @DisplayName(&quot;상속구조에서 equals 테스트&quot;) void testSymmetryInheritance(){ Coffee coffee = new Coffee(25, Size.MEDIUM); Espresso espresso = new Espresso(25, Size.MEDIUM, 3); assertThat(espresso.equals(coffee)).isNotEqualTo(coffee.equals(espresso)); }} 해결방법 equals method 를 instance of 대신 class가 다르면 false를 반환 (지양) * 리스코프 치환 원칙(LSP) : 상위 타입의 객체를 하위 타입의 객체을 사용하는 프로그램은 정상적으로 동작해야 함을 위배 contains와 같이 내부적으로 equals를 사용하는 method에서 하위 class가 들어오면 parameter와 무관하게 항상 부모class와 같지않음을 return 함. 123456789101112131415161718192021@AllArgsConstructorpublic class Coffee { protected Integer temperature; // 커피온도 protected Size size; // 커피 사이즈 Large,Medium,Small @Override public boolean equals(Object o) { if( o == null || o.getClass() != this.getClass()){ return false; } Coffee coffee = (Coffee) o; return this.size.equals(coffee.size) &amp;&amp; this.temperature.equals(coffee.temperature); }} 2. 상속 대신 컴포지션 사용 상속구조를 버리고, 멤버변수에 값타입으로 사용한다. (지향) 12345678910111213141516171819202122232425public class Espresso { private Coffee coffee; private Integer shotNum; public Espresso(Integer temperature , Size size , Integer shotNum) { this.coffee = new Coffee(temperature, size); this.shotNum = shotNum; } public Coffee asCoffee(){ return coffee; } @Override public boolean equals(Object o) { if(!(o instanceof Espresso)){ return false; } Espresso ep = (Espresso) o; return ep.coffee.equals(ep) &amp;&amp; (ep).shotNum.equals(this.shotNum); }} 더이상 상속구조가 아니기에 다음과 같이 값타입을 view method로 꺼내서 비교하면 된다. 1234567@Testvoid testEquals() { Espresso espresso = new Espresso(25, Size.MEDIUM, 10); Coffee coffee = new Coffee(25, Size.MEDIUM); assertThat(espresso.asCoffee().equals(coffee)).isTrue(); assertThat(coffee.equals(espresso.asCoffee())).isTrue();} 결론은 equals 비교할일이 없다면 굳이 재정의하지말고 값을 비교해야할 값타입인 경우에는 상속구조를 사용하지 말고, 필드로 값을 추가한다. equals method 구현방법 정리123456789101. == 연산자를 이용해 입력이 자신의 참조인지 확인2. instanceof 로 타입 확인3. 명시적 형 변환 4. 값이 같다고 판단할떄 필요한 필드들의 일치여부 확인 +) hashCode도 재정의 (item 11)","link":"/2021/12/06/2021-12-06-item10/"},{"title":"Item8. finalizer와 cleaner 사용을 피해라","text":"Java는 두가지 객체 소멸자를 제공한다. finalizer cleaner 여기서 객체 소멸자란 생성자와 정반대의 개념으로, 객체가 소멸될떄(GC될때)자동으로 호출되는 함수이다. Java 9에서부터는 finalizer를 사용 자제해야 할 API로 지정하고, cleaner를 그 대안으로 소개하였다. 하지만 책에서는 cleaner또는 finalizer의 사용을 피하라고 얘기하고 있다,.그렇다면 finalizer와 cleaner는 왜 사용하면 안될까? 12345@Override // deprecated protected void finalize() throws Throwable { super.finalize();} 단점 1. finalizer와 cleaner는 즉시 수행된다는 보장이 없다.객체의 소멸을 GC가 담당하므로, finalizer와 cleaner를 언제 수행할지의 역할은 전적으로 GC 알고리즘에 달려있다. 즉 GC 구현마다 차이가 있다. 위와 같은 특징들을 보면 당연히 finalizer와 cleaner로는 제때 실행되어야 하는 작업은 절대 할 수 없다. 단점 2. finalizer는 instance 반납을 지연시킬 수도 있다.finalizer 쓰레드는 우선순위가 낮아서 , 언제 실행될지 모른다. -&gt; 계속 대기 된다면 GC되지 않고, OutOfMemoryException이 발생할수도 있다. 단점 3. finalize 동작 중에 발생한 에러는 무시되며, 처리할 작업이 남았더라도, 그 순간 종료된다.중간에 예외가 터지면, 객체가 훼손된 상태로 남아있을수도 있다. 단점 4. 성능 문제AutoCloseable 객체를 만들고, try-with-resoucre 로 자원 반납을 하는데 걸리는 시간은 12ns 인데 비해, Finalizer는 550ns 거의 약 50배가 걸렸다. cleaner도 60ns로, 5배정도 느리다. 그렇다면 finalizer나 cleaner를 어떻게 대체해주어야 하는가? 반환할 자원 class에 AutoCloseable 을 구현해주고, client에서 instance를 다 쓰고 나면 close method을 호출해주면 된다. finalizer와 cleaner의 적절한 용도 자원 소유자가 close method를 깜빡하고 호출하지 못하였을때, 안전망 역할을 해준다. 자바 객체가 아닌 native peer 회수 cleaner 사용예시 - 리소스 반환을 위한 안전망 역할1234567891011121314151617181920212223242526272829303132333435363738394041public class Room implements AutoCloseable{ private static final Cleaner cleaner = Cleaner.create(); private static class State implements Runnable{ int numJunkPiles; // public State(int numJunkPiles) { this.numJunkPiles = numJunkPiles; } @Override public void run() { System.out.println(&quot;clean room&quot;); numJunkPiles = 0; } } private final State state; private final Cleaner.Cleanable cleanable; public Room(int junk) { state = new State(junk); cleanable = cleaner.register(this,state); } @Override public void close() throws Exception { // 자원 사용하는 client가 리소스를 깜빡하고 반환하지 못하였을때, cleaner가 안전망 역할로써 이를 반환해준다 (gc될떄 호출됨 ) cleanable.clean(); }} 위 예시처럼 Room client가 명시적으로 close를 호출하는것을 깜빡하였다면 room이 GC에 의해 회수될때 cleaner가 state의 run method를 호출해줌으로서 , 리소스를 회수하는 역할을 해준다. (안전망 역할) 하지만 이조차도 try-with-resouces 블록으로 감싸면 필요하지 않다. 예를 들면 다음과 같다. 1234567public static void main(String[] args) throws Exception { try(Room myRoom = new Room(8)){ new Room(99); System.out.println(&quot; try - with -resource &quot; ); }} 정리하면 java 8 : finalizer / java 9 이후 : cleaner는 안전망 역할이나 네이티브 피어 객체 회수용 정도로만 사용하고, 이후에는 사용하지 말고, 대신 try-with-resource로 안전하게 자원을 반환하자는 내용이다.","link":"/2021/12/05/2021-12-05-item8/"},{"title":"Item9. try-finally 보다는 try-with-resource를 사용하라.","text":"코딩을 하다보면 close method를 통해 반환해주어야 하는 리소스가 많다(java.sql.Connection, java.io 관련 리소스 ex) InputStream,OutputStream ) , 개발자가 실수로 리소스 정리를 깜빡하는 경우가 있다. 주로 자원을 반환할떄 사용하던 try- finally 구문은 다음과 같다. 123456789static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try{ return br.readLine(); } finally { br.close(); }} 위 try - finally 의 단점은 다음과 같다. 중첩 try - finally 문 작성으로 코드가 장황해지고, 디버깅이 힘들어질수 있다. 예를 들면 , try문에서 예외가 터지고, finally문에서 다시 예외가 터지면, try문에서 발생한 예외가 finally 문에서 발생한 예외에 의해 삼켜진다. 아래와 같이 치킨리소스가 있다고 하였을때, try문에서 발생한 예외는 finally문에서 또다시 발생한 예외로 인해 보이지 않는다. 12345678910111213public class ChickenResource implements AutoCloseable{ public void logicA(){ System.out.println(&quot;logicA 호출&quot; ); throw new FirstError(); } @Override public void close() throws Exception { System.out.println(&quot;eat chicken&quot;); throw new SecondError(); }} 12345678910111213public static void main(String[] args) throws Exception { ChickenResource chickenResource = new ChickenResource(); try{ chickenResource.logicA(); // First Error 발생 } finally { chickenResource.close(); // First Error가 발생했지만, SecondError 가 이후에 발생하여 First Error는 보이지 않음 }} 위 코드에 try-with-resource를 사용하면 다음과 같이 코드가 간결해지고 명시적으로 close를 호출해줄 필요가 없다. 123456789public static void main(String[] args) throws Exception { try(ChickenResource chickenResource = new ChickenResource()){ chickenResource.logicA(); // close 묵시적으로 호출 }} 또한 두번쨰예외에 의해 삼켜진 첫번쨰예외도 suppressed : First exception stack trace도 확인할수가 있어 디버깅이 휠씬 유리하다는 장점이 있다. 또한 try안에 여러개의 리소스를 사용하여도 반환이 가능하다. 12345678910public static void main(String[] args) throws Exception { try(ChickenResource chickenResourceA = new ChickenResource(); ChickenResource chickenResourceB = new ChickenResource(); ){ chickenResourceA.logicA(); chickenResourceB.logicA(); }} 정리하면 리소스 회수에 try-with-resource를 사용하여, 코드 간결성과 디버깅 측면에서 장점을 가져가자는 것이다.","link":"/2021/12/06/2021-12-06-item9/"},{"title":"Item12. toString은 항상 overriding하자","text":"Object toString 은 별도로 overrriding 하지 않는 경우에는 class명@16진수_해시코드 를 반환한다. 1getClass().getName() + '@' + Integer.toHexString(hashCode()) Object 명세에 보면 toString은 간결하며, 사람이 읽기 쉬운 형태의 정보를 반환해야 하며, toString을 overrding한 모든 하위 클래스에서도 toString 을 재정의해야 하며, 해당 객체가 가진 주요 값 필드를 반환하는게 바람직하다.(https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) toString을 재정의하면 다음과 같은 장점을 가지고 있다. 해당 객체의 주요필드를 로그에 남김으로 빠른 디버깅 가능 선택사항 : toString 사용시 포맷을 문서화 여부 값 class라면 문서화하는 것을 권장하나, 단점은 해당 포맷에 종속된다. 포맷 명시 여부와 상관없이 toString 반환 값에 포함된 정보를 가져올 수 있는 API 제공해야 함","link":"/2021/12/12/2021-12-12-item12/"},{"title":"Item11. equals를 재정의시에는, hashCode도 같이 재정의하라.","text":"hashCode method는 해싱(hashing) 기법에 사용되는 해시함수를 구현한 것이다. hashCode가 반환해주는 결과값(해시코드값)은 hashTable,hashMap내 실제값이 저장되는 위치를 알려주는 일종의 인덱스로 사용된다. Object 명세에 보면 다음과 같이 기술되어 있다. (https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()) 1234567891011121. equals 비교에 사용되는 정보가 변환되지 않았다면, app이 실행되는 동안 객체의 hashCode값은 항상 같아야 함2. equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다. =&gt; 논리적으로 같은 객체는 같은 해쉬코드값을 반환해야 함3. equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode 값이 다를 필요는 없음 Java HashMap은 hash함수 적용할떄, hashCode값을 사용함으로 다른 두 객체가 hashCode값이 같다면 두 객체는 같은 인덱스로 해쉬됨(collision)으로 성능상 단점이 있음.(Jdk 8 hashMap:해시 키 값 충돌 시 separtate chaining 방식 사용) hashCode 구현 방법 int 변수 result를 선언한 후 객체의 첫번쨰 핵심필드 (equals에서 값비교시 사용하는 첫필드)의 해시 코드 계산해 초기화 나머지 핵심 필드들도 타입별로 해시코드 계산 기본 타입 필드 : boxingClass.hashCode(f) 참조 타입 필드 : hashCode를 재귀적으로 호출 (null인 경우: 0 반환) 배열 : 배열 내 원소들을 필드처럼 다루어, 해시코드 값을 계산하고 핵심 원소가 하나도 없는 경우 0 반환 , 모든 원소가 핵심원소라면 Arrays.hashCode 사용 계산된 해시코드로 result 갱신 ( result = 31 * result + c ) 31을 곱하는 이유 : 짝수를 곱하는 경우, 비트 쉬프트 연산과 같은 결과를 내고, overflow 발생시 값 소실될 가능성이 있음 예외: 파생필드는 제외, equals비교에 사용되지 않은 필드는 반드시 제외함 (똑같은 객체가 다른 해시 코드 값을 반환할 수 있다. ) 123456789101112131415161718192021222324252627282930// 값 보관을 위한 classpublic class PhoneNumber { // 값 비교를 위한 핵심필드 private short areaCode; private short prefix; private short lineNum; @Override public boolean equals(Object obj) { if( obj == this){ return true; } if (!(obj instanceof PhoneNumber)) { return false; } PhoneNumber pn = (PhoneNumber) obj; return pn.lineNum == this.lineNum &amp;&amp; pn.areaCode == this.areaCode &amp;&amp; pn.prefix == this.prefix; } @Override public int hashCode() { int result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); return result; }} 12345678910111213141516171819202122class PhoneNumberTest { @Test @DisplayName(&quot;핵심 필드가 모두 같은 경우에 두 객체는 논리적으로 같습니다.&quot;) void testEqualsAndHashCode() { PhoneNumber phoneNumberA = new PhoneNumber(900, 400, 200); PhoneNumber phoneNumberB = new PhoneNumber(900, 400, 200); Assertions.assertThat(phoneNumberA == phoneNumberB).isFalse(); Assertions.assertThat(phoneNumberA).isEqualTo(phoneNumberB); Assertions.assertThat(phoneNumberA.hashCode()).isEqualTo(phoneNumberB.hashCode()); } @Test @DisplayName(&quot;핵심 필드가 다른 경우에 두 객체는 논리적으로 다릅니다. &quot;) void testNotEqualsAndHashCode() { PhoneNumber phoneNumberA = new PhoneNumber(900, 400, 200); PhoneNumber phoneNumberB = new PhoneNumber(900, 400, 0); Assertions.assertThat(phoneNumberA == phoneNumberB).isFalse(); Assertions.assertThat(phoneNumberA).isNotEqualTo(phoneNumberB); Assertions.assertThat(phoneNumberA.hashCode()).isNotEqualTo(phoneNumberB.hashCode()); }} Object static method 중에 hash method를 이용하면 손쉽게 hashCode 함수를 작성 가능하나 성능은 더 느림 (boxing - unboxing) 12345@Overridepublic int hashCode(){ Objects.hash(lineNum,prefix,areaCode);} 해시의 키값으로 주로 사용되지 않는 객체인 경우에 굳이 클래스 로딩시점에 값을 초기화 시키지 않고, 지연로딩(Lazy Initialization)으로 성능 향상 가능 12345678910111213141516171819202122public class PhoneNumber { private short areaCode; private short prefix; private short lineNum; private int hashCode; // primitive int type - default 값 0으로 초기화 // ...equals method 생략 @Override public int hashCode() { // hashCode 가 실제로 호출될떄 값이 default면 초기화 int result = hashCode; if(result == 0){ result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); return result; } }} 정리 equals overriding시에는 hashCode도 overriding해 hashMap,hashTable등 hashCode를 사용해 해싱하는 API들이 정상적으로 작동하도록 만들자 논리적으로 같은 객체인 경우, 무조건 같은 hashCode값을 반환해야 하나, 논리적으로 다른 객체인 경우, 같은 hashCode값을 가질수도 있으나, hashMap등에서 사용할떄 collision이 발생해 최악의 경우 O(n) 시간복잡도를 가지게 성능을 떨어트린다.","link":"/2021/12/12/2021-12-12-item11/"},{"title":"Item13. clone overriding은 주의해서 진행하라","text":"Object class에는 clone() method가 protected로 선언되어 있고, 객체를 복사하려면 java.langCloneable Interface를 implement하여 복사할 수 있다. 123package java.lang;public interface Cloneable {} (https://docs.oracle.com/javase/7/docs/api/java/lang/Cloneable.html) Cloneable은 아무 method도 없는 marker interface지만 ,Object의 clone method의 동작 방식을 결정한다. Cloeanble을 구현한 class에서부터 만들어진 객체에서 clone을 호출하면 객체의 필드들을 복사한 객체를 반환하도록 하고, 그렇지 않은 객체에서는 CloneNotSupportedException을 던진다. java Object 명세에 적혀있는 clone method에서 지켜야할 규약은 다음과 같다. 123456789어떤 객체 x에 대해서도 다음은 true이다.1. x.clone() != x; (복사된 객체와 원복 객체의 주소가 다름)2. x.clone().getClass() == x.getClass();3. x.clone().equals(x) (일반적으로 참이나 필수는 아님)관례상 이 clone() method가 반환하는 객체는 super.clone을 호출해 얻어야 하며,반환된 객체와 원본 객체는 독립적이여야 한다. super.clone을 통해 method를 부모쪽으로 재귀적으로 호출해서 받으므로, 강제성이 없는 생성자 연쇄와 비슷한 방식이다. 문제는 clone() method를 통해 생성된 객체가 , 가변 객체를 참조하는 경우이다.예를 들어 다음과 같은 Hotel 객체가 있는데, 이 객체의 필드 중에 가변필드인 guests 필드가 있다고 가정하자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Slf4j@Getterpublic class Hotel implements Cloneable { public String location; public List&lt;Person&gt; guests; // 투숙객 // 입실 public void addGuest(Person person){ if(guests == null){ guests =new ArrayList&lt;&gt;(); } guests.add(person); } //투숙객 정보 변경 public void updateGuest(Person oldPerson, Person newPerson){ guests.stream().filter((guest) -&gt; guest.equals(oldPerson)) .findFirst() .ifPresentOrElse( (p)-&gt;{ log.info(&quot;투숙객을 찾아서 변경합니다.&quot;); p.setAge(newPerson.getAge()); p.setName(newPerson.getName()); }, ()-&gt;log.info(&quot;투숙객을 찾지 못했습니다.&quot;) ); } @Override public Hotel clone() { try { return (Hotel) super.clone(); } catch (CloneNotSupportedException e) { throw new AssertionError(); } } @Override public boolean equals(Object o) { if (this == o) { return true; } if ( !(o instanceof Hotel)) { return false; }; Hotel hotel = (Hotel) o; return Objects.equals(getLocation(), hotel.getLocation()) &amp;&amp; Objects.equals(getGuests(), hotel.getGuests()); } @Override public int hashCode() { return Objects.hash(getLocation(), getGuests()); }} 위 객체를 그대로 clone(얇은 복사) 한뒤 원본객체에서 투숙객 정보를 바꾸면 어떻게 될까? 12345678910111213141516171819202122232425262728293031class HotelTest { @Test @DisplayName(&quot;가변 객체를 얇은 복사를 사용하면 안됩니다.&quot;) void testClone() { Hotel hotel = new Hotel(); Person personA = new Person(10, &quot;김이름&quot;); Person personB = new Person(10,&quot;박이름&quot;); Person personC = new Person(10,&quot;장이름&quot;); Person newPerson = new Person(20,&quot;김새이름&quot;); hotel.addGuest(personA); hotel.addGuest(personB); hotel.addGuest(personC); // 얇은 복사 Hotel copyedHotel = hotel.clone(); // 물리적으로 다른 주소를 가지지만, 논리적으로는 동일한 copyedHotel assertThat(hotel != copyedHotel).isTrue(); assertThat(hotel.equals(copyedHotel)).isTrue(); List&lt;Person&gt; guests = hotel.getGuests(); // person A -&gt; personB 로 변경 hotel.updateGuest(personA,newPerson); List&lt;Person&gt; copyedGuest = copyedHotel.getGuests(); assertThat(copyedGuest.contains(newPerson)); }} 복사된 객체에서 guest가 원본 객체의 guests의 메모리 주소를 참조함으로 동일하게 바뀐다. clone method 는 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다. 위 내용을 참조해서 Hotel class의 clone 메소드를 수정하면 다음과 같다. 1234567891011121314@Overridepublic Hotel clone() { try { Hotel copyedHotel = (Hotel) super.clone(); List&lt;Person&gt; newGuests = new ArrayList&lt;&gt;(); // list의 모든 요소를 복사해준다. Collections.copy(newGuests,guests); copyedHotel.guests = newGuests; return copyedHotel; } catch (CloneNotSupportedException e) { throw new AssertionError(); }} +) 가변 필드가 final인 경우는 불가능 해시테이블과 같이 linkedList로 구현된 경우 Clone 방법1234567891011121314151617public class HashTable implements Cloneable{ private Entity[] buckets = new Entity[]{}; private static class Entry{ final Object key; Object value; Entry next; public Entry(Object key, Object value, Entry next) { this.key = key; this.value = value; this.next = next; } } } 위와 같이 각 해시테이블내 각 버킷 인덱스가 entry의 linkedList로 구현되어 있다고 하면 12345678910@Overrideprotected HashTable clone() { try{ HashTable result = (HashTable) super.clone(); result.buckets = buckets.clone(); return result; }catch (CloneNotSupportedException e){ throw new AssertionError(); }} 복제본은 자신만의 copy본을 갖지만 원본과 동일한 연결 리스트를 참조한다. 즉 복제본의 entry의 next가 원본의 entry를 가르킬수도 있는 가능성이 있다. 따라서 각 버킷을 구성하는 연결리스트 자체도 복사해야 한다. 재귀적으로 호출하여 복사 1234// 연결 리스트내 엔트리도 재귀적으로 복사해준다.public Entry deepCopy(){ return new Entry(key,value,next ==null ? null : next.deepCopy());} for loop 사용하여 복사 1234567public Entry deepCopy(){ Entry result = new Entry(key, value, next); for(Entry p = result ; p.next != null ; p = p.next){ p.next = new Entry(p.next.key,p.next.value , p.next.next); } return result;} 1234567891011121314151617@Overrideprotected HashTable clone() { try{ HashTable result = (HashTable) super.clone(); result.buckets = new Entity[buckets.length]; for (int i = 0; i&lt; buckets.length ; i++){ if(buckets[i] != null){ result.buckets[i] = buckets[i].deepCopy(); } } return result; }catch (CloneNotSupportedException e){ throw new AssertionError(); }} 객체를 생성하는 목적이 아닌 상속용 class는 cloneable을 구현해서는 안된다. 상속용 class에서 clone method를 하위 class에서 overriding 하지 못하게, final 로 구현시켜놓으면 된다. 1234@Overrideprotected final Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException();} 정리 cloneable 을 구현하는 모든 class는 clone을 overriding 해주어야 한다. 반환타입은 class 자신으로 , 접근 제한자는 public으로 설정한다. super.clone() 을 호출한뒤, 부모에 있는 가변 객체를 복사한다. 1234567891011121314// 복사 생성자 : 자신과 같은 class의 인스턴스를 받는 생성자 public Hotel ( Hotel hotel){ this.location = hotel.location; this.guests = new ArrayList&lt;&gt;(); Collections.copy(this.guests,hotel.getGuests());}// 복사 팩터리 public static Hotel getNewInstance(Hotel hotel){ return new Hotel(hotel);} clone() 보다는 복사 생성자 또는 복사 팩터리 방식을 고려하자 (배열 제외) 복사 생성자 , 복사 팩터리 방식을 사용하면 다음과 같은 이점을 갖기 때문이다. cloneable의 단점이 없다 (문서화된 규약에 종속적이지 않고, 불필요한 검사 예외도 던지지 않고, 형변환도 필요가 없음 ) 해당 class가 구현체라면 인터페이스 타입의 인스턴스를 인수로 받을 수 있다. (유연하게 개발이 가능하다)","link":"/2021/12/12/2021-12-13-item13/"},{"title":"Item14. Comparable을 구현할지 고려하라.","text":"compareTo는 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, generic하다. 123public interface Comparable&lt;T&gt; { public int compareTo(T o);} comparable을 구현했다는 것은 그 클래스의 인스턴스들에 순서가 있음을 뜻한다. 그래서 Comparable을 구현한 객체들의 배열은 다음과 같이 정렬이 가능하다. 123Arrays.sort(arrayOfInstance); 순서가 명확한 값 class를 작성한다면 Comparable 인터페이스 구현을 고려하자. compareTo method의 일반 규약은 다음과 같다. compareTo method는 주어진 객체와 this 객체의 순서를 비교한다. this 객체가 주어진 객체보다 작으면 음의 정수 , 같으면 0 , 크면 양의 정수를 반환하고 이 객체와 비교할수 없는 타입의 객체가 주어지면 ClassCastException을 던진다. 1. Comparable을 구현한 class는 모든 x,y에 대해서 sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) 2. Comparable을 구현한 class는 추이성을 보장해야 한다. ( x.compareTo(y) > 0 && y.compareTo(z) > 0)이면 x.compareTo(z) > 0이다. 3. Comparable을 구현한 class는 모든 z에 대해 x.compareTo(y) == 0 이면, sgn(x.compareTo(z)) == sgn(y.compraeTo(z)) 다. 4. 부가적으로 다음의 규약은 필수는 아니나 지키면 좋다.(x.compareTo(y) == 0) == x.equals(y) 여야 한다. 만약 위 식이 성립하지 않는다면 이 클래스의 순서는 equals method와 일관되지 않음을 명시해야 한다. compareTo규약을 지키지 못하면 비교를 활용하는 TreeSet, TreeMap, Collections,Array등의 클래스에서 제공해주는 API가 정상적으로 작동하지 않을 수도 있다. equals와 마찬가지로 기존 클래스를 확장한 구체 클래스에서 새로운 값 타입을 추가했다면, compareTo규약을 지킬 방법이 없으므로, item10에서 설명했던 것처럼 상속 대신에 독립된 class를 만들고, 이 클래스에 원래 클래스의 인스턴스를 가르키는 필드를 두고, 해당 인스턴스를 가르키는 view method 를 만들어주면 된다. 예를 들어, 아래와 같은 학생 class가 있고, 키를 기준으로 정렬한다고하면 comparable은 다음과 같이 overriding할 수 있을 것이다. 123456789101112131415161718192021222324252627@Getter@EqualsAndHashCode@ToStringpublic class Student implements Comparable&lt;Student&gt; { private String name; private Float height; private Student(String name, Float height) { this.name = name; this.height = height; } public static Student studentWithHeight(String name, Float height){ return new Student(name,height); } @Override public int compareTo(Student o) { return Float.compare(this.height,o.height); }} score 값을 추가하고자 할떄 student class를 상속하는 경우에는 equals와 compareTo 를 적절히 사용할 수 없기 때문에 (item 10 참조) 다음과 같이 멤버 변수로 값을 추가하고, 학생 타입은 view method로 꺼내서 비교한다. 123456789101112131415161718192021222324252627282930@Getter@ToStringpublic class StudentScore implements Comparable&lt;StudentScore&gt; { private Student student; private Integer score; public Student asStudent(){ return this.student; } private StudentScore(Student student, Integer score) { this.student = student; this.score = score; } public static StudentScore studentWithScore(Student student, Integer score){ return new StudentScore(student,score); } @Override public int compareTo(StudentScore o) { int result = Integer.compare(this.score, o.score); // 우선 순위 1 : 점수 if(result == 0){ result = this.asStudent().compareTo(o.asStudent()); // 우선 순위 2 : 학생 키 } return result; }} 12345678910111213141516171819202122232425class StudentTest { Student studentA = Student.studentWithHeight(&quot;철수&quot;,171.2f); Student studentB = Student.studentWithHeight(&quot;영희&quot;,184.3f); Student studentC = Student.studentWithHeight(&quot;아기&quot;,120.1f); @Test void compareToTest(){ Student[] studentList = new Student[]{studentA,studentB,studentC}; Arrays.sort(studentList); assertThat(studentList).containsExactly(studentC,studentA,studentB); } @Test void compareScoreTest(){ StudentScore studentScoreA = StudentScore.studentWithScore(studentA, 100); StudentScore studentScoreB = StudentScore.studentWithScore(studentB, 100); StudentScore studentScoreC = StudentScore.studentWithScore(studentC, 500); StudentScore[] studentScores = {studentScoreA, studentScoreB, studentScoreC}; Arrays.sort(studentScores); assertThat(studentScores).containsExactly(studentScoreA,studentScoreB,studentScoreC); }} compareTo의 마지막 규약은 필수는 아니나, compareTo method로 수행한 동치성 결과가 equals 결과와 같아야 한다는 것이다.이를 잘 지키면 compareTo로 줄지은 순서와 equals의 결과가 일관되게 한다. compareTo의 순서와 equals의 결과가 일관되지 않아도 class는 여전히 동작은 하지만 Collection이 제공하는 API에서 오류를 발생할 수 있다. 예를 들면 , BigDecimal class는 hashSet에서는 equals, TreeSet에서는 compareTo로 비교한다. 12345678910111213141516@Testvoid bigDecimal(){ BigDecimal decimalA = new BigDecimal(&quot;1.0&quot;); BigDecimal decimalB = new BigDecimal(&quot;1.00&quot;); Set&lt;BigDecimal&gt; hashDecimal = new HashSet&lt;&gt;(); hashDecimal.add(decimalA); hashDecimal.add(decimalB); // size : 2 Set&lt;BigDecimal&gt; treeDecimal = new TreeSet&lt;&gt;(); treeDecimal.add(decimalA); treeDecimal.add(decimalB); // size: 1 assertThat(hashDecimal.size()).isNotEqualTo(treeDecimal.size());} compareTo method 작성 요령은 equals와 비슷하다. 몇가지 차이점이 있는데, Comparable 은 타입을 인수로 받는 generic Interface임으로, compareTo method의 인수 타입은 컴파일 타임에 정해진다.(굳이 런타임에 형변환하는 건 당연히 안하는게 좋다. ) null을 인수로 넣어 호출하면 NullPointerException이 발생해야 한다. 어짜피 필드 값을 비교하려고 할떄, 객체가 null임으로 NPE가 발생할 것이다. compareTo는 equals와 다르게 동치인지를 비교하는게 아니라 순서를 비교한다. 객체 참조 필드를 비교하려면 compareTo method를 재귀적으로 호출하면 된다. Comparable 을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 한다면 Comparator 를 대신 사용한다. 123456789public final class CaseInsensitiveString implements Comparable&lt;CaseInsensitiveString&gt;{ String s; @Override public int compareTo(CaseInsensitiveString o) { // java 제공 comparator return String.CASE_INSENSITIVE_ORDER.compare(s,o.s); }} 위의 연습 예제였던 학생 class에 comparator를 적용하면 다음과 같다 , 람다를 활용하면 클래스 파일을 별도로 생성하지 않고, 조금 더 깔끔하게 코드를 구현할 수 있다. 12345678910111213141516171819@Test@DisplayName(&quot;인터페이스 방식 &quot;)void compartorTest() { // List.of는 unmodifiableList 를 만들기 때문에 sort 연산이 지원되지 않음 List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(List.of(this.studentA, studentB, studentC)); Collections.sort(studentList,new MyComparator()); assertThat(studentList).containsExactly(studentC,studentA,studentB);}@Test@DisplayName(&quot;람다 방식 &quot;)void compartorTest_Lambda() { List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(List.of(this.studentA, studentB, studentC)); Collections.sort(studentList,(x,y)-&gt;Float.compare(x.getHeight(),y.getHeight())); assertThat(studentList).containsExactly(studentC,studentA,studentB);} boxing된 primitive type들에 새로 정의된 정적 method인 compare를 이용해서 값을 비교하라 java 7이전 부터는 boxing된 primitive type들에 새로 정의된 정적 method인 compare가 없었기 떄문에 부등호(&gt;,&lt;&gt;) 로 값을 비교하였는데, java7부터는 이를 지원해주기 때문에, 실수가 발생할 수 있는 부등호보다는 정적 메소드를 사용하는게 좋다. 위 예제들도 모두 정적 메소드를 사용해서 구현하였다. class에 핵심 필드(비교하고자 하는 필드) 가 여러 개인 경우, 가장 핵심적인 필드부터 비교하자 가장 필터링이 많이 되는 필드부터 비교하면 성능상 이점이 있다. 1234567891011121314@Override public int compareTo(PhoneNumber o) { int result = Short.compare(areaCode,o.areaCode); //동치라면 또 다시 비교 if(result == 0) { result = Short.compare(prefix,o.prefix); if(result == 0){ result = Short.compare(lineNum,o.lineNum); } } return result; } java 8부터는 Comparator 인터페이스가 일련의 비교자 생성 method를 통해 method chaining 방식으로 비교자를 생성할 수 있게 되었다. 약간의 성능저하가 있지만, 활용시 코드를 간결하게 작성할 수 있다. 123456789private static final Comparator&lt;PhoneNumber&gt; COMPARATOR = comparingInt((PhoneNumber pn)-&gt; pn.areaCode) .thenComparingInt(pn-&gt;pn.prefix) .thenComparingInt(pn-&gt;pn.lineNum);@Overridepublic int compareTo(PhoneNumber o) { return COMPARATOR.compare(this,o);} 정리순서를 고려하는 값 class 의 경우에는 comparable 인터페이스를 구현하여 Collection API를 돌렸을때 정상 작동하도록 해야 하고, compareTo method에서 필드값 비교할때는 부등호로 실수할 여지를 주지말고, boxing된 primitive type class가 제공하는 정적 compare method나 Compartor 인터페이스를 사용하자.","link":"/2021/12/16/2021-12-16-item14/"},{"title":"Item15. 클래스와 멤버의 접근 권한을 최소화하라","text":"잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리한다. 오직 API를 통해서만 다른 컴포넌트와 소통하며, 서로 구체적인 동작 방식은 개의치 않는다. 정보 은닉 (Information Hiding) 의 장점 시스템을 구성하는 컴포넌트를 서로 독립시켜서 개발/테스트/적용/수정 분석을 개별적으로 할 수 있게 해준다 여러 컴포넌트를 병렬로 개발 가능함으로, 개발 속도를 높임 각 컴포넌트를 빨리 파악 및 디버깅이 관리하고, 다른 컴포넌트로 교체하는 작업이 손쉽기 때문에 유지보수 비용이 덜 든다 직접적으로 성능을 높여주지는 않지만, 성능최적화에 도움을 준다. 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정하고, 해당 컴포넌트만 최적할 수 있기 때문이다. SW 재사용을 높임 시스템 개발 난이도를 낮춘다. 개별 컴포넌트단위로 나누어 개발하고 테스트할 수 있기 때문이다. 접근 제어 원리는 클래스,인터페이스,멤버의 접근성을 명시하고, 각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자 (private,protected,public) 으로 정해진다, 모든 클래스와 멤버의 접근성은 가능한 낮추어야 한다. ( public-&gt;private 방향)클래스와 인터페이스에 부여할 수 있는 접근 수준은 package-private(default) , public 2 가지이다. 클래스와 인터페이스를 public으로 선언하면 공개 API가 되며, default로 선언하면 해당 패키지 안에서만 사용할 수 있다. public으로 선언할 경우에는 외부에 노출되는 API가 되므로, 하위 호환을 위해서 계속 관리해주어야 한다. 다음과 같이 public,package-private 클래스 안에 private static 클래스로 내부 클래스를 선언하면, outer 클래스에서는 inner 클래스 접근이 가능하지만, 외부에서는 inner 클래스 접근이 불가능하다. 12345678910111213public class Outer { public void publicApi(){ Inner inner = Inner Sub(); inner.doSomething(); } private static class Inner{ public void doSomething(){} }} public 필요가 없는 클래스의 접근 수준을 package-private(default) 로 좁히자. public 클래스는 그 패키지의 API인 반면, package-prviate는 내부구현으로 분류되기 떄문이다. 접근 제한자의 종류와 접근 가능 범위 접근 지시자 클래스 내부 동일 패키지 하위 클래스 Global private v default (package-private) v v protected v v v public v v v v 클래스의 공개 API를 만들떄는 해당 클래스의 모든 멤버는 우선 private로 선언해두고, 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한 해 , default로 풀어주자 public class의 protcted 멤버는 공개 API에 속함으로, 계속 지원해주어야 하고, 내부 동작방식을 API문서에 적어 공개해야 할 수도 있다. 예외 상황: 부모 class의 method를 overriding하여 자식 class에서 접근 지시자를 좁힐수는 없다. (리스코프 치환 원칙을 지키기 위해 필요) Test 상황시에는 public 클래스의 private 멤버 변수를 default까지로 변경하는 것은 괜찮으나, 테스트를 위해 public API로 만들어서는 안된다. public class의 필드는 되도록 public이 아니여야 한다.(item16관련, Immutable 객체 관련 내용이다. ) immutable 객체란 객체가 한번 생성되고 나서 외부에서 상태를 변경시킬 수없는 객체를 말하는데, 필드가 public이면 당연히 값 변경이 자유롭기 떄문에, 불변객체가 아니고 또한 Thread-safe 하지 않다. 헤당 클래스와 관련된 상수인 경우는 public stiac final 필드로 공개하여도 괜찮다 1234public class Round{ public static final float PIE = 3.14f; //관례상 대문자, snake 표기법을 사용한다,} 이떄 주의할 사항은 public static final 필드에 배열을 두거나, 이 필드를 반환하는 접근자 method를 제공해서는 안된다는 점이다. 1public static final Thing[] VALUES = {...}; 위 코드는 client에서 배열 원소를 가져가 수정하면 원본 배열에도 변경사항이 적용된다는 보안 취약점이 있다. 해결방법은 두가지가 있는데, private 배열로 만들고, public 불변 리스트를 추가한다. 1234567public class Round { private static final Point[] PRIVATE_VALUE = {Point.pointOf(1,1), Point.pointOf(2,5)}; public static final List&lt;Point&gt; VALUE = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUE));} 1234567891011@Testvoid test(){ List&lt;Point&gt; value = Round.VALUE; // add 혹은 remove operaton 시 UnsupportedOperationException 를 던진다. assertThrows(UnsupportedOperationException.class,()-&gt;value.add(Point.pointOf(1000,1000))); assertThrows(UnsupportedOperationException.class,()-&gt;value.remove(0)); // 주의사항 : value.get(index값) // -&gt; 꺼내온 값을 변경하면 원본 원소도 바뀜} Collections.unmodifiableList API는 주어진 리스트에 대해서 add 혹은 remove 연산시 UnsupportedOperationException예외를 발생시킨다 private 배열을 만들고, 그 복사본을 반환하는 public method를 추가한다 (방어적 복사 라고 부름 ) 123456789public class Round { static final Point[] PRIVATE_VALUE = {Point.pointOf(1,1), Point.pointOf(2,5)}; public static final Point[] values(){ return PRIVATE_VALUE.clone(); }} java9 부터는 모듈 시스템 개념이 도입되면서 두가지 암묵적 접근 수준이 추가되었다. (모듈 : 패키지의 묶음 ) 정리program 요소의 접근성은 가능한 최소한으로 해서 필수적인 것만 public API로 공개하자. 해당 클래스의 개념과 관련된 상수들은 public static final 로 선언하고, 이떄 public static final 필드가 client에서 변경할 수 없는 불변임을 확인하라","link":"/2021/12/17/2021-12-17-item15/"},{"title":"Item16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라","text":"다음과 같이 캡슐화되지 않은 class는 필드를 외부에서 직접 접근이 바로 가능하니 작성하지 않는 것이 좋다. (모듈간 독립성이 떨어짐) 123456public class Point { public double x; public double y;} 외부에서 멤버필드 값을 조회,변경할떄는 getter , setter 방식을 사용한다. 123456789101112131415161718192021public class Point { private double x; private double y; public double getX() { return x; } public void setX(double x) { this.x = x; } public double getY() { return y; } public void setY(double y) { this.y = y; }} public class라면 클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성이 생긴다. 예를 들어 기존에 client가 필드를 직접 참조해서 사용하였을떄는 Point class의 내부 표현 방식을 바꾸기 어려울 것이다. 12Point point = new Point();doSomething(point.x); private, default class라면 데이터 필드가 노출된다하더라도 문제가 없다. 그 class가 표현하고자 하는 추상 개념만 올바르게 표현해주면 된다.default class 인 경우 client도 같은 패키지에 있겠지만, 어차피 client도 해당 패키지안에서만 동작하는 class임으로 패키지 바깥과는 독립적이다.따라서 패키지 바깥 쪽의 코드는 수정에는 닫혀있으면서 , 데이터 표현 방식의 변경에는 열려있다. private 중첩 class의 경우에는 수정 범위가 더 좁아져서 이 class를 포함하는 외부class까지로 제한된다. 정리public class는 가변 필드를 직접 노출해서는 안되고, 불변이라면 노출해도 덜 위험하지만 완전히 안전하지는 않다.default,private class에서는 필드를 노출하는 편이 나을떄도 있다.","link":"/2021/12/17/2021-12-17-item16/"},{"title":"Item18. 상속보다는 Composition을 사용해라","text":"상속의 단점 상속은 캡슐화를 꺠트린다. 상위 class 내부 구현 변경에 따라 하위 class가 영향을 받을 수도 있다. 상위 class가 확장을 충분히 고려해두고 설계되지 않으면 하위 class는 상위 class의 변화맞추어 수정되야 한다. hashSet에서 원소가 하나 추가될떄마다 count해주기 위해서 다음과 같이 HashSet을 상속받은 클래스가 있다고 가정하자. 1234567891011121314151617181920212223242526public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; { private int addCount = 0; public InstrumentedHashSet() { } public InstrumentedHashSet(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor); } @Override public boolean addAll(Collection&lt;? extends E&gt; c) { addCount += c.size(); return super.addAll(c); } @Override public boolean add(E e) { addCount++; return super.add(e); }} 위 class는 실제로 Test해보면 정상작동하지 않는다는 것을 알 수 있다. HashSet의 addAll이 내부적으로 add를 호출하기 떄문이다. addAll을 overriding안하면 해결되겠지만, 이는 HashSet의 내부구현방식이 변경되면 작동하지 않는다. 1234567891011class InstrumentedHashSetTest { @Test void test(){ InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;&gt;(); s.addAll(List.of(&quot;str1&quot;,&quot;str2&quot;,&quot;str3&quot;)); Assertions.assertThat(s.getAddCount()).isEqualTo(3); // fail }} 또한 상위 class에서 추가된 methoid가 하위 classs의 method와 동일한 시그니처,다른 반환타입을 가진다면 컴파일 에러가 날 것이다. Composition 기존 class를 확장하는 대신 , private 필드로 기존 class의 인스턴스를 참조하도록 하는 방식 기존 class가 새로운 class의 구성요소로 쓰인다는 점에서 Composition (구성) 이라고 부른다. Forwarding: 새로운 class의 method(forwarding method) 들이 기존 class 에 대응되는 method를 호출하여 결과를 반환하는 방식(새로운 class가 wrapper class로 작동하고 , 반환하는 과정에서 기능 추가가 가능하다) 123456789101112131415//Wrapper Classpublic class ForwardingSet&lt;E&gt; implements Set&lt;E&gt;{ // composition private final Set&lt;E&gt; s; public ForwardingSet(Set&lt;E&gt; s) { this.s = s; } // forwarding method public boolean addAll(Collection&lt;? extends E&gt; c) {return s.addAll(c); } public boolean add(E e) { return s.add(e); } Proxy 를 활용한 여러 디자인 패턴에서 활용된다. 대표적으로 Decorator 패턴이 존재한다. Decorator pattern 객체에 추가적인 요건을 동적으로 첨가한다.Decorator pattern은 서브 클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다. 123public interface Beverage { double getCost();} 123456789public class Coffee implements Beverage{ private final double cost = 2000; @Override public double getCost() { return cost; }} 123456789101112131415161718public class Whipping implements Beverage{ // Composition private final Beverage beverage; private final double cost = 500; public Whipping(Beverage beverage) { this.beverage = beverage; } // 기능 추가 @Override public double getCost() { // forwarding double cost = beverage.getCost(); return cost + this.cost; }} 1Beverage beverage = new Whipping(new Coffee()); Composition과 전달의 조합은 넓은 의미로는 위임(delegation)이라고 하는데, 정확히는 Wrapper 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 위임에 해당 된다. 구현체가 여러개 있을떄, 전달 method을 매 구현체마다 작성하는 대신 공통적인 전달 method 묶음을 인터페이스로 만들어두면 편리하게 구현할 수 있다. Composition의 단점 callback framework 와 같이 자기 자신의 참조를 다른 객체 넘겨서 다른 객체에서 호출하는 경우 문제가 생길수도 있다. (코드 예시 참조 : https://coderanch.com/t/670687/java/wrapper-class-suitable-callback-framework) 상속을 사용하는 상황클래스 A를 상속하는 클래스 B를 작성하려고 하면 , B is-a A 관계일떄만 클래스를 상속해야 한다. 정리상속은 상위 class가 변경됨에따라 하위class가 영향을 받으므로, 캡슐화를 해친다는 문제가 있다. 순수한 is-a관계일떄만 사용을 지향해야하고, 상속의 문제점을 피하려면 Composition과 전달을 사용하자","link":"/2021/12/18/2021-12-18-item18/"},{"title":"Item19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라","text":"상속용 클래스의 문서화 상속용 클래스는 overriding할 수 있는 method들을 내부적으로 어떻게 이용하는 지 문서로 남겨야 한다. 클래스의 API로 공개된 method에서 클래스 자신의 또 다른 method를 호출할 수도 있는데, 이 method가 overriding이 가능하다면 method의 API 설명에 적어두어야 한다. 어떤순서로 호출되는지, 호출 결과가 이어지는 처리에 어떤 영향을 줄 수 있는지도 문서화해야한다. 문서화 예시 : https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html API 문서의 method설명 끝에서 종종 ‘This Implementation’ ~ 로 시작하는 절을 볼 수 있는데 이 부분이 method의 내부 동작 방식을 설명하는 곳이다. 클래스를 안전하게 상속할 수 있도록 하려면, 내부 구현 방식에 대해 설명해주어야 한다. ( Java method 주석에 @implSpec tag를 붙여주면 자바독 도구가 생성해준다. ) 상속용 클래스의 제약 상속용 클래스의 생성자는 overriding 가능한 method를 호출해서는 안된다.(private,final,static method는 overriding이 불가능하니 생성자에서 호출하여도 무관하다. ) 12345678public class Super { public Super(){ overrideMe(); } public void overrideMe(){ }} Super라고 하는 상위 class에서 생성자에 overriding가능한 method를 호출한 상황을 가정하자 12345678910111213141516171819202122public final class Sub extends Super{ private final Instant instant; Sub(){ instant = Instant.now(); } public void overrideMe(){ System.out.println(&quot;instant = &quot; + instant); } public static void main(String[] args) { Sub sub = new Sub(); sub.overrideMe(); // 실행결과 // instant = null // instant = 2021-12-19T08:58:46.412929Z }} Super class를 상속한 자식 class에서 부모 생성자를 호출 -&gt; 부모 생성자에서 overrideMe() 호출 -&gt; 자식class의 instant 필드는 초기화 되기전임으로 null 출력이 된다. clone과 readObject 모두 overriding 가능한 method를 호출해서는 안된다. 예를 들어 , clone과 readObject는 객체를 새로 만드는 데 중간에 overriding 한 method를 호출한 경우, 제대로 복사되지 않은 객체가 만들어질수 있다. 1234567891011121314151617181920public class Parent implements Cloneable{ public Thing[] things; @Override protected Parent clone() { try{ Parent copyedParent = (Parent) super.clone(); // 부모 class에서 가변필드를 복사하기전에 overriding가능한 method 호출 overridedMethod(); copyedParent.things = things.clone(); return copyedParent; } catch(CloneNotSupportedException e){ throw new AssertionError(); } } protected void overridedMethod(){}} 123456public final class Child extends Parent { @Override protected void overridedMethod() { throw new RuntimeException(); }} 1234public static void main(String[] args) { Parent child = new Child(); child.clone(); // RuntimeException } 특히 clone이 잘못되면 복제본 뿐 아니라 원복객체에도 피해를 줄 수 있다, 가변필드는 복제본이랑 원본과 공유되고 있는 상태를 예시로 들 수 있을 것이다. Serializable 을 구현한 상속용 class가 readResolve 나 writeReplace method를 갖는다면 이 method들은 private 가 아닌 protected 로 선언해야 한다. readResolve : 역직렬화 과정에서 호출되는 method writeReplace : 직렬화된 상태에서 다시 객체로 만들떄 호출되는 method private 로 선언한다면 하위 class에서 무시되기 떄문이다. 일반적인 구체 클래스 상속용으로 만들지 않고, 문서화되지 않은 class는 개발할떄 필요에 의해서 상속해도 괜찮을까? 되도록이면 상속을 금지하고, 대신 핵심 기능들을 정의해놓은 인터페이스 구현을 하는 것을 권고하고 있다. 상속을 금지하는 방법은 이전 item에서도 다루었듯이 class를 final로 선언하거나 생성자를 하위class에서 호출할수 없도록 막는 방법이 있다. 꼭 상속을 해야 한다면, 상속할 class 내부에 overriding 가능한 method들을 호출하는 코드가 없도록 하고, 이를 문서화 해야한다. 12345678public void doSomething(){ doAnotherThing();}public void doAnotherThing(){ // overriding 가능한 method를 호출하고 있음으로, // 이를 private로 변경하고 문서화 해야한다. } overriding 가능한 자기 사용 코드를 완벽히 제거하면, method를 자식 class에서 overriding해도 다른 method와는 독립적으로 작동할수 있으므로, 안전하다. 정리상속용 class를 설계하려면 내부동작 방식과 다른 method들을 어떻게 호출하는지 (자기 사용 패턴) 을 모두 문서화해야 하며, 한번 문서화하면 변경하면 안된다. 때문에 상속을 사용해야할 명확할 이유가 없다면 상속을 금지하는 것을 권고한다.","link":"/2021/12/19/2021-12-19-item19/"},{"title":"Item17. 변경 가능성을 최소화하라","text":"불변 클래스란 객체 생성 후에 객체의 내부 값을 수정할 수 없는 클래스이다. 불변 객체에 간직된 정보는 고정되어 객체 소멸 시점까지 변경되면 안된다. 자바 String,primitive type boxing 클래스, BigInteger,BigDecimal 이 여기에 속한다. 불변 객체를 사용하는 이유는 다음과 같다. 가변 클래스보다 사용하기 쉬우며 , 안전하다.ex) 멀티쓰레드상황에서 여러 client가 동시에 객체를 사용하는 경우 (Thread-Safe) 불변 객체 만드는 규칙 객체의 상태를 변경하는 메소드 (ex) setter) 를 제공하지 않는다 class를 확장할 수 없도록 한다. 대표적으로 class를 final로 선언하면 된다. 모든 필드를 final로 선언한다.( 어떤 method도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다. ) 모든 필드를 private로 선언한다. 불변 필드인 경우에는 public final로 선언하여도 불변 객체는 되지만, API를 수정하기 힘들어진다. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. 클래스 내부에 가변 필드가 있다면, client에서 그 가변 필드의 참조값을 가지고 수정할수 있으므로 생성자/접근자/readObject method에서 모두 방어적 복사를 수행해야 한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class ImmutablePerson { private final Integer age; private final String name; private final List&lt;PhoneNumber&gt; phoneNumber; public Integer getAge() { return age; } public String getName() { return name; } public List&lt;PhoneNumber&gt; getPhoneNumber() { return List.copyOf(phoneNumber); } public static class Builder{ private Integer age; private String name; private List&lt;PhoneNumber&gt; phoneNumber; public Builder age(Integer age) { this.age = age; return this; } public Builder name(String name) { this.name = name; return this; } public Builder phoneNumber(List&lt;PhoneNumber&gt; phoneNumber) { this.phoneNumber = List.copyOf(phoneNumber); return this; } public ImmutablePerson build(){ return new ImmutablePerson(this); } } private ImmutablePerson(Builder builder){ this.age = builder.age; this.name = builder.name; this.phoneNumber = builder.phoneNumber; }} 책의 예시를 보면 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public final class Complex { private final double re; private final double im; public Complex(double re, double im){ this.re = re; this.im = im; } public double realPart(){ return re; } public double imaginaryPart(){ return im; } public Complex plus(Complex c){ return new Complex(re+c.re , im + c.im); } public Complex minus(Complex c){ return new Complex(re - c.re , im - c.im); } public Complex times(Complex c){ return new Complex(re*c.re - im * c.im, re * c.im - im * c.re); } public Complex dividedBy(Complex c){ double tmp = c.re * c.re + c.im * c.im; return new Complex( (re*c.re + im * c.im)/tmp, (im*c.re - re * c.im)/tmp ); } @Override public boolean equals(Object o){ if(o == this){ return true; } if(!(o instanceof Complex)){ return false; } Complex c = (Complex) o; return Double.compare(c.re,re)==0 &amp;&amp; Double.compare(c.im,im) == 0; } @Override public int hashCode(){ return 31*Double.hashCode(re) + Double.hashCode(im); } @Override public String toString(){ return &quot;(&quot; + re + &quot; + &quot; + im + &quot;i)&quot;; }} 위 method들은 불변객체를 수정하는게 아니라 새로운 객체를 만들어서 반환한다. 이처럼 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 함수형 프로그래밍이라고 한다. 이와 달리 절차형 프로그래밍은 피연산자인 자신을 수정해 자신의 상태가 변하게 된다. 불변 객체는 생성된 시점의 상태를 파괴될떄까지 그대로 간직함으로, 멀티 쓰레드 상황일때도 별도로 동기화 작업이 필요가 없으며, 객체는 한번 만든 인스턴스를 최대한 재활용하는 것이 좋다. 123public static final Complex ZERO = new Complex(0,0);public static final Complex ONE = new Complex(1,0);public static final Complex I = new Complex(0,1); 불변 객체는 자주 사용되는 인스턴스를 caching하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리 메소드를 제공할 수 있다. 1234567891011121314151617181920public final class ImmutablePerson { private final Integer age; private final String name; private final List&lt;PhoneNumber&gt; phoneNumber; private static ImmutablePerson cachedTeacher; public static ImmutablePerson getTeacher(){ if(cachedTeacher == null) { cachedTeacher = new Builder() .name(&quot;선생님&quot;) .age(30) .phoneNumber(List.of(new PhoneNumber(&quot;010&quot;,&quot;1234&quot;,&quot;5678&quot;))) .build(); } return cachedTeacher; } //...} 이렇게 정적 팩터리를 사용해서 자주쓰는 불변객체는 cache해놔서 객체를 계속 생성하는 것보다 메모리를 아낄수 있다. 불변 객체는 자유롭게 공유할 수 있고, client측에서 불변 객체의 상태 변경이 불가능함으로 당연히 복사해서 사용하는 것도 의미가 없다. 따라서 불필요하게 clone 이나 복사 생성자를 제공할 필요가 없다. 불변 객체는 자유롭게 공유할수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유 할 수 있다. BigInteger class는 내부에서 값의 부호와 크기를 따로 표현하는데 부호는 int 필드, 크기는 int[] 을 사용한다, BigInteger의 negate method 는 크기는 동일하고 부호만 반대인 새로운 BigInteger 객체를 생성하는데 이떄 두 불변객체는 가변 타입인 배열을 복사해서 사용하지 않고, 원본 객체와 공유해서 사용한다. 객체를 만들떄 다른 불변 객체들을 구성요소로 사용하면 이점이 많다. 값이 변경되지 않는 구성요소로 이루어진 객체는 불변식을 유지하기 쉽다. 예를 들어 Map,Set 의 경우에 key 또는 원소로 불변 객체를 사용할 경우 안에 담긴 값이 바뀌면 불변식이 허물어지는데 불변 객체를 사용하면 그런 걱정이 필요 없다. 불변 객체는 그 자체로 실패 원자성을 제공한다. 값이 변경 되지 않으므로, 잠깐이라도 불일치 상태에 빠질 가능성이 없다. 불변 객체의 단점 값이 다르면 반드시 독립된 객체로 만들어야 한다. 원하는 객체를 완성하기 까지의 중간 단계가 많고, 객체의 필드를 하나만 바꾸더라도 객체를 새로 생성해야 한다. (객체 생성 비용 ) 해결방안 다단계연산을 예측하여 기본기능으로 제공하는 방법 package-private 의 가변 동반 클래스 사용 ex) String의 String Builder 상속 제한 방법클래스가 불변임을 보장하려면 자신을 상속하지 못하게 해야 한다. final 클래스 선언 모든 생성자를 private 혹은 package-private로 만들고, 정적 팩토리 메소드 사용 2번 방식은 자식 클래스 생성자에서 부모 클래스 생성자 호출이 불가능함으로 당연히 상속이 불가능해진다.예시는 다음과 같다. 123456789// private로 외부 호출을막고, 정적팩토리로만 인스턴스를 생성하게 한다. private Complex(double re, double im){ this.re = re; this.im = im;}public static Complex valueOf(double re, double im){ return new Complex(re,im);} 추가로 BigInteger , BigDecimal의 경우는 final 이 아니고, 상속이 가능하다. 즉 보안상 BigInteger 인지 overriding하여 사용한 가짜 BigInteger인지 확인해야 한다. 1234public static BigInteger isSafeInstance(BigInteger val){ return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray()); } 정리class는 꼭 필요한 경우가 아니면 불변이여야 하며, 불변 클래스의 장점은 Thread-Safe하다는 점과, 복사를 할 필요도 없고, 프로그래밍시에 가변 클래스보다 안전하다는 장점을 가지고 있다. 반면 객체의 상태가 많고 특정 상태만 조금씩만 변경하고자 할떄는 객체 생성 비용 측면에서 단점을 가지고 있다. 만약 불변으로 만들 수 없는 상황이라면 변경할 수 있는 부분을 최소한으로 줄임으로서, 객체를 예측하고 디버깅하기 쉬워진다.","link":"/2021/12/17/2021-12-18-item17/"},{"title":"Item21. 인터페이스는 구현하는 쪽을 생각해 설계해라","text":"default methodjava 8 이후부터는 interface에 default method를 추가할 수 있게 되었다. default method 를 기존 인터페이스에 추가하였을떄 다음과 같은 사이드 이펙트가 발생할 수 있으니, 고려해서 추가하자는 내용이다. 기존 구현체와의 호환성 문제org.apache.commons.collections4.collection.SynchronizedCollection 은 client가 제공한 객체에 lock 을 걸어주는 능력을 제공한다. (race condition 해결) 모든 method에서 lock 객체로 동기화 한 후, 내부 collection 객체에 기능을 위임하는 wrapper class이다. 이 wrapper class를 사용해 removeIf를 호출한다면, overriding이 안된 (lock 기능이 없는) interface default method가 호출된다, 즉 정상작동하지 않는다. 현재는 overriding 되어 있으나, 어쩄거나 구현체에서 default method와 호환이 안될수도 있다는 것이 핵심이다. 또한 default method는 컴파일에 성공하더라도 런타임 오류를 발생시킬 수도 있다. 테스트를 통한 결함예방새로운 인터페이스라면 배포 이전에 반드시 테스트를 수행하고, 여러 방식으로 구현체를 구현해보고, 인터페이스가 의도한대로 작동되는지 확인해야 한다.","link":"/2021/12/22/2021-12-22-item21/"},{"title":"Item24. 멤버 class 는 되도록 static 으로 만들라","text":"중첩 class중첩 class (nested class) 란 다른 class 안에 정의된 class를 말한다. 중첩 class는 자신을 감싼 바깥 class에서만 쓰여야 한다. 중첩 class의 종류 정적 멤버 class 멤버 class 지역 class 익명 class 각 중첩 class의 용도 정적 멤버 class 정적 멤버 class는 흔히 바깥 class와 함께 쓰일떄만 유용한 public 도우미 class로 쓰인다. 예를 들어, Operation 열거 타입은 Calcuator class의 정적 member class가 되어, 부가적인 기능을 제공해줄 수 있을 것이다. 1234567891011121314public class Calculator { boolean isSupport(String operation){ String s = operation.toUpperCase(); return Arrays.stream(Operation.values()).filter((element) -&gt; element.toString().equals(s)) .findFirst() .isPresent(); } // static member class enum Operation{ PLUS,MINUS,DIVIDE; }} private 정적 멤버 class는 바깥 class가 표현하는 객체의 한 구성요소를 나타낼떄 사용한다. ex) Map 구현체의 Entry class 멤버 class ( = 비정적 멤버 class ) 멤버 class의 instance는 바깥 class의 인스턴스와 암묵적으로 연결된다. 따라서 중첩 class의 instance가 바깥 instance 와 독립적으로 존재가능하다면 static 으로, 그게 아니라면 그냥 멤버 class로 선언해야 한다. 멤버 class의 경우 바깥 instance로의 숨은 외부 참조를 갖기 때문에, 멤버 class가 GC되지 못하면 바깥 instance도 GC되지 못하는 메모리 누수가 생길 수도 있다. 때문에 Map의 Entry class도 static으로 선언되어 있다. 정규화된 this : 멤버 class의 instance는 바깥 class.this 형태로 바깥 class의 instance 참조값을 가져올 수 있다. 멤버 class instance와 바깥 class instance간에 관계는 멤버 class가 instance화될떄 확립되며, 더이상 변경될 수 없다. 이 관계는 보통 바깥 class의 method에서 멤버 class의 생성자를 호출할떄 자동으로 만들어진다. 12345678910111213141516171819202122public class Outer { Inner inner; public Outer() { this.inner = new Inner(); } void doSomething(){ System.out.println(&quot; outer class&quot; ); } class Inner { void doSomething(){ System.out.println(&quot;inner class&quot;); // 정규화된 this Outer.this.doSomething(); // outer class } }} 1Outer.Inner inner = new Outer().new Inner(); // 드물게는 다음과 같이 수동으로 생성시키기도 한다. 이 관계 정보는 멤버 class의 instance 안에 만들어져 , 메모리 공간을 차지하며, 생성시간도 더 걸린다. 멤버 class의 주 용도는 어댑터 에 사용된다고 한다. (Q: 어댑터를 만들떄 내부 멤버 class 를 사용하는 지) 즉 어떤 class의 instance를 감싸 마치 다른 class의 instance처럼 보이게 하는 view로 사용하는 것이다. 1234567891011public class MySet&lt;E&gt; extends AbstractSet { //... @Override public Iterator iterator() { return new MyIterator(); } private class MyIterator implements Iterator&lt;E&gt;{ //... }} 익명 class 쓰이는 시점에 선언과 동시에 인스턴스가 만들어지며, 코드의 어디서든 만들 수 있다.비정적인 문맥에서 사용될떄만 바깥 class의 instance를 참조할 수 있고, 정적 문맥에서라도 상수 변수 이외의 정적 멤버는 가질 수 없다. 12345678910111213141516171819202122public class Outer { Integer outerIntNum = 10; static final int staticOuterIntNum = 10; Inner createInnerClass(){ return new Inner() { // 비정적 문맥에서는 바깥 instance 참조가 가능하다. final int innerIntNum = outerIntNum; // 정적 문맥에서는 상수 변수와 같은 정적 멤버만 가질 수 있다. static final int staticInnerNum = staticOuterIntNum; @Override public void doSomething() { } }; }} 익명 class는 제약이 많다. 선언한 지점에서만 instance 만들수 있음 instanceof 검사나, 클래스 이름이 필요한 작업은 수행 불가 여러 인터페이스 구현 불가, 다른 class 상속 불가 익명 class를 사용한 client는 그 익명 class가 상위 타입에서 상속한 멤버외에는 호출 불가 현재는 람다가 익명 class를 대체해 주로 사용되고 있으나, 정적 팩토리 method 구현시에 익명 class가 활용 될 수 있다. 1234567891011121314151617181920212223static List&lt;Integer&gt; intArrayAsList(int[] a){ Objects.requireNonNull(a); return new AbstractList&lt;Integer&gt;() { @Override public Integer get(int index) { return a[index]; } @Override public Integer set(int index, Integer val){ int oldVal = index; a[index] =val; return oldVal; } @Override public int size() { return a.length; } };} 지역 class 지역 변수를 선언하는 곳이면 선언 가능하며, 유효 변수도 지역변수와 동일하다, 멤버 class 처럼 이름이 있고, 반복적으로 사용가능하다.익명 class 처럼 비정적 문맥에서 사용될떄만 바깥 instance를 참조할 수 있으며, 정적 멤버는 가질 수 없으며 가독성을 위해 짧게 작성되야 한다. 정리바깥 인스턴스를 참조하면 비정적 내부 class. 그렇지 않는다면 정적 내부 class로 만들고,한 method 안에서만 쓰이면서 , 그 인스턴스를 생성하는 시점이 단 한곳이라면 지역 내부 class 또는 익명 내부 class를 사용한다.이미 적합한 class나 인터페이스가 있다면 익명 내부 class로 사용하고 그렇지 않다면 지역 내부 class를 사용하면 된다.","link":"/2021/12/25/2021-12-25-item24/"},{"title":"Item20. 추상 클래스보다는 인터페이스를 우선하라","text":"추상 class추상 class와 인터페이스의 가장 큰 차이점은 추상 class가 정의한 type을 구현하는 class는 반드시 추상 class의 하위 타입이 되야한다는 점이다. java는 단일 상속만 지원함으로, 추상 class 방식은 새로운 타입을 정의하는데 제약을 갖게 된다. 반면 인터페이스의 경우는 어떤 class를 상속했더라도 같은 type으로 취급된다 기존 class에 새로운 인터페이스를 구현해넣는것은 쉬우나, 새로운 추상 class를 넣기는 힘들다.두 class가 동일한 추상 class 를 확장하려면 그 추상 class는 계층구조상 두 class의 공통조상이여야 한다. 인터페이스의 장점1. mixin정의에 알맞다.mixin : class가 구현할 수 있는 타입으로, mixin을 구현한 class에 원래의 주된 타입 외에 특정 선택적 행위를 제공한다고 선언하는 효과를 준다. 대상 타입의 주된 기능에 선택적 기능을 혼합 (mixin) 한다고 해서 mixin 이라고 부른다. 추상 클래스로는 이중 상속이 불가능하므로, mixin 정의가 불가능하다. 예 : Comparable 은 자신을 구현한 클래스의 인스턴스들끼리 순서를 정할 수 있다고 선언하는 mixin 인터페이스이다. 2. 계층구조가 없는 타입 프레임워크를 만들 수 있다.현실세계에 있는 계층구조로 표현하기 힘든 개념도 표현이 가능하다. 12345678910111213public interface Singer { AudioClip sing(Song s);}public interface SongWriter { Song compose(int chartPosition);}public interface SingerSongwriter extends Singer,SongWriter{ AudioClip strum(); void actSensitive();} 인터페이스로는 다중 확장이 가능하기 때문이다. 이를 class구조로 만드려면 가능한 조합 전부를 class로 표현한 무거운 계층구조가 만들어질 것이다. 3. 인터페이스 + 추상 골격 구현 class인터페이스와 추상 골격 구현(skeletal implementation) class를 함께 제공하여 인터페이스와 추상 class의 장점을 모두 취하는 방법도 있다. 관례상 인터페이스의 이름이 Interface라면, 그 골격 구현 class의 이름은 AbstractInterface로 짓는다.123456789101112131415161718192021package java.util;/** * This class provides a skeletal implementation of the {@code Collection} * interface, to minimize the effort required to implement this interface. &lt;p&gt; * * To implement an unmodifiable collection, the programmer needs only to * extend this class and provide implementations for the {@code iterator} and * {@code size} methods. (The iterator returned by the {@code iterator} * method must implement {@code hasNext} and {@code next}.)&lt;p&gt; * * ....중략 * * @author Josh Bloch * @author Neal Gafter * @see Collection * @since 1.2 */public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; { java Collection 인터페이스의 추상 골격 클래스인 abstractCollection의 설명은 다음과 같이 적혀있다. To implement an unmodifiable collection, the programmer needs only to extend this class and provide implementations for the {@code iterator} and {@code size} methods. 이 API를 활용하는 개발자는 abstractCollection을 상속받아서, iterator, size에 관한 로직만 작성해주면 골격 구현 클래스가 나머지 method는 이미 구현을 해놓았기에, 구현을 할필요가 없다. 이를 template method pattern 이라고 한다. 추상 골격 클래스 + 인터페이스 조합을 사용하면 손쉬운 확장이 가능하다. 1234567891011121314151617181920212223static List&lt;Integer&gt; intArrayAsList(int[] a){ Objects.requireNonNull(a); return new AbstractList&lt;Integer&gt;() { @Override public Integer get(int index) { return a[index]; } @Override public Integer set(int index, Integer val){ int oldVal = index; a[index] =val; return oldVal; } @Override public int size() { return a.length; } };} 위 예제에서는 익명 클래스를 사용해, 추상 골격 클래스를 구현하였다. 또한 추상 골격 구현 클래스를 우회적으로 이용 가능하다 , 인터페이스를 구현한 class에서 해당 골격 구현을 확장한 private 내부 class를 정의하고, 각 method 호출을 내부 class의 instance에 전달하는 것이다. (simulated multiple inheritance) 추상 골격 class 의 장점을 정리하면 다음과 같다. 구체 class의 구현을 도와준다.(공통로직은 부모에 작성가능하다) 인터페이스를 통해 타입을 가질 수 있다. 추상 골격 class 의 작성을 정리하면 다음과 같다. 다른 method들의 구현에 사용되는 기반 method 를 선택해, 추상 method로 만든다. 추상 method를 통해 다른 method들을 직접 구현 가능한 method를 모두 default method로 제공한다. (*equals와 hashCode는 default method로 제공하면 안되며, default method , abstract method로 만들지 못한 method가 있다면 해당 interface를 구현하는 다른 추상 골격 class를 만들어 작성한다. ) 정리다중 구현시 인터페이스를 활용하는 경우가 상속을 여러번 받는경우보다 유리하며, 복잡한 인터페이스의 경우 구현체의 공통로직을 작성해주는 추상 골격 class를 이용하면 구현체 작성이 쉽고, 공통로직을 부모로 분리해줄 수 있다.","link":"/2021/12/21/2021-12-21-item20/"},{"title":"Item23. 태그 달린 class보다는 class 계층 구조를 활용하자","text":"태그 달린 class헌재 표현하는 의미를 태그 값으로 알려주는 class 는 아래와 같이 class 계층구조를 사용하지 않고, 한 class내에 태그 필드를 가지는 class를 말한다. 12345678910111213141516171819202122232425262728293031323334353637public class Figure { enum Shape {RECTANGLE,CIRCLE}; // 현재 모양 final Shape shape; // RECTANGLE일떄만 쓰이는 필드 double length; double width; // CIRCLE일떄만 쓰이는 필드 double radius; // CIRCLE용 생성자 public Figure(double radius) { this.shape = Shape.CIRCLE; this.radius = radius; } // RECTANGLE용 생성자 public Figure(double length, double width) { this.shape = Shape.RECTANGLE; this.length = length; this.width = width; } double area(){ switch (shape){ case RECTANGLE: return length * width; case CIRCLE: return Math.PI * (radius * radius); default: throw new AssertionError(shape); } }} 태그 달린 class의 단점 태그 필드를 가지고, 분기처리 (swith,if-else)를 하기 때문에 코드 가독성이 떨어지고, 계층형 구조로 가져갔을때 불필요한 코드들이 생긴다. 태그 값마다 필요한 필드가 다른데, 이를 모두 하나의 class에 보관함으로, 객체를 생성하였을떄 사용되지 않는 필드 (메모리 낭비) 도 같이 초기화 된다. 변경에 열려있다, 태그 값 추가시마다 분기로직을 수정해야 한다. 인스턴스 타입을 보고 현재 타입이 나타내는 의미를 알 수가 없다. 클래스 계층 구조로 변경 태그 달린 class는 위와 같은 단점들을 가지고 있기 떄문에, 클래스 계층 구조로 변경하는게 더 바람직하다. 변경 방법을 정리하면 다음과 같다. 계층 구조의 부모가 될 추상 class를 정의 태그 값에 따라 동작이 달라지는 method를 자식이 구현하도록 abstract method로 선언 태그 값에 따라 동작이 달라지지 않는 method는 default method로 선언 구현체는 태그값(의미)별로 하나씩 정의 예제 코드를 보면 Figure class를 다음과 같은 클래스 계층구조로 변경하였다. 123456public abstract class Figure { // 구현체마다 동작이 다른 추상 method abstract double area();} 태그값 (의미) 별로 구현체로 분리하였으며, 구현체마다 다른 로직은 추상 method로 뽑았다. 1234567891011121314151617181920212223242526272829public class Circle extends Figure { final double radius; public Circle(double radius) { this.radius = radius; } @Override double area() { return Math.PI * ( radius * radius ); }}public class Rectangle extends Figure{ final double length; final double width; public Rectangle(double length, double width) { this.length = length; this.width = width; } @Override double area() { return length * width ; }} 계층구조로 변경하면서 생긴 장점은 다음과 같다. 불필요한 분기로직 제거 타입만 보아도 해당 class가 무슨 기능을 하는지 짐작 할 수 있다. (가독성) 불필요한 필드 제거 , 해당 클래스에서 필요한 필드만 가지고 있다. 확장성 증가 예를 들어 직사각형 class를 상속받는 정사각형 class는 다음과 같이 간단히 표현될 수 있다. 123456public class Square extends Rectangle{ public Square(double side) { super(side, side); }} 정리태그 달린 class는 계층구조로 리팩토링 하자, 구현체간에 공통된 로직은 default method로 , 구현체마다 다른 로직은 abstract method로 선언하면 변경이 가능하다.","link":"/2021/12/25/2021-12-25-item23/"},{"title":"Item22. 인터페이스는 타입을 정의하는 용도로만 사용하라","text":"인터페이스의 사용 용도인터페이스는 자신을 구현한 class의 instance를 참조할 수 있는 타입 역할을 한다. 즉 class가 어떤 인터페이스를 구현한다는 것은 자신의 인터페이스로 무엇을 할수 있을 지 client에게 얘기해주는 것이며, 인터페이스는 오직 이 용도로만 사용해야 한다. 12345678910public interface Flyable { void fly();}public class Bird implements Flyable{ @Override public void fly() { System.out.println(&quot; fly &quot; ); }} 12Flyable bird = new Bird();bird.fly(); 잘못된 인터페이스 사용예시이와 반대되는 안티 패턴으로 상수 인터페이스 라는 것이 있다. 상수 인터페이스는 method없이 오직 static final field 로만 채운 인터페이스를 말한다. 123456789public class PhysicalConstants { static final double AVOGADROS_NUMBER = 6.022_140_857e23; static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23; static final double ELECTRON_MASS = 9.109_383_56e-31;} 상수 인터페이스는 이를 구현하는 class 내부 구현을 클래스의 API로 노출하는 행위이다. client의 관심사와는 전혀 관련이 없지만 클래스의 API로 노출되어 client에게 혼란만 주기 떄문에 사용해서는 안되는 안티 패턴이다. 상수 인터페이스 대안 특정 class와 연관된 상수라면 그 class에 자체적으로 추가한다. ex) Integer의 MAX_VALUE 12345public class Round { public static final float PIE =3.14f;} 열거 타입으로 나타내기 적합한 경우 열거 타입으로 만들어 공개한다. 인스턴스화 할 수 없는 유틸리티 클래스에 담아 공개한다. 12345678910111213public class PhysicalConstants { private PhysicalConstants(){} static final double AVOGADROS_NUMBER = 6.022_140_857e23; static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23; static final double ELECTRON_MASS = 9.109_383_56e-31;}","link":"/2021/12/22/2021-12-22-item22/"},{"title":"Item25. top level class는 한 파일에 하나만 담으라","text":"소스 파일 하나당 top-level class를 여러개 선언해도 compile error는 나지 않는다, 123456789// Utensil.java class Utensil { static final String NAME = &quot;pan&quot;;}class Dessert{ static final String NAME = &quot;cake&quot;;} 12345678class Dessert { static final String NAME = &quot;pie&quot;;}class Utensil { static final String NAME = &quot;pot&quot;;} 위와 같이 하나의 java file에 여러개의 class가 들어있는 경우 문제가 생길수도 있다. 12345public class Main{ public static void main(String[] args) { System.out.println(&quot;Utensil.NAME + Dessert.NAME = &quot; + Utensil.NAME + Dessert.NAME); }} 위 예제는 compile 순서에 따라 다른 결과를 출력한다. 해결 방법은 top-level class들을 서로 다른 소스 파일로 분리하면 된다.굳이 여러개의 class를 하나의 소스 파일로 묶고자 하면 중첩 클래스 중 정적 멤버 class를 만드는 방법이 더 괜찮다. 1234567891011public class Outer{ // 정적 멤버 class 사용 public static class Utensil { static final String NAME = &quot;pan&quot;; } public static class Dessert{ static final String NAME = &quot;cake&quot;; }} 정리하면 compile 순서에 따라 출력결과가 달라지지 않으려면 하나의 java file에 하나의 top-level class만을 두자는 것이다.","link":"/2021/12/26/2021-12-26-item25/"},{"title":"State pattern","text":"State Pattern (상태패턴) 객체의 다양한 상태를 객체화합니다. 객체 내부의 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있습니다 마치 객체의 class가 바뀌는 것과 같은 결과를 얻을 수 있습니다. State Pattern 의 class diagram 먼저 객체의 여러 상태들에 대한 공통 인터페이스를 정의한다. 여기서는 State interface가 그 역할을 한다. Context는 객체의 상태(State 객체)를 바꾸어가면서 다른 행동을 할 수 있는 클래스로, 여러개의 객체 상태를 가질 수 있다. request() method가 호출되면 그 작업은 상태 객체에게 위임(delegation)된다. State 인터페이스를 구현한 실제 객체의 상태를 나타내는 Concrete State는 Context로 부터 요청된 작업을 수행한다 (handle() method ) State Pattern 사용 예시 예제 아래와 같이 사탕 기계에서 동전을 넣고, 사탕을 받는다고 하였을떄, 해당 flow가 가질수 있는 상태머신은 다음과 같을 것이다. 이를 상태 패턴으로 객체 지향적으로 개발이 가능하다. 객체의 상태를 공통적으로 Interface로 도출한다. 12345678910111213public interface State { // 동전 투입시 할일 void insertQuarter(); // 동전 반환시 할일 void ejectQuarter(); // 사탕기계 손잡이를 돌렸을떄 할일 void turnCrank(); // 사탕 반환시 할일 void dispense();} 객체의 실제 상태마다 구현체를 만든다. 1234567891011121314151617181920212223242526272829303132// 동전을 가지고 있는 상태public class HasCoinState implements State{ CandyMachine machine; public HasCoinState(CandyMachine machine) { this.machine = machine; } @Override public void insertQuarter() { System.out.println(&quot; 동전은 한개만 넣어주세요. &quot; ); } @Override public void ejectQuarter() { System.out.println(&quot; 동전이 반환됩니다. &quot; ); machine.setState(machine.getNoCoinState()); } @Override public void turnCrank() { System.out.println(&quot; 손잡이를 돌리셨습니다. &quot; ); machine.setState(machine.getSoldState()); } @Override public void dispense() { System.out.println(&quot; 사탕이 나갈 수 없습니다. &quot;); }} 1234567891011121314151617181920212223242526272829303132333435// 동전을 가지고 있지 않는 상태 public class NoCoinState implements State{ CandyMachine machine; public NoCoinState(CandyMachine machine) { this.machine = machine; } @Override public void insertQuarter() { System.out.println(&quot; 동전을 넣으셨습니다. &quot; ); machine.setState(machine.getHasCoinState()); } @Override public void ejectQuarter() { requireCoin(); } @Override public void turnCrank() { requireCoin(); } @Override public void dispense() { requireCoin(); } private void requireCoin() { System.out.println(&quot;동전을 넣어주세요&quot;); }} 12345678910111213141516171819202122232425262728293031323334// 사탕이 매진된 상태 public class SoldOutState implements State{ CandyMachine machine; public SoldOutState(CandyMachine machine) { this.machine = machine; } @Override public void insertQuarter() { noCandy(); } @Override public void ejectQuarter() { noCandy(); } @Override public void turnCrank() { noCandy(); } @Override public void dispense() { noCandy(); } private void noCandy() { System.out.println(&quot; 죄송합니다, 매진되었습니다. &quot;); }} 12345678910111213141516171819202122232425262728293031323334// 사탕 판매 상태 public class SoldState implements State{ CandyMachine machine; public SoldState(CandyMachine machine) { this.machine = machine; } @Override public void insertQuarter() { System.out.println(&quot; 잠깐만 기다려주세요, 알맹이가 나가고 있습니다. &quot;); } @Override public void ejectQuarter() { System.out.println(&quot; 이미 알맹이를 뽑으셨습니다. &quot; ); } @Override public void turnCrank() { System.out.println(&quot; 손잡이는 한번만 돌려주세요&quot; ); } @Override public void dispense() { machine.releaseBall(); if(machine.getCount() &gt; 0){ machine.setState(machine.getNoCoinState()); }else{ System.out.println(&quot; 사탕이 매진 되었습니다. &quot; ); machine.setState(machine.getSoldOutState()); } }} State라고 하는 공통적인 인터페이스를 두고, 구현체가 수행해야될 행동을 명시해둔뒤, 실제 객체의 상태는 이를 각기 다르게 구현하였다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Getterpublic class CandyMachine { // Composition , 각 객체의 상태를 가진다. private State soldOutState; private State noCoinState; private State hasCoinState; private State soldState; private State state = soldOutState; int count = 0; public CandyMachine(int numberOfBall ) { this.count = numberOfBall; soldOutState = new SoldState(this); noCoinState = new NoCoinState(this); hasCoinState = new HasCoinState(this); soldState = new SoldState(this); if(numberOfBall &gt; 0 ){ state = noCoinState; } } public void insertQuarter(){ state.insertQuarter(); } public void ejectQuarter(){ state.ejectQuarter(); } public void turnCrank(){ state.turnCrank(); state.dispense(); } // void setState(State state){ this.state = state; } void releaseBall(){ System.out.println(&quot; 사탕 나옴 &quot; ); if(count != 0 ){ count -=1; } }} Context 역할을 하는 , 즉 객체의 상태가 바뀜에 따라 다른 역할을 하는 객체이다. 여기서는 Context 객체가 처음 생성될떄 state 구현체들을 주입받음으로서, context 객체가 한번만 생성된다고 하면 나머지 state 구현체들은 싱글톤으로 유지되도록 하였다. 어쩄거나, State 인터페이스를 필드로 가지고,State 구현체에게 필요한 작업들을 요청(forwarding)한다.state 구현체들은 필요에 따라 Context의 setState() method를 호출해 Context의 상태를 변경한다. state pattern 의 장점 각 상태의 행동을 별개의 class로 도출하여 한 class가 하나의 책임을 가지도록 하였다. (SRP) 하나의 class로 상태머신을 구현하였을때 나올수 있는 if-else 와 같은 분기로직 제거 각 상태를 변경에 대해서는 닫혀있도록 하면서 , 새로운 상태는 쉽게 추가가 가능하다 (OCP) strategy pattern과의 유사점과 차이점사실 state pattern과 strategy pattern은 class diagram이 동일하나 그 의도가 다르다. state patterrn을 사용할떄에는 state 객체의 행동이 캡슐화된다.상황에 따라 Context 객체에서 여러 상태 객체 중 한 객체에게 모든 행동을 맡긴다. 맡겨진 객체에서 수행하는 행동에 따라 Context 객체의 state 필드가 변경되고, 행동도 바뀐다. 하지만 strategy pattern을 사용할떄는 일반적으로 client에서 context 객체에게 어떤 전략 객체를 사용할지를 지정해주는 방식이다. 12345if(someCondition()){ context.execute(new InternalValidator(...));}else{ context.execute(new EmrValidator(...));} strategy pattern은 주로 실행시에 전략 객체를 변경할수 있는 유연함을 제공하기 위해 사용된다. 정리상태 패턴은 객체의 다양한 상태에 따라 Context 객체의 행동을 바꿀수 있는 패턴으로, 객체의 상태를 공통 인터페이스를 두고 구현함으로서 가능하게 한다.","link":"/2021/12/26/2021-12-26-state-pattern/"},{"title":"JPA composite key mapping 방식 - @EmbeddedId,@IdClass","text":"복합키 매핑 방법JPA는 복합키 매핑을 다음과 같은 2가지 annotation으로 지원해준다. 1.@IdClass2.@Embeddable 복합키를 매핑하는 class의 전제조건 composite primary key class 는 public 이여야만 한다. no-arg constructor 가 존재해야만 한다. equals,hashCode method를 overriding해야만 한다. Serilizable interface 를 구현해야 한다. @IdClass@IdClass 방식은 class의 필드를 entity에도 중복 보관한다. 12345678910111213141516171819@Entity@NoArgsConstructor(access = AccessLevel.PROTECTED)@AllArgsConstructor@Builder@IdClass(UserId.class)public class User { @Id private String userId; @Id private String password; private LocalDateTime createdAt; private LocalDateTime updatedAt; private LocalDateTime deletedAt;} @AllArgsConstructor annotation이 entity에 추가된 이유는 lombok 빌더 떄문이다.(@Builder)빌더 패턴은 모든 멤버변수를 생성자로 받을 수 있어야 한다, 자세한 내용은 이펙티브 자바 , builder pattern 내부 구현을 보면 알수 있는데 간략하게 정리하면 아래와 같이 빌더내 멤버변수를 생성하고자 하는 객체에 넘겨줄떄 생성자가 필요하기 떄문이다. 또는 빌더 자체를 넘겨주어서 빌더로부터 필드를 가져오는 방식도 존재한다. 1234// lombok builder 구현방식public build(){ new User(builder.userId , builder.password ... );} 1234567891011121314151617181920212223User{ //builder 자체를 넘겨주는 방식 User(Builder builder){ this.userId = builder.getUserId; } public static class Builder{ private String userId; public Builder userId(){ this.userId = userId; return this; } //... public build(){ new User(builder); } }} UserId를 보면 복합키에 사용될 필드를 보관하고 있고, serializable interface를 구현하고 equals &amp; hascode를 overriding했다. 1234567891011@EqualsAndHashCode@AllArgsConstructor@NoArgsConstructor@Getterpublic class UserId implements Serializable { private String userId; private String password;} repository 에서는 복합키 클래스를 Id Class로 명시해주면 된다. 12@Repositorypublic interface UserRepository extends JpaRepository&lt;User, UserId&gt; {} 이를 테스트해보면 정상작동여부를 확인할 수 있다. 12345678910111213141516171819@Test @DisplayName(&quot;@IdClass 정상작동여부 확인&quot;) public void user(){ //given UserId userId = new UserId(&quot;tester&quot;,&quot;1234&quot;); User user = new User.UserBuilder() .userId(userId.getUserId()) .password(userId.getPassword()) .createdAt(LocalDateTime.now()) .build(); User savedUser = userRepository.save(user); //when Optional&lt;User&gt; foundUser = userRepository.findById(userId); //then Assertions.assertThat(foundUser.isPresent()); Assertions.assertThat(foundUser.get() ).isEqualTo(savedUser); } @EmbeddedClass@EmbeddedClass 방식은 필드를 복합키 클래스에서만 보관하고, entity에는 복합키 클래스만을 보관한다. 12345678910111213141516171819202122@EqualsAndHashCode@AllArgsConstructor@NoArgsConstructor@Getter@Embeddable //추가 public class UserId implements Serializable { private String userId; private String password;}@Entity@NoArgsConstructor(access = AccessLevel.PROTECTED)@AllArgsConstructor@Builderpublic class User { @EmbeddedId //추가 private UserId userId;} 이를 테스트해보면 마찬가지로 정상작동여부를 확인할수 있다. 123456789101112131415161718@Test@DisplayName(&quot;@EmbeddedId 정상작동여부 확인&quot;)public void user(){ //given UserId userId = new UserId(&quot;tester&quot;,&quot;1234&quot;); User user = new User.UserBuilder() .userId(userId) .createdAt(LocalDateTime.now()) .build(); User savedUser = userRepository.save(user); //when Optional&lt;User&gt; foundUser = userRepository.findById(userId); //then Assertions.assertThat(foundUser.isPresent()); Assertions.assertThat(foundUser.get() ).isEqualTo(savedUser);} @IdClass와 @EmbeddedClass간의 차이점@EmbeddedClass에서는 entity class에 복합키 클래스만 명시해주는 반면, @IdClass는 복합키 클래스의 필드를 중복으로 다시 명시해주어야 한다jpql query가 나갈떄 차이점도 존재한다.@IdClass 1SELECT user.userId,user.password from User user 이와달리 @EmbeddedClass에서는 추가적인 alias가 사용되어 jpql query가 나간다. 1SELECT user.userId.id , user.userId.password from User user","link":"/2021/12/27/2021-12-27-JPA-composite-key-mapping/"},{"title":"Item26. Generic Raw Type은 사용을 자제하라","text":"Generic Type클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 쓰이면 이를 generic class 또는 generic interface라 한다. 이 두 개를 통칭해서 Generic type이라고 부른다. 1public class GenericExample&lt;T&gt;{} // T : 타입 매개변수 각각의 generic type은 매개변수화 타입 (parameterized type)을 정의한다. 매개변수화타입은 &lt;&gt; 괄호 안에 실제 타입을 명시함으로서 정의가 가능하다. 1GenericExample&lt;String&gt; stringGenericExample = new GenericExample&lt;&gt;(); raw tye은 generic type을 하나 정의하면 함께 정의되는데, generic type에서 타입 매개변수를 전혀 사용하지 않았을떄를 말한다. , raw type이 generic type을 하나 정의할떄마다 같이 생성되는 이유는 기존 java code와 호환성 문제떄문이다. 1GenericExample rawTypeGeneric = new GenericExample(); Raw Type 단점 compile error로 금방 해결될 수 있는 문제를 runtime error로 발생시킬 수도 있다. 타입 안정성을 제공하지 않는다 아래와 같이 Collection 을 타입 매개변수를 정의하지 않은 raw type 으로 사용하는 예제를 보면 collection에 어떤 타입이 들어가도 에러를 발생시키지 않는다. 1234567private final Collection stamps = new ArrayList();public void doSomething(){ stamps.add(new Stamp()); stamps.add(new Coin()); stamps.stream().forEach((item)-&gt;((Stamp)item).cancel());} 타입 매개변수를 정의한 경우에는 compile time에 error를 잡아내고, 형변환까지 수행된다. 1234567private final Collection&lt;Stamp&gt; stamps = new ArrayList();public void doSomething(){ stamps.add(new Stamp()); // stamps.add(new Coin()); compile Error stamps.stream().forEach((item)-&gt;item.cancel()); // 형변환코드 불필요 } raw type 과 &lt;Object&gt; 차이점List&lt;Object&gt;는 모든 타입을 허용하겠다는 의사를 compiler에게 명확히 전달한 것으로 매개변수로 List 를 받는 method에 List&lt;String&gt; 을 넘길수는 있지만 , 매개변수로 List&lt;Object&gt;를 받는 method에 List&lt;String&gt;을 넘길 수는 없다. 이유는 Generic의 하위 타입 규칙때문이다. List raw type은 List,List를 하위타입으로 가지지만,List&lt;Object&gt;는 List&lt;String&gt;을 하위타입으로 가지지 않기 떄문이다. 12345678910// raw type을 매개변수로 받는 methodprivate static void unsafeAdd(List list , Object o ){ list.add(o);}public static void main(String[] args) { List&lt;String&gt; strings= new ArrayList&lt;&gt;(); unsafeAdd(strings,Integer.valueOf(42)); String s = strings.get(0); // ClassCastException} 위 예제와 같이 List&lt;String&gt;은 List의 하위타입이기 때문에 아무런 compile error가 나지 않는다.문제는 값을꺼낼때 generic이 string type임으로 String으로 자동 형변환됨으로 문제가 생긴다 123456789// Object type을 매개변수로 받는 methodprivate static void unsafeAdd(List&lt;Object&gt; list , Object o ){ list.add(o);}public static void main(String[] args) { List&lt;String&gt; strings= new ArrayList&lt;&gt;(); unsafeAdd(strings,Integer.valueOf(42)); //compile error} List&lt;Object&gt;를 매개변수로 선언하면 다른 매개변수 타입은 들어갈수없으므로, compile error가 발생한다 (빠르게 디버깅이 가능하다 ) unbounded wildcard typeunbounded wildcard type은 어떤 타입 매개변수도 허용하고자할떄 사용한다. unbounded wildcard type collection에는 null을 제외한 어떠한 원소도 삼입이 불가능하다. java 공식 문서에 보면 unbounded wildcard type 을 사용하는 상황은 다음과 같다. 아래와 같이 list 원소를 loop를 돌려 출력하고자할떄, List&lt;Object&gt; 는 다른 generic type을 받을 수 없다. 12345public static void printList(List&lt;Object&gt; list) { for (Object elem : list) System.out.println(elem + &quot; &quot;); System.out.println();} 반면 wildcard type으로 변환하면 다른 generic type도 매개변수로 받을 수 있다. 1234567891011public static void printList(List&lt;?&gt; list) { for (Object elem: list) System.out.print(elem + &quot; &quot;); System.out.println();}public static void main(String[] args){ List&lt;Integer&gt; li = Arrays.asList(1, 2, 3); List&lt;String&gt; ls = Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;); printList(li); printList(ls);} 또한 다음과 같이 차이점에 대해서도 기술하고 있다. It’s important to note that List&lt;Object&gt; and List&lt;?&gt; are not the same. You can insert an Object, or any subtype of Object, into a List&lt;Object&gt;. But you can only insert null into a List&lt;?&gt;. (ref - https://docs.oracle.com/javase/tutorial/java/generics/unboundedWildcards.html) raw type은 아무 원소나 collection에 삼입할수있으므로, 타입 불변식을 훼손하기 쉽다. 예외상황 - class literal, instanceof class literal 에는 raw type을 사용해야한다. 12List&lt;String&gt;.class;// compile errorList.class 배열과 기본타입을 제외하고 class literal에 매개변수화 타입을 사용하지 못하게 하였다. instanceof generic은 runtime 시점에 매개변수화 타입이 모두 지워진다. (Type erasure) 따라서 instanceof 와 같이 runtime에 타입을 비교하는 경우에는 매개변수화 타입을 당연히 사용할 수 없다. 따라서 raw type을 쓰는게 맞다. (Type erasure ensures that no new classes are created for parameterized types; consequently, generics incur no runtime overhea, https://docs.oracle.com/javase/tutorial/java/generics/erasure.html) 123if(o instanceof Set){ Set&lt;?&gt; s = (Set&lt;?&gt;) s;} 정리raw type을 사용하는 경우에는 타입 안전성을 제공해주지 않아 runtime error가 발생하기 쉬우므로, 예외상황이 아닌 경우에는 raw type보다는 generic type을 사용해야한다. &lt;Object&gt; 는 어떤 타입의 객체도 받을 수 있는 매개변수화 타입이고, &lt;?&gt; 는 어떤 타입도 받을 수는 있으나, Collection&lt;?&gt; 인 경우에 null을 제외한 어떠한 원소도 삼입이 불가능하다.","link":"/2021/12/28/2021-12-28-item26/"},{"title":"Item27. 비검사 경고를 제거하라","text":"@SuppressWarningscompiler 경고를 제거할수는 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarning(“unchecked”) annotation을 달아 경고를 숨길 수 있다, 단 rumtime에 ClassCastException이 발생하지 않도록 타입 안전함을 검증해야 한다. @SuprressWarnings 사용 주의점 @SuppressWarinigs의 적용범위는 지역변수~class 까지 어떤 범위에도 선언할 수 있으나, 가능한 좁은 범위에 적용해야 한다 ex) 한줄이 넘는 method나 생성자에 달린 경우, 지역변수 선언으로 옮김 1234567891011//ArrayList의 toArray methodpublic &lt;T&gt; T[] toArray(T[] a){ if(a.length &lt; size){ return (T[]) Arrays.copyOf(elements,size,a.getClass()); } System.arraycopy(elements,0,a,0,size); if(a.length &gt; size){ a[size] = null; } return a;} ArrayList를 compile하면 경고가 발생한다, 이떄 method 전체에 @SuppressWarnings를 선언해 혹시 발생할 수도 있는 다른 error를 숨기는 방향보다, 지역변수로 뽑아서 @SuppressWarnings를 적용하는것을 권고하고 있다. 123456789101112public &lt;T&gt; T[] toArray(T[] a){ if(a.length &lt; size){ @SuppressWarnings(&quot;unchecked&quot;) T[] result = (T[]) Arrays.copyOf(elements, size, a.getClass()); return result; } System.arraycopy(elements,0,a,0,size); if(a.length &gt; size){ a[size] = null; } return a;} 추가적으로 @SuppressWarning 로 명시적으로 컴파일 경고를 숨길때에는 항상 주석으로 안전한 이유를 적어두어야 한다.","link":"/2021/12/28/2021-12-28-item27/"},{"title":"Item28. 배열보다는 리스트를 사용하라","text":"배열과 Generic type의 차이점 배열은 공변(covariant) 인 반면 Generic은 불공변(invariant) 이다. Sub class가 Super class의 하위 class라고 가정하면 배열 Sub[]는 Super[]의 하위 타입이 된다.반면에 서로 다른 타입인 Type1과 Type2가 있을떄 Generic인 List&lt;Type1&gt; List&lt;Type2&gt; 은 아무 계층관계도 가지지 않는다. 1234567// Array Object[] longs = new Long[1];longs[0] = &quot;타입이 다름에도 컴파일에러가 나지 않습니다.&quot;; //ArrayStoreException// Generic List&lt;Object&gt; ol = new ArrayList&lt;Long&gt;(); // compile Error 배열은 type으로 인해 runtime Exception이 발생할 수 있는 반면, generic인 compile 경고를 먼저 띄워준다. 배열은 실체화 된다. 배열은 runtime 에도 원소의 타입을 인지하고 확인한다, 예를 들면 Long 배열에 String을 넣으려고 하면 runtime에 이를 확인하고 예외를 발생시킨다.반면 generic은 runtime에 타입을 소거한다 (type erasure). 원소의 타입을 compile time에만 검사하며 , runtime에는 모른다. 위와 같은 차이점 떄문에 Generic 배열은 Java에서 허용되지 않는다. 예시로 아래와 같이 List 를 원소로 갖는 제너릭 배열을 만든다고 가정하면, 배열은 공변이기 떄문에 Object[] 으로 배열을 받을 수 있고,Object[] 배열은 모든 타입의 원소를 받을 수 있으므로 값을꺼낼때 runtime error가 발생할수도 있다. 12345List&lt;String&gt;[] stringList = new List&lt;String&gt;[1];List&lt;Integer&gt; integerList = List.of(42);Object[] objects = stringList;objects[0] = integerList;String s = stringList[0].get(0); 실체화 불가 타입E,List&lt;E&gt;,List&lt;String&gt;과 같은 type을 실체화 불가 타입이라고 한다. 실체화 불가 타입이란 runtime에는 compile time보다 타입 정보를 적게 가지는 타입이다. runtime시 타입 소거 떄문에 매개변수화 타입 중에 실체화 될 수 있는 타입은 List&lt;?&gt; 와 Map&lt;?,?&gt; 와 같은 비한정적 wildcard 타입 뿐이다. Generic type을 배열로 형변환12345678910111213public class Chooser { private final Object[] choiceArray; public Chooser(Collection choice){ this.choiceArray = choice.toArray(); } public Object choose(){ Random rnd = ThreadLocalRandom.current(); return choiceArray[rnd.nextInt(choiceArray.length)]; }} 이를 client에서 꺼내쓰려면 매번 형변환이 필요하다 123List&lt;String&gt; stringList = List.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;);Chooser chooser = new Chooser(stringList);String result = (String) chooser.choose(); 따라서 다음과 같이 generic collection을 생성자에서 받고, T 배열로 형변환하면 된다. 123456789101112public class Chooser&lt;T&gt; { private final T[] choiceArray; public Chooser(Collection&lt;T&gt; choice){ this.choiceArray = (T[]) choice.toArray(); } public T choose(){ Random rnd = ThreadLocalRandom.current(); return choiceArray[rnd.nextInt(choiceArray.length)]; }} 123List&lt;String&gt; stringList = List.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;);Chooser&lt;String&gt; chooser = new Chooser&lt;&gt;(stringList);String result = chooser.choose(); 또는 배열과 Generic을 섞어 쓰는 상황에서는 아래와 같이 배열을 리스트로 아예 대체하는 해결방안도 제시하고 있다. 123456789101112public class Chooser&lt;T&gt; { private final List&lt;T&gt; choiceList; public Chooser(Collection&lt;T&gt; choice){ this.choiceList = new ArrayList&lt;&gt;(choice); } public T choose(){ Random rnd = ThreadLocalRandom.current(); return choiceList.get(rnd.nextInt(choiceList.size())); }} 정리배열과 Generic은 다른 타입 규칙이 적용된다. 배열은 공변 , Generic은 불공변이다.Generic은 compile time에 type 관련 error를 잡아주고 type이 지워진 bytecode를 만드는 반면, 배열은 runtime에도 type을 검사하고, type과 관련된 runtime exception이 터질 수도 있다.Generic과 배열을 같이쓰는 상황에서는 배열을 List로 대체하는 것을 고려하자","link":"/2021/12/29/2021-12-29-item28/"},{"title":"Servlet Filter 와 Spring Interceptor","text":"Servlet Filter servlet filter는 http 요청이 dispatcher servlet에 전달되기전에 호출되는 객체로서, 호출되는 순서는 아래와 같다. HTTP message –&gt; WAS –&gt; Filter –&gt; dispatcher servlet dispatcher servlet: Tomcat과 같은 servlet container 안에 HTTP 요청을 가장 먼저 받아, 적합한 controller에게 요청을 forwarding 해주는 일종의 front controller(https://docs.spring.io/spring-framework/docs/3.0.0.M4/spring-framework-reference/html/ch15s02.html) 주로 logging, encryption , input validation 과 같은 공통 관심사에 기능을 적용하고자 할떄 활용된다. Filter chain : Filter는 chain 형태로 구성되어, 여러개의 필터를 끼울 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738package javax.servlet;import java.io.IOException;/** * A filter is an object that performs filtering tasks on either the request to * a resource (a servlet or static content), or on the response from a resource, * or both. &lt;br&gt; * &lt;br&gt; * Filters perform filtering in the &lt;code&gt;doFilter&lt;/code&gt; method. Every Filter * has access to a FilterConfig object from which it can obtain its * initialization parameters, a reference to the ServletContext which it can * use, for example, to load resources needed for filtering tasks. * &lt;p&gt; * Filters are configured in the deployment descriptor of a web application * &lt;p&gt; * Examples that have been identified for this design are&lt;br&gt; * 1) Authentication Filters &lt;br&gt; * 2) Logging and Auditing Filters &lt;br&gt; * 3) Image conversion Filters &lt;br&gt; * 4) Data compression Filters &lt;br&gt; * 5) Encryption Filters &lt;br&gt; * 6) Tokenizing Filters &lt;br&gt; * 7) Filters that trigger resource access events &lt;br&gt; * 8) XSL/T filters &lt;br&gt; * 9) Mime-type chain Filter &lt;br&gt; * * @since Servlet 2.3 */public interface Filter { public default void init(FilterConfig filterConfig) throws ServletException {} public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; public default void destroy() {}}} java.servlet.Filter interface는 3가지 method를 가지고 있다. init() : servlet container가 생성될떄 호출되는 filter 초기화 method이다. destroy() : servlet contrainer가 종료될떄 호출되는 method doFilter() : client 요청시마다, 해당 method가 호출된다. Servlet Filter 예제123456789101112131415161718192021222324252627import lombok.extern.slf4j.Slf4j;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;@Slf4jpublic class TestFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { log.info(&quot;filter init&quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest httpServletRequest = (HttpServletRequest) request; log.info(&quot;request path : {}&quot;,httpServletRequest.getRequestURI()); chain.doFilter(request,response); } @Override public void destroy() { log.info(&quot;filter destroy&quot;); }} Filter interface를 implement한 Filter는 다음과 같이 등록이 가능하다. 12345678@Beanpublic FilterRegistrationBean&lt;TestFilter&gt; testFilter(){ FilterRegistrationBean&lt;TestFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;(); registrationBean.setFilter(new TestFilter()); // 등록할 필터 registrationBean.setOrder(1); // filter chain 순서 registrationBean.addUrlPatterns(&quot;/*&quot;); // 적용할 url pattern return registrationBean;} 등록할떄 필터간에 실행될 순서도 조절할 수 있는데, Filter chain을 어떤 순서로 실행할지 설정할 수 있다. 1234567891011121314151617@Beanpublic FilterRegistrationBean&lt;TestFilter&gt; testFilter(){ FilterRegistrationBean&lt;TestFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;(); registrationBean.setFilter(new TestFilter()); registrationBean.setOrder(1); registrationBean.addUrlPatterns(&quot;/*&quot;); return registrationBean;}@Beanpublic FilterRegistrationBean&lt;SecondFilter&gt; secondFilter(){ FilterRegistrationBean&lt;SecondFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;(); registrationBean.setFilter(new SecondFilter()); registrationBean.setOrder(2); registrationBean.addUrlPatterns(&quot;/*&quot;); return registrationBean;} Servlet Filter - 요청에 따른 분기 처리만약 Filter에서 특정 요청 url에 따라 분기처리를 하고 싶다면 다음과 같이 구현이 가능하다. 123456789101112131415161718192021222324@Slf4jpublic class TestFilter implements Filter { private final String[] allowPath ={&quot;/test&quot;}; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest httpServletRequest = (HttpServletRequest) request; String requestURI = httpServletRequest.getRequestURI(); log.info(&quot;filterName : {} / request path : {}&quot;,&quot;FirstFilter&quot;,requestURI ); if(isAllowPath(requestURI)){ chain.doFilter(request,response); // 다음 filter chaninig }else{ response.getWriter().write(&quot;허용되지 않는 경로입니다.&quot;); return; // dispatcher servlet 전달이전에 요청종료 } } private boolean isAllowPath(String requestURI) { return PatternMatchUtils.simpleMatch(allowPath, requestURI); } Spring Interceptorspring interceptor는 filter와 유사한 기능을 하나 , servlet 이 제공하는 기술이 아니라 spring MVC에서 제공해주는 기술이다. Servlet filter와 Spring Interceptor와 차이점 적용 순서 spring interceptor는 servlet container위에서 동작하는 spring이 제공해주는 기술으로 적용순서가 servlet filter 보다 뒷단계에서 적용된다. HTTP 요청 –&gt; WAS –&gt; servlet filter –&gt; dispatcher servlet –&gt; spring interceptor –&gt; controller 요청 url pattern 조절 spring interceptor는 interceptor를 등록할떄 특정 url을 제외하고 spring interceptor를 적용가능하다 method 적용시점 interceptor는 controller 호출 전, 호출 후, 요청 완료 이후 까지 세분화되어 적용이 가능하다. 이에 반해 filter는 filter 초기화,소멸시점과 filter 로직을 넣을수 있는 doFilter() 만 제공한다. Spring Interceptor Interfacespring interceptor interface는 org.springframework.web.servlet.HandlerInterceptor interface이다. 123456789101112131415161718192021222324252627public interface HandlerInterceptor { /** * Interception point before the execution of a handler. Called after HandlerMapping determined an appropriate handler object, but before HandlerAdapter invokes the handler */ default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return true; } /** * Interception point after successful execution of a handler. Called after HandlerAdapter actually invoked the handler, but before the DispatcherServlet renders the view. */ default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception { } /** * Callback after completion of request processing, that is, after rendering * the view. Will be called on any outcome of handler execution, thus allows * for proper resource cleanup. */ default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception { } interface 설명에도 적혀있지만 세 method는 적용 시점이 다르다. preHandle(…) : controller 요청 전 ( Called after HandlerMapping determined an appropriate handler object, but before HandlerAdapter invokes the handler ) postHandle(…) : controller 요청 이후 (Called after HandlerAdapter actually invoked the handler, but before the DispatcherServlet renders the view.) afterCompletion(…) : 요청 완료 이후 (= 뷰 렌더링 이후 ) afterCompletion같은 경우에는 interface 설명에 보면 예외가 발생해도 실행됨으로, resource 정리에 활용될 수 있다고 한다. 반면 postHandle은 controller가 예외없이 성공적으로 실행됬을때만 실행된다. spring interceptor 예제123456789101112131415161718192021222324@Slf4jpublic class TestInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(&quot;before handler / handler : {}&quot; , printClassName(handler)); return true; // true 를 반환하면 다음 interceptor 가 호출된다. } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info(&quot;after handler / handler : {}&quot; , printClassName(handler)); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { log.info(&quot;view rendering / handler: {} / ex: {} &quot;,printClassName(handler) , ex.getMessage()); } private String printClassName(Object handler) { return handler.getClass().getName(); }} interceptor는 다음과 같이 등록할 수 있다. 123456789101112@Configurationpublic class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { WebMvcConfigurer.super.addInterceptors(registry); registry.addInterceptor(new TestInterceptor()) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/exclude&quot;) // interceptor적용하지 않을 path 명시 .order(1); // interceptor 적용순서 }} 다음과 같이 handler에 예외가 발생하면 postHandle(…)은 호출되지 않고, afterCompletion(…) method에 예외정보가 담겨 반환된다. 12345678@RestControllerpublic class TestController { @GetMapping(&quot;/test-ex&quot;) public String testEx(){ throw new RuntimeException(&quot;runtime exception.&quot;); }}","link":"/2021/12/29/2021-12-29-spring-filter-interceptor/"},{"title":"Item29. 이왕이면 Generic Type으로 만들어라","text":"Generic Type 변환Stack Generic Type으로 변경할 경우 , Client에서 Stack에서 꺼낸 객체를 형변환할 필요가 없으며 동시에 ClassCastException 이 나지 않는 장점을 갖는다. Item 28 에서는 Generic 사용시 배열보다 리스트를 고려하라고 권고는 하였으나 Generic type 안에서 List를 사용하는게 항상 가능하지도 않고, Java가 기본 타입으로 List를 제공하지 않으므로 성능 향상 목적으로 기본 타입인 배열을 사용하기도 한다. 1234567891011121314151617181920212223242526272829303132333435363738public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e){ ensureCapacity(); elements[size++] = e; } public Object pop(){ if(size == 0){ throw new EmptyStackException(); } Object result = elements[--size]; elements[size] = null; // 다 쓴 참조 해제 return result; } public boolean isEmpty(){ return size == 0; } private void ensureCapacity() { if(elements.length == size ){ elements = Arrays.copyOf(elements,2*size+1); } }} Stack class 를 Generic type으로 바꾸기 위해서는 먼저 타입매개변수를 추가한다 (관례상으로 E를 주로 사용함) 12345678910111213141516171819202122232425262728293031public class Stack&lt;E&gt; { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { // compile Error , E는 실체화불가 타입 elements = new E[DEFAULT_INITIAL_CAPACITY]; } public void push(E e){ ensureCapacity(); elements[size++] = e; } public E po public boolean isEmpty(){ return size == 0; } private void ensureCapacity() { if(elements.length == size ){ elements = Arrays.copyOf(elements,2*size+1); } }} 타입매개변수 자체는 실체화 불가 타입임으로 객체화할 수 없다. 1E[] elements = new E[DEFAULT_INITIAL_CAPACITY]; // compile Error 이를 우회하는 해결방안은 2가지가 있다. Object[] 타입으로 배열을 먼저 생성하고 , 타입매개변수 타입으로 형변환하는 방법 1E[] elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; 이떄 타입매개변수 타입으로 변환했을떄 타입 안전한지 확인해야 한다, 해당 배열에서 원소를 꺼내거나, 집어넣을떄 method를 확인하면 원소의 타입은 항상 E임으로 타입 안전하다. 배열 필드 타입을 Object[] 타입으로 선언하고, 해당 배열에 값을 뺼떄 타입매개변수 타입으로 형변환하는 방법 1234567891011121314151617181920public class Stack&lt;E&gt; { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } //... public E pop(){ if(size == 0){ throw new EmptyStackException(); } E result = (E) elements[--size]; // 타입 매개변수 타입으로 형변환 elements[size] = null; // 다 쓴 참조 해제 return result; } 두 방법은 각각의 장단점을 가지고 있다. 1번 방법인 “생성자에서 Object[] 을 타입매개변수 타입으로 형변환하는 방법”은 코드가 짧아져 가독성이 좋다. 또한 배열을 최초로 생성하는 시점에만 한번의 형변환이 일어난다. 반면 2번 방법인 “Object[] 에서 원소를 반환할떄마다 타입매개변수 타입으로 형변환하는 방법” 은 형변환이 pop method 호출 시마다 일어난다는 단점을 가지고 있다. 그럼에도 2번 방법을 고려하는 이유는 1번 방법에서 생길 수 있는 Heap pollution 떄문이다. heap pollution is a situation that arises when a variable of a parameterized type refers to an object that is not of that parameterized type. This situation is normally detected during compilation and indicated with an unchecked warning. Later, during runtime heap pollution will often cause a ClassCastException. (ref-https://en.wikipedia.org/wiki/Heap_pollution) heap pollution이란 선언된 매개변수 타입의 변수로 다른 매개변수 타입의 변수를 가르키는 경우에 발생한다. heap pollution이 발생한 이유는 item 26에서 사용하지 말라고 강조했던 raw type 을 사용했기 때문이다. 앞선 item 설명대로 generic 은 불공변임으로 서로 다른 타입은 어떠한 상속관계도 갖지 않음에도 불구하고, raw type을 사용함으로 다른 타입을 형변환되었다. 따라서 runtime에 원소를 꺼낼떄 ClassCastException이 발생한다. 12345public static void main(String[] args) { List integerList = List.of(10, 11, 12); // raw type 사용 List&lt;String&gt; stringlist = (List&lt;String&gt;) integerList; //heap pollution String s = stringlist.get(0);// ClassCastException: class java.lang.Integer cannot be cast to class java.lang.String} 한정적 타입 매개변수 - 타입 매개변수 제약한정적 타입 매개 변수(bounded type pararmeter)는 타입 매개 변수에 제약을 두는 방법으로 , 특정 타입을 상속받아, 해당 타입의 하위 타입만 타입매개변수로 사용가능하도록 제한하는 방법이다. 1public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt; {//...} 정리client에서 직접 형변환하지 않도록 Generic 으로 만들어두면 안전하고 사용하기 편하다, 배열의 경우 Generic으로 만들떄는 타입 매개변수는 실체화 불가능한 타입임으로 new Object[] 로 먼저 객체를 생성하고 타입매개변수 타입으로 형변환하면 된다. (heap pollution은 주의)","link":"/2021/12/30/2021-12-30-Item29/"},{"title":"Item30. raw type 보다는 Generic method로 만들어라","text":"Generic Method아래와 같이 raw type을 받는 method는 타입 안전하지 않다. 12345public static Set union(Set s1, Set s2){ Set result = new HashSet&lt;&gt;(s1); result.addAll(s2); return result;} 아래와 같이 다른 타입의 Generic이 와도 어떠한 compile error도 발생하지 않고 runtime exception이 터진다. 123Set&lt;String&gt; strings = Set.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);Set&lt;Integer&gt; integers = Set.of(1, 2, 3);Set&lt;String&gt; unionResult = union(strings, integers); method parameter와 반환타입을 다음과 같이 Generic method로 변경함으로 타입 안전하게 만들 수 있다. 12345public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1,Set&lt;E&gt; s2){ Set&lt;E&gt; result = new HashSet&lt;&gt;(s1); result.addAll(s2); return result;} Generic Singleton Factory 요청 타입 매개변수에 맞게 매번 그 객체의 타입을 바꾸주는 정적 팩토리 method Generic은 Runtime에 type정보가 소거된다. (Type erasure) 따라서 하나의 객체를 어떤 타입으로든 매개변수화 할 수 있다. 12345private static UnaryOperator&lt;Object&gt; IDENTITY_FN = (t)-&gt;t;// Generic Sinlgeton Factory method public static &lt;T&gt; UnaryOperator&lt;T&gt; identityFunction(){ return (UnaryOperator&lt;T&gt;) IDENTITY_FN;} Generic Sinlgeton Factory method 인 identityFunction 는 항등함수로 string이 들어오면 string으로 number가 들어오면 number type으로 반환타입을 바꿔준다. 1234567String[] strings = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;};UnaryOperator&lt;String&gt; sameString = identityFunction();Arrays.stream(strings).forEach((element)-&gt; System.out.println(sameString.apply(element)));Number[] numbers= {1,2.0,3L};UnaryOperator&lt;Number&gt; sameNumber = identityFunction();Arrays.stream(numbers).forEach((element)-&gt; System.out.println(sameNumber.apply(element))); Recursive type bound자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용범위를 한정할 수 있는데 이를 재귀적 타입 한정( Recursive type bound) 이라고 한다. 주로 Comparable interface와 함께 쓰인다. 12345678910111213// collection에서 max값을 반환 public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c){ if(c.isEmpty()){ throw new IllegalArgumentException(&quot;empty collection&quot;); } E result = null; for (E e : c) { if(result == null || e.compareTo(result) &gt; 0){ result = Objects.requireNonNull(e); } } return result; } 반환 타입 &lt;E extends Comparable&lt;E&gt; 을 보면 자기 자신의 타입과 비교가 가능함을 표현하고 있다. 정리반환값을 매번 명시적으로 형변환해야하는 경우 Generic method를 사용하면 안전하고 사용하기 간편하다","link":"/2022/01/01/2022-01-01-Item30/"},{"title":"Spring validation - BindingResult","text":"BindingResultspring은 입력데이터에 대한 validation과 예외처리를 지원해준다. org.springframework.validation.BindingResult 가 validation 기능을 지원해주는 주요 객체 중 하나이다. BindingResult는 입력 form의 필드값 중에 오류가 있으면 오류정보를 담아둔다. 예제아래와 같은 간단히 사람의 이름과 나이를 입력하고 입력한 정보를 조회할 수 있는 controller가 있다고 가정하자 12345678910111213141516171819202122232425262728293031@Slf4j@Controller@RequiredArgsConstructor@RequestMapping(&quot;/member&quot;)public class MemberController { private final MemberRepository repository; @GetMapping public String getMember(Model model){ model.addAttribute(new Member()); return &quot;member&quot;; } @PostMapping public String addMember(@ModelAttribute Member member , RedirectAttributes redirectAttributes){ log.info(&quot;member : {}&quot;,member); Member savedMember = repository.save(member); Long id = savedMember.getId(); redirectAttributes.addAttribute(&quot;id&quot;,id); return &quot;redirect:/member/{id}&quot;; } @GetMapping(&quot;/{id}&quot;) public String detailMember(@PathVariable(name = &quot;id&quot;) Long id ,Model model ){ Member foundMember = repository.findById(id); model.addAttribute(&quot;member&quot;,foundMember); return &quot;memberDetail&quot;; }} getMember method 로 사람의 정보를 등록할 수 있는 member page가 호출된다. 1234567891011121314151617181920&lt;!-- member.html --&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; lang=&quot;eg&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/member&quot; method=&quot;POST&quot; th:object=&quot;${member}&quot; &gt; &lt;div&gt; &lt;label th:for=&quot;name&quot;&gt;Enter your name: &lt;/label&gt; &lt;input type=&quot;text&quot; th:field=&quot;*{name}&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label th:for=&quot;age&quot;&gt;Enter your age: &lt;/label&gt; &lt;input type=&quot;text&quot; th:field=&quot;*{age}&quot;&gt; &lt;/div&gt; &lt;button&gt;submit&lt;/button&gt;&lt;/form&gt; addMember 를 호출하면 name=value&amp;name=value 형태 (Content-Type: application/x-www-form-urlencoded) 로 데이터가 서버에 넘어가고, 서버에서 memberDetail page로 redirect 한다. 이를 PRG 패턴이라고 한다. PRG pattern - Post/Redirect/Get POST 방식으로 client에서 server로 데이터 전송 이후, Server가 바로 특정 page를 forward하게 되면 refresh 시 데이터가 중복 재전송된다. 이를 방지하기 위해서 다른 페이지로 GET (redirect) 한다. (ref - https://en.wikipedia.org/wiki/Post/Redirect/Get) Binding Result 적용 1bidingResult는 에러를 포함한 객체 바로 다음에 와야 한다. 객체의 필드값별로 로직에 따라 추가할 에러를 설정할 수 있다. bindingResult.addError(ObjectError) 참고로 FieldError는 Object Error의 자식임으로 addError parameter에 넘겨줄 수 있다. 1public class FieldError extends ObjectError{} field Error와 object error는 2개의 생성자를 overloading 하고 있는데첫번쨰는 defaultMessage (view에 보여줄 메시지) 를 바로 명시하는 생성자 방식이 있고,두번째는 messageCodeResolver에 의해 설정파일로부터 값을 읽어와 view에 보여줄 수 있는 생성자 방식이 있다.두 방식에서 공통 매개변수는 객체와 해당 객체에 오류를 가졌다고 명시할 필드이다. 참고로 messageCodeResolver와 messages.properties 관련 내용은 spring internalization 관련 내용으로 , boot에서는 /resources/messages.properties 파일을 생성하고, message code를 입력하면 자동으로 등록해준다. Object error는 해당 객체에 특정 필드가 가진 오류라기보다 global 오류 정보를 의미한다. 예를 들어 특정 필드간의 조합이 x 범위 이내를 만족하지 못할 경우이다. 12345678910111213141516171819202122232425@PostMappingpublic String addMember(@ModelAttribute Member member , BindingResult bindingResult , RedirectAttributes redirectAttributes){ // binding result는 에러 필드를 가진 객체 바로 뒤에 와야한다. // fieldErrors log.info(&quot;member :{}&quot;,member); if(!StringUtils.hasText(member.getName())){ bindingResult.addError(new FieldError(&quot;member&quot;,&quot;name&quot;,member.getName(),false,new String[]{&quot;empty.name&quot;},null,null)); } if(member.getAge() == null){ bindingResult.addError(new FieldError(&quot;member&quot;,&quot;age&quot;,member.getAge(),false,new String[]{&quot;empty.age&quot;},null,null)); } // objectErrors if(member.getAge() != null &amp;&amp; member.getAge() &lt;= 10 &amp;&amp; member.getName().startsWith(&quot;Kim&quot;)){ bindingResult.addError(new ObjectError(&quot;member&quot;,new String[]{&quot;limit.member&quot;},null,null)); } // error가 있다면 바로 view 반환 if(bindingResult.hasErrors()){ return &quot;member&quot;; } Member savedMember = repository.save(member); Long id = savedMember.getId(); redirectAttributes.addAttribute(&quot;id&quot;,id); return &quot;redirect:/member/{id}&quot;;} 위와 같이 controller에서 binding result에 error 정보를 포함해주고, 바로 view를 반환한다. template engine마다 다르겠지만 thymeleaf template engine은 spring binding result에 포함된 오류정보를 꺼내서 보여주는 기능을 가지고 있다. 12345678910111213141516171819&lt;form action=&quot;/member&quot; method=&quot;POST&quot; th:object=&quot;${member}&quot; &gt; &lt;!-- objectError --&gt; &lt;div th:if=&quot;${#fields.hasGlobalErrors()}&quot;&gt; &lt;p th:each=&quot;err : ${#fields.globalErrors()}&quot; th:text=&quot;${err}&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label th:for=&quot;name&quot;&gt;Enter your name: &lt;/label&gt; &lt;input type=&quot;text&quot; th:field=&quot;*{name}&quot;&gt; &lt;!-- fieldError --&gt; &lt;div th:errors=&quot;*{name}&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;label th:for=&quot;age&quot;&gt;Enter your age: &lt;/label&gt; &lt;input type=&quot;text&quot; th:field=&quot;*{age}&quot;&gt; &lt;!-- fieldError --&gt; &lt;div th:errors=&quot;*{age}&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button&gt;submit&lt;/button&gt;&lt;/form&gt; th:object=”${객체명}” th:errors=”*{필드명}” 을 사용하면 해당 필드에 오류가 있으면 bindingResult에 저장된 오류 메시지를 출력해준다. thymeleaf에서는 th:object에 명시될 객체를 command object라고 한다. Command object is the name Spring MVC gives to form-backing beans, this is, to objects that model a form’s fields and provide getter and setter methods that will be used by the framework for establishing and obtaining the values input by the user at the browser side. (ref - https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#validation-and-error-messages) Binding Result 적용 2앞선 BindingResult는 오류를 검사할 객체 바로 뒤에 온다, 즉 오류를 검사할 target 객체를 알고 있으므로, bindingResult는 오류메시지를 간편하게 추가할 수 있는 method를 제공한다. rejectValue(…) : FieldError 와 유사한 기능 reject(…) : ObjectError와 유사한 기능 123456789101112131415161718192021@PostMappingpublic String addMember(@ModelAttribute Member member , BindingResult bindingResult , RedirectAttributes redirectAttributes){ // binding result는 에러 필드를 가진 객체 바로 뒤에 와야한다. log.info(&quot;member :{}&quot;,member); if(!StringUtils.hasText(member.getName())){ bindingResult.rejectValue(&quot;name&quot;,&quot;empty.name&quot;); } if(member.getAge() == null){ bindingResult.rejectValue(&quot;age&quot;,&quot;empty.age&quot;); } if(member.getAge() != null &amp;&amp; member.getAge() &lt;= 10 &amp;&amp; member.getName().startsWith(&quot;Kim&quot;)){ bindingResult.reject(&quot;limit.member&quot;); } if(bindingResult.hasErrors()){ return &quot;member&quot;; } Member savedMember = repository.save(member); Long id = savedMember.getId(); redirectAttributes.addAttribute(&quot;id&quot;,id); return &quot;redirect:/member/{id}&quot;;} Valdiation 로직 분리위의 검증 로직들은 별도의 validator에 의해 분리될 수 있다.spring은 별도의 validator interface를 제공한다. (org.springframework.validation.Validator) 123456789101112131415161718192021public interface Validator { /** * Can this {@link Validator} {@link #validate(Object, Errors) validate} * instances of the supplied {@code clazz}? */ boolean supports(Class&lt;?&gt; clazz); /** * Validate the supplied {@code target} object, which must be * of a {@link Class} for which the {@link #supports(Class)} method * typically has (or would) return {@code true}. * &lt;p&gt;The supplied {@link Errors errors} instance can be used to report * any resulting validation errors. * @param target the object that is to be validated * @param errors contextual state about the validation process * @see ValidationUtils */ void validate(Object target, Errors errors);} 인터페이스 설명에 보면 2가지 method를 구현해야 하는데, 다음과 같이 정리하였다. supports(…) : 해당 instance가 검증할 class의 instance가 맞는가? validate(…) : 검증 후 , report할 오류는 errors parameter에 추가한다. 위 interface를 만든 예제에 적용하면 다음과 같다. 12345678910111213141516171819202122@Component // 굳이 검증기를 client요청시마다 생성할 이유가 없다, 동시성 이슈가 있는 것도 아니기 떄문에 싱글톤으로 관리하는게 적합하다고 한다. public class MemberValidator implements Validator { @Override public boolean supports(Class&lt;?&gt; clazz) { return Member.class.isAssignableFrom(clazz); } @Override public void validate(Object target, Errors errors) { Member member = (Member) target; if(!StringUtils.hasText(member.getName())){ errors.rejectValue(&quot;name&quot;,&quot;empty.name&quot;); } if(member.getAge() == null){ errors.rejectValue(&quot;age&quot;,&quot;empty.age&quot;); } if(member.getAge() != null &amp;&amp; member.getAge() &lt;= 10 &amp;&amp; member.getName().startsWith(&quot;Kim&quot;)){ errors.reject(&quot;limit.member&quot;); } }} 별도로 validator를 생성자 DI 받으면 controller의 책임과 validation 책임을 분리할수있다 (SRP) 12345678910111213141516171819202122232425262728293031323334353637@Slf4j@Controller@RequiredArgsConstructor@RequestMapping(&quot;/member&quot;)public class MemberController { private final MemberRepository repository; private final MemberValidator validator; @GetMapping public String getMember(Model model){ model.addAttribute(new Member()); return &quot;member&quot;; } @PostMapping public String addMember(@ModelAttribute Member member , BindingResult bindingResult , RedirectAttributes redirectAttributes){ // binding result는 에러 필드를 가진 객체 바로 뒤에 와야한다. log.info(&quot;member :{}&quot;,member); validator.validate(member,bindingResult); if(bindingResult.hasErrors()){ return &quot;member&quot;; } Member savedMember = repository.save(member); Long id = savedMember.getId(); redirectAttributes.addAttribute(&quot;id&quot;,id); return &quot;redirect:/member/{id}&quot;; } @GetMapping(&quot;/{id}&quot;) public String detailMember(@PathVariable(name = &quot;id&quot;) Long id ,Model model ){ Member foundMember = repository.findById(id); model.addAttribute(&quot;member&quot;,foundMember); return &quot;memberDetail&quot;; }} 추가로 해당 controller에 있는 method들에 validator를 적용하고 싶으면 다음과 같이 설정하면 된다. local controller 적용123456789101112public class MemberController { private final MemberRepository repository; private final MemberValidator validator; // controller 마다 적용 @InitBinder public void init(WebDataBinder dataBinder){ dataBinder.addValidators(validator); } global 적용123456789@Configurationpublic class WebConfig implements WebMvcConfigurer { //global (전체 controller)에 해당 검증기 적용 @Override public Validator getValidator() { return new MemberValidator(); }} 정리spring 이 제공하는 binding result를 활용하면 간결하게 검증 로직을 추가할 수 있다. 오류 메시지는 하드코딩하지말고 messages.propeties 에 설정정보를 가져오는 messageCodeResolver를 활용하면 오류 메시지 변경이 생길떄 빠르게 대처할 수 있다. spring 외에 다른 framework 적용시에도 위와 같은 흐름으로 오류 처리를 하면 좋을 것같다. 참고자료인프런 - 김영한 개발자님의 강의를 듣고, 궁금한 부분은 추가로 레퍼런스를 찾고 정리한 글입니다.https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1","link":"/2021/12/30/2021-12-30-spring-validation/"},{"title":"Java Virutal Machine - Memory,실행 엔진 내부 구성요소","text":"JVM의 목표Java 코드를 작성하고 compile하면 bytecode (.class) 가 생성된다. 이 bytecode를 실행해주는 역할이 Jvm의 역할이다. byte code는 최종적으로 machine code (native code)로 변경되서 실행되는데 이는 CPU에 종속적이다. Jvm은 OS별로 구현체가 여러개 있어, Java source 코드는 운영체제와는 독립적으로 작성될 수 있도록 해준다. Jvm은 bytecode (.class)를 실행해주는데, 사실 Java 이외에도 .class file이 생성되는 타 프로그래밍 언어들을 실행할 수 있다 예를 들면 Kotlin ,Scala 가 있다. JRE, JDK , JVMJVM은 우리가 흔히 사용하는 JRE, JDK에 포함되어있다. 그렇다면 Jre와 Jdk간의 차이점은 무엇일까? Jre (Java Runtime Environment) : java를 실행할 수 있게 해주는 JVM과 핵심 라이브러리만 가지고 있다.(javac 가지고 있지 않음 ) Jdk ( Java ) : JRE 에 개발에 필요한 여러 tool들을 함께 제공하고,Java11부터는 Jdk만을 제공한다. Jvm 구조Jvm은 다음과 같은 구성요소로 이루어진다. 클래스 로더 시스템 메모리 실행 엔진 네이티브 메소드 인터페이스 (JNI) 네이티브 메소드 라이브러리 Class loader systemcompile된 class file을 Jvm 이 OS로부터 할당받은 메모리에 배치하는 역할을 한다. classs loader system은 loading,linking ,initialization 3가지 task를 수행하는데 다음과 같다. loading : class file을 읽어오는 과정 linking : reference 연결 intialization : static 값 초기화 Memory 구조Jvm이 할당받은 메모리 공간을 크게 3가지로 나누고 내부적으로 사용하는 PC register , Native method stack이 존재한다. PC register는 현재 thread가 실행중인 명령어의 위치를 가르키는 pointer가 저장된다. 당연히 thread 별로 독립적으로 할당되고, native method stack도 thread별로 할당된다.native method란 java에 native keyword가 들어간 c,c++로 구현된 method를 말한다. 123@HotSpotIntrinsicCandidatepublic static native Thread currentThread(); Method 영역 - Thread 간 공유 Stack 영역 - Threaad별로 독립적으로 할당됨 Heap 영역 - Thread간 공유 web과 같이 client reqeust가 thread에 mapping되서 실행되는 상황에서는 thread간 race condition이 생길 수 있는데 이는 method,heap영역에 있는 thread간 공유자원을 동시에 접근해서 생기는 문제들이다. Memory - Method areamethod 영역에는 method의 bytecode 와 class 변수 (static 변수) 가 저장된다. java main method 호출로부터 프로그램이 시작되는데, 사실상 main method 의 byte code는 program의 흐름을 구성하는 byte code이기때문에 컴파일된 코드의 거의 대부분이 method 영역에 올라간다. method 영역은 bytecode를 저장함으로 class 정보 (클래스 로딩 시점)를 처음 메모리에 올릴떄 저장되는 메모리 공간이다. 따라서 method 영역에는 클래스 수준의 정보를 저장된다. (클래스 이름, 부모클래스명 , method , 변수) method 영역은 jvm permanent generation영역의 일부이다. permananat generation의또 다른 영역은 runtime constant pool 로서, string literal 등이 보관된다. Memory - HeapHeap 영역에는 객체가 저장된다. Heap 영역은 객체 생성 시점에 따라 Young Generation , Old Generation 에 나누어 진다. 새로 생성된 객체는 young generation에 보관되었다가 young generation 영역이 모두 차면 GC가 수행되는데 이를 minor Gc라고 한다. Young Generation은 3개의 요소로 나뉘어진다. 1. Eden Memory 2. two Survivor Memory spaces. 여러번의 minor GC 에도 참조가 계속 남아있어서 살아있는 객체는 old genration영역으로 옮겨진다. 마찬가지로 old generation 영역도 모두 차면 GC가 수행되는데 이를 major GC라고 한다. (ref- https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java ) Memory - stackthread 마다 할당되는 메모리 영역이다. 지역변수, 매개변수가 저장되는 공간이다. 지역변수,매개변수는 해당 method 내에서만 유효한 변수들인데, 조금 더 자세히 정리하면 해당 method를 빠져나가면 바로 소멸되는 영역이다. 공부한 내용을 바탕으로 메모리 구조를 정리하면 위와 같다.사실 heap 내 young generation내 eden 영역도 있고, gc에 의해 관리되는 메카니즘도 또 있는데 기회가 되면 깊숙한 메카니즘까지 공부해보고 싶다. Native method - JNI, library Native method library: c,c++로 작성된 library JNI(Java native Interface) : java 실행엔진의 요소로서 c,c++,assembly code로 작성된 함수를 사용할 수 있게 해준다. JVM 실행엔진JVM 실행엔진은 interpreter , JIT Compiler , GC(garabage collector) 로 구성된다. interpreter : bytecode를 한줄씩 machine code로 compile Just In time(JIT) compiler : bytecode내 반복적인 code를 한꺼번에 machine code로 compile GC : 참조되지 않은 객체를 메모리에서 제거한다.","link":"/2022/01/01/2022-01-01-JVM/"},{"title":"EntityManagerFactory ,EntityManager, Persistent Context 주요 개념","text":"Jpa 의 EntityManagerFactory ,EntityManager, Persistent Context 주요 개념을 알아보기전에 spring boot에서 Jpa 환경을 setting 해주었다. spring boot에서는 /meta-inf/persistence.xml JPA 설정파일을 인식하지 않고, 기본으로 설정해준다. spring이 아닌 환경에서는 /META-INF/persistence.xml 파일을 설정해주어야 한다. boot에서는 다음과 같이 EntityManagerFactory 와 EntityManager 를 주입받을 수 있다. 12345@PersistenceContextEntityManager em;@PersistenceUnitEntityManagerFactory emf; 12345678910111213141516171819202122232425@SpringBootTestclass JpaApplicationTests { @PersistenceUnit EntityManagerFactory emf; @Test void basicJpa() { EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); try{ transaction.begin(); // transaction 시작 // 비즈니스 로직 transaction.commit(); }catch (Exception e){ transaction.rollback(); } finally { em.close(); } emf.close(); }} boot에서 자동으로 설정해준 Persistence class(Jpa 설정 정보)를 주입받아, EntityManagerFactory instance를 생성했다. 참고로 Jpa는 기본적으로 데이터 변경시 Transaction을 당연히 필요로 하며, transaction이 없는 경우는 예외를 던진다. (javax.persistence.TransactionRequiredException) EntityManagerFactory EntityManagerFactory 는 Persistence class로부터 Jpa를 동작시키기 위한 기반 객체를 만들고, Jpa 구현체에 따라서는 DB connection pool도 만든다 객체 생성 비용이 매우 큼으로, application 전체에 딱 한번만 생성하고 공유된다 (singleton) DB 1개당 하나의 EntityManagerFactory가 생성된다. multi-thread 상황에서 공유 가능하다 EntityManager다음으로 EntityManagerFactory에서 EntityManager를 생성하게 되는데, EntityManager 가 사실상 Jpa 기능의 대부분을 제공한다. 요청시(Thread별로)마다 EntityManagerFactory로부터 EntityManager가 생성된다. (Thread간에 공유하면 race condition 이 생길 수 있다. ) EntityManager는 내부적으로 DB connection을 가지고 DB와 통신하는데, DB 연결이 꼭 필요한 시점까지는 Connection을 가져오지 않는다. Persistence Context (영속성 컨텍스트) Entity를 영구 저장하는 환경으로, EntityManager가 생성될떄 하나 만들어지고, EntityManager는 이 영속성 컨텍스트에 Entity를 보관하고 관리한다. 여기서 Entity란 DB 테이블과 매핑한 Entity class를 말한다. 123456789@Entity // entity public class Member { @Id @Column(name = &quot;ID&quot;) private String id; @Column(name = &quot;NAME&quot;) private String username; private Integer age;} 다음과 같이 em.persist(entity객체) 코드를 실행하면 entityManager는 해당 객체는 영속성 컨텍스트에 저장한다. (영속화한다) 1em.persis(member); Entity 생명주기영속성 컨텍스트에 저장된 엔티티는 다양한 생명주기를 갖는다. 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관련없는상태 영속: 영속성 컨텍스트에 저장된 상태 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태로 영속성 컨텍스트내 준영속화된 entity 정보가 모두 제거된다. (ex) 1차 캐시 정보 , 내부 sql 저장소 ) 삭제 123456void entityLifeCycle(){ Member member = new Member(); // 비영속 상태 : 영속성 컨텍스트와 무관한 상태 em.persist(member); // 영속 상태 (em.find도 영속 상태 엔티티를 반환한다) em.detach(member); // 준영속 상태 em.remove(member); // 삭제 } 추가로 준영속 상태는 entityManager가 다음과 같은 method를 호출했을때 모두 준영속 상태가 된다. em.detach(entity) : 특정 entity만 준영속화 em.clear():영속성 컨텍스트 내 모든 entity 준영속화 em.close():영속성 컨텍스트 종료 준영속화된 entity는 다음과 같이 영속화될수 있다. merge에 대해서는 동작방식이 persist와 약간 다른데, 아래에 정리하였다. 1Entity nowAttachedEntity = em.merge(detachedEntity); Persistent Context의 특징Persistent Context의 특징은 다음과 같다. 1차 Caches 동일성 보장 Write buffering Dirty Checking (변경 감지) Lazy Loading (지연 로딩) 1차 cache영속성 컨텍스트는 DB에 쿼리문을 바로 날리는게 아니라 내부적으로 1차 Cache 에 먼저 저장한다.이떄 @Id (DB의 PK값) 와 Entity 객체를 K-V 로 저장한다. 그렇다면 왜 1차 Cache에 먼저 저장할까? 이름에서 알 수 있듯이 Cache의 장점이다. 접근하기 빠른 더 상위 계층의 저장계층에 저장함으로서 DB까지 I/O query가 안나가고 application에서 영속성 상태의 Entity 객체를 찾아 올 수 있는 것이다. (성능상 장점) 1234Member member = new Member();member.setId(&quot;testId&quot;);em.persist(member); // 1차 cache &lt;testId,member&gt;em.find(Member.class,&quot;testId&quot;) // DB에 I/O요청이 안나간다. 따라서 EntityManger는 먼저 1차 Cache를 조회하고 , 1차 Cache에 Entity가 없다면 DB 에 I/O요청을 보낸다. DB에서 조회한 Entity도 먼저 1차 Cache에 저장하고 반환한다. 동일성 보장1차 Cache와 동일한 내용이다. 1차 Cache에 보관된 Entity 를 계속 find 요청해도 동일한 Entity가 반환된다. 123456789101112131415161718192021@Testvoid test(){ EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); try{ transaction.begin(); Member member = new Member(); // 비영속 상태 : 영속성 컨텍스트와 무관한 상태 member.setId(&quot;testId&quot;); em.persist(member); // 영속 상태 Member foundMemberA = em.find(Member.class, &quot;testId&quot;); Member foundMemberB = em.find(Member.class, &quot;testId&quot;); Assertions.assertThat(foundMemberA == foundMemberB).isTrue(); // 동일한 참조값을 가짐. transaction.commit(); }catch (Exception e){ transaction.rollback(); }finally { em.close(); } emf.close();} Write bufferingEntityManager는 Trnasaction commit 전까지 내부 쿼리 저장소에 쿼리를 저장해둔다. 그리고 Transaction commit 시점에 한번에 데이터베이스에 쿼리를 보낸다 (flush) flush : 영속성 컨텍스트의 엔티티는 유지한 채 영속성 컨텍스트의 변경사항을 DB에 동기화하는 작업으로 EntityManager.flush() method 혹은 transaction commit 시점 혹은 JPQL 쿼리 반환 결과를 위해 JPQL 쿼리 실행시에도 자동으로 호출된다. 123456Member member = new Member(); // 비영속 상태 : 영속성 컨텍스트와 무관한 상태member.setId(&quot;testId&quot;);em.persist(member); // 영속 상태member.setUsername(&quot;test1&quot;); //updatemember.setUsername(&quot;test2&quot;); //updatetransaction.commit(); // 최종적으로는 snapshot과 비교후 1개의 update 쿼리가 나간다 이렇게 write buffering 하면 불필요한 쿼리를 줄일 수 있다 예를 들어 위와 같이 member에 대해 update 를 수행하였을떄 바로바로 update query가 나가지 않고, commit 시점에 snapshot과 비교해 한번의 update쿼리가 나간다 (dirty checking) . 이부분은 영속성컨텍스트의 또다른 특징으로 아래에 정리하였다. +) 만약 성능 최적화를 위해 JPQL 쿼리 실행시에도 flsuh가 호출되지 않게하려면 다음과 같이 설정할 수 있다. 12 EntityManager em = emf.createEntityManager();em.setFlushMode(FlushModeType.COMMIT); Dirty Checking (변경 감지)Jpa는 Entity를 영속화해서 영속성 컨텍스트에 보관할떄 최초의 상태를 복사해 저장해준다 (SNAPSHOT) 그리고 flush 시점에 SNAPSHOT과 Entity를 비교해서 변경된 Entity를 찾고 ,update query를 생성해서 EntityManager 내부 쿼리 저장소에 쿼리를 저장해두고 flush 시점에 한번에 커밋한다. 1234em.update(member) // 존재하지 않는 코드member.setAge(23);em.flush(); // 최초 SNAPSHOT과 비교후 AGE가 변경되었음으로 //update쿼리를 쓰기지연 저장소에 보내고, 한꺼번에 커밋된다 (write buffering) Dirty checking 기능은 최초의 SNAPSHOT을 비교해서 update 쿼리 기능을 생성하는 것임으로 당연히 SNAPSHOT이 없는 영속 상택 아닌 Entity들은 적용되지 않는다. default로는 변경되지 않는 필드도 update된다. 아래의 코드는 userName 필드만 변경하고 있는데 실제로 나가는 쿼리를 보면 전체 필드에 대한 쿼리가 나간다. 123456Member member = new Member(); member.setId(&quot;testId&quot;);em.persist(member); member.setUsername(&quot;test1&quot;);member.setUsername(&quot;test2&quot;);transaction.commit(); I/O 요청시 데이터 전송량이 증가함에도 불구하고 이렇게 모든 필드에 대해 업데이트하는 이유는 무엇일까? 수정쿼리가 항상 동일함으로,application 로딩시점에 미리 수정쿼리를 생성해두고 binding 시킬 수 있다. 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 parsing한 쿼리를 재사용할 수 있다. org.hibernate.annotations.DynamicUpdate 을 사용하면 변경되는 필드에 대해서만 쿼리가 나갈수도 있으나, 성능상이점을 얻는 정도는 약 30개이상의 필드가 존재할떄라고 한다. (ref - https://www.baeldung.com/spring-data-jpa-dynamicupdate ) 123456@Entity@Table(name = &quot;MEMBER&quot;)@Setter@DynamicUpdate // 동적으로 update sql 생성 public class Member {} Lazy Loading (지연로딩)준영속 상태가 아닌 실제 Entity 객체 대신 proxy 객체를 반환받고, 해당 객체를 실제 사용할떄 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다. 이와 반대되는 개념이 즉시로딩 (eager loading)이 있는데, entity간 관계를 mapping하는 chapter에서 다시 정리하려고 한다. Merge vs Persist1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@SpringBootTestpublic class ExamMergeMain { @PersistenceUnit EntityManagerFactory emf; Member createMember(String id,String username){ EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); Member member = new Member(); member.setId(id); member.setUsername(username); em.persist(member); transaction.commit(); em.close();//영속성 컨텍스트가 종료됨 return member; // 영속 --&gt; 준영속 } void mergeMember(Member member){ EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); Member mergeMember = em.merge(member); transaction.commit(); System.out.println(&quot;member.getUsername() = &quot; + member.getUsername()); // 준영속 상태 System.out.println(&quot;mergeMember.getUsername() = &quot; + mergeMember.getUsername()); //영속 상태 System.out.println(&quot;em.contains(member) = &quot; + em.contains(member)); System.out.println(&quot;em.contains(mergeMember();) = &quot; + em.contains(mergeMember)); em.close(); } @Test void test(){ Member member = createMember(&quot;testId&quot;, &quot;tester&quot;); // 준영속상태 member.setUsername(&quot;changed&quot;); mergeMember(member); }} createMember(…) method가 실행됨에따라 entitymanager가 transaction을 열고, 데이터를 변경하는데 member entity를 영속화하고, commit()한다. commit 시점에 insert into Member query가 수행된다. em.close() 호출함에따라 member는 영속성컨텍스트가 종료되어 이젠 준영속상태이다. member.setUsername(“changed”)를 호출해도 준영속상태임으로 dirty checking되지 않고 ,mergeMember(…)의 parameter로 넘어간다. 새로운 entitymanager가 transaction을 다시 열고 , 준영속상태의 member를 merge 한다. merge 동작 방식은 다음과 같다. parameter로 넘어온 준영속상태의 entity key 값으로 1차cache에서 조회하고 , 1차 cache에 없다면 DB까지 가서 값을 가져오고, 1차 cache에 저장한다. 조회된 entity를 준영속상태의 entity 의 모든 값으로 변경한다. *** 영속 상태인 조회된 entity를 반환한다. 정리하면 merge는 persist와 다르게 준영속상태의 entity를 영속화시킬떄 쓰이는데 , 모든 필드의 값을 덮어씌운다는게 차이점이다. 어쩄거나 영속 상태인 조회된 entity의 값이 변경되었으므로 commit시점에 다시 dirty checking이 일어난다. 정리Jpa는 Java 표준 ORM으로 요청시마다 EntityManagerFactory로부터 entity manager가 생성되고, 이 entity manager가 DB connection 을 가지고 와 요청을 수행한다. 이떄 entity manager는 논리적인 persistent context에 entity를 관리하는데, persistent context의 특징은 1차캐시/동일성 보장/write buffering/dirty checking/lazy loading이 있다.","link":"/2022/01/03/2022-01-02-Jpa-emf-em-pc/"},{"title":"Jpa","text":"Jpa 란? Java Persistence API (JPA)는 Java 진영의 ORM (Object relational mapping ) 기술 표준으로서 (API 표준 명세로 , JPA 자체가 구현체는 아니다. ) , JDBC API를 추상화해 application과 JDBC 사이에서 동작한다. Jpa를 사용하려면 그 구현체를 선택해야하는데, 구현체는 hibernate , EclipseLink , DataNuclues가 존재하며 이중에서 hibernate가 가장 대중적이다. ORM의 정의 객체와 관계형 데이터베이스의 엔티티를 매핑한다 ORM을 왜 사용해야하는가?ORM을 사용해야하는 이유는 관계형 데이터베이스와 객체간의 차이점에서 온다. 비즈니스 요구사항을 모델링한 application 객체를 entity라고 하는데, ORM을 사용하지 않으면 entity가 Dao 로직의 SQL에 의존적이 된다. 예를 들면 entity에 추가적인 필드가 생기면 Dao내 sql로직을 같이 수정해주어야 한다. 따라서 application 에서 sql을 직접 다루면, entity를 신뢰할수 없으며 sql에 의존적인 개발이 이루어진다. ORM이 해결해야하는 문제 ORM은 객체와 관계형 데이터베이스간의 불일치성을 해결해야 한다. 대표적인 객체와 관계형 데이터베이스간의 차이점을 보면 아래와 같다. 상속 객체는 상속이 가능하지만 테이블은 상속이 불가능하다. 데이터베이스 모델링에서는 슈퍼타입 서브타입 관계를 사용하면 객체 상속과 유사한 형태로 테이블을 설계할수는 있다. 연관관계 객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회하는 반면 테이블은 외래키를 사용해 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다. 비교 데이터베이스는 PK의 값으로 각 row을 구분하는 반면 객체는 동일성 (==,주소값비교) , 동등성 (equals(),값비교) 으로 구분된다. Jpa를 왜 사용해야하는가? 생산성Jpa를 사용하면 데이터베이스 엔티티를 마치 객체를 다루듯이 추상화해주어 개발 생산성이 증가한다. 반복적인 CRUD SQL를 직접 작성할 필요가 없다. 유지보수성SQL을 직접 다루면 엔티티에 필드 변경이 생겼을 경우 이에 관련된 Dao내의 sql코드가 모두 변경되야 한다. Jpa는 이러한 과정이 모두 추상화되어 제공되기 때문에 수정에 덜 열려있다. 객체와 관계형 데이터베이스간의 불일치성 해결 성능Jpa 는 write buffering 을 통한 여러가지 성능 개선의 여지를 준다. DB 벤더와 독립적으로 개발 가능관계형 데이터베이스는 벤더 (ex) oracle ,mysql) 마다 사용법이 다른 경우가 빈번한데, Jpa는 application이 특정 DB벤더에 종속적이지 않도록 추상화해준다. (Jpa Dialect) Mybatis와 차이점Mybatis를 프로젝트에서 직접 사용해본 경험은 없지만 차이점을 알고 추후에 프로젝트에 더 알맞는 기술을 선택해 개발하는게 중요할 것 같아서 정리한다. Mybatis는 SQL Mapper 기능을 해주는데,객체와 SQL 결과를 매핑해준다. 즉 순수JDBC API를 사용해 ResultSet으로 부터 반환되는 값들을 개발자가 직접 매핑해주는게 아니라 SQL Mapper 기능을 해주는 Mybatis 가 이를 대신 처리해준다. Jpa에 비해 갖는 장점 : 복잡한 쿼리 (ex) 동적 쿼리 ,통계성 쿼리) 도 SQL 쿼리를 직접 작성하기 때문에 최적화된 쿼리를 작성만 할 능력이 된다면 손쉽게 구현할 수 있다. Jpa에 비해 갖는 단점: 앞서 공부했던것처럼 Jpa는 sql에 의존적인 개발을 피하게 추상화시켜준다. 따라서 mybatis는 비즈니스 요구사항 변경시마다 sql로직을 직접 수정해주어야 한다는 단점이 존재한다. 정리Jpa 는 Java ORM 기술 표준으로 그 구현체는 hibernate가 주로 쓰인다, 관계형 데이터베이스와 객체간의 불일치성을 중간에서 추상화시켜 해결해주며, 장점으로는 생산성,유지보수성,DB 벤더에 종속적이지 않게 해준다.Mybatis는 sql mapper로서 sql로직을 직접 작성하지만 그만큼 복잡한 쿼리를 작성하는데는 장점을 가지고 있으나 엔티티가 변경된다면 변경에 열려있다는 단점을 가지고 있다.","link":"/2022/01/02/2022-01-02-Jpa/"},{"title":"Item31. 한정적 와일드카드를 사용해 API 유연성을 높이라","text":"Generic 타입 불공변 특성으로 인한 제약1234567891011121314151617181920212223242526272829303132333435public class Stack&lt;E&gt; { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY =16; public Stack(){ elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(E e){ ensureCapacity(); elements[size++] =e; } public E pop(){ if(size ==0 ){ throw new EmptyStackException(); } E result = elements[--size]; elements[size] =null; return result; } public boolean isEmpty(){ return size == 0; } private void ensureCapacity(){ if(elements.length == size){ elements = Arrays.copyOf(elements,2*size+1); } }} Generic type Stack에서 pushAll method를 추가한다고 가정하자 12345public void pushAll(Iterable&lt;E&gt; src){ for (E e : src) { push(e); }} Integer는 Number의 하위 타입임으로 아래의 method도 논리적으로는 정상작동해야 올바르지만, Generic의 불변성때문에 허용되지않고 compile error 가 나온다. 1234567public static void main(String[] args) { Stack&lt;Number&gt; numberStack = new Stack&lt;Number&gt;(); Iterable&lt;Integer&gt; intList = List.of(10,11,12,13);// numberStack.pushAll(intList);// incompatible types: Iterable&lt;Integer&gt; cannot be converted to Iterable&lt;Number&gt;} bounded wildcard type을 통한 유연성 제공123// bounded wildcard typeList&lt;? extends Number&gt; // Number를 포함한 하위타입만 타입매개변수로 올수있다.List&lt;? super Number&gt; // Number를 포함한 상위타입만 타입매개변수로 올수 있다. 한정적 와일드카드 타입 ( bounded wildcard type ) 을 통해 불공변 특성을 가진 Generic 의 유연성을 높일수 있다. PECS - producer-extends , consumer-super 공식 와일드카드 타입을 사용하는 기본 원칙으로, 매개변수화 타입 T가 생성자라면 &lt;? extends T&gt; 를 사용하고 , 소비자라면 &lt;? super T&gt; 를 사용하라는 공식이다. 위 Generic stack의 예에 적용해보면 다음과 같다.pushAll의 매개변수인 Iterable은 값을 꺼내서(생성해주어서) stack에게 전달해주는 매개변수이다.따라서 생성자라고 볼 수 있다. –&gt; &lt;? extends T&gt; 를 사용한다. 123456// PECS 공식 - 생성자 public void pushAll(Iterable&lt; ? extends E&gt; src){ for (E e : src) { push(e); }} 또 다른 stack의 method로 stack의 모든 원소를 차례로 꺼내서 매개변수에게 전달해주는 popAll() method를 예시로 들었다. 12345public void popAll(Collection&lt;E&gt; dst){ while (!isEmpty()){ dst.add(pop()); }} 마찬가지로 generic은 불공변임으로 모든 객체의 부모class인 Object class임에도 불구하고 in-compatible type compile error 가 뜬다. 123Stack&lt;Number&gt; numberStack = new Stack&lt;Number&gt;();Collection&lt;Object&gt; objList = new ArrayList&lt;&gt;();// numberStack.popAll(objList); PECS 공식을 적용해서 Collection&lt;E&gt; dst 매개변수를 보면 stack의 원소들을 전달받는(stack의 원소를 소비해서) 매개변수이다. 따라서 다음과 같이 수정해야한다. 12345public void popAll(Collection&lt;? super E&gt; dst){ while (!isEmpty()){ dst.add(pop()); }} 또 다른 예제로 collection에서 max값을 찾아주는 max method에 한정적 와일드카드 타입을 적용하면 다음과 같다. 123456789101112public static &lt;E extends Comparable&lt;? super E&gt;&gt; E max(Collection&lt;? extends E&gt; c){ if(c.isEmpty()){ throw new IllegalArgumentException(&quot;empty collection&quot;); } E result = null; for (E e : c) { if(result == null || e.compareTo(result) &gt; 0){ result = Objects.requireNonNull(e); } } return result;} parameter는 collection에서 값을 생성해줌으로 extends , 반환타입인 comparable은 값을 소비함으로 super 를 적용하였다 Comparable은 언제나 소비자임으로, 일반적으로 Comparable&lt;E&gt;보다는 Comparable&lt;? super E&gt; 를 사용하는 편이 낫다. 꼭 PECS 공식을 적용해서 코드를 복잡하게 만들어야 하는 이유가 있을까? 구체적인 예를 보면 아래의 list는 PECS 규칙을 적용한 max method에만 적용된다. 1List&lt;ScheduledFuture&lt;?&gt;&gt; list; 123public interface Comparable&lt;E&gt;public interface Delayed extends Comparable&lt;E&gt;public interface ScheduledFuture&lt;V&gt; extends Delayed,Future&lt;V&gt; ScheduledFuture는 Comparable을 상속받은 Delayed Interface를 상속받았다.max method의 반환타입인 E extends Comparable&lt;E&gt; 를 보면 Comparable&lt;ScheduledFuture&gt; type은 존재할 수 없기 때문이다. 유의점 반환타입에서는 한정적 와일드카드타입을 사용하면 client에서도 한정적 와일드카드 타입을 써야함으로 반환타입에는 사용하면 안된다. compiler 가 올바른 타입을 추론하지 못할떄는 명시적 타입 인수를 사용해서 타입을 알려주면 된다. 이는 JDK 8부터는 Target typing을 지원하지만 JDK 7까지는 발생할 수 있는 문제이다. Target typing (Type Inference , Generalized Target-Type Inference ) : 타입 추론으로 말 그대로 compiler 가 타입을 추론해서 불필요한 boilerplate 코드를 줄여준다.(https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html) 123456789// type inference 도입 전 Map&lt;String, Map&lt;String, String&gt;&gt; mapOfMaps = new HashMap&lt;String, Map&lt;String, String&gt;&gt;();List&lt;String&gt; strList = Collections.&lt;String&gt;emptyList();List&lt;Integer&gt; intList = Collections.&lt;Integer&gt;emptyList();//후 Map&lt;String, Map&lt;String, String&gt;&gt; mapOfMaps = new HashMap&lt;&gt;();List&lt;String&gt; strList = Collections.emptyList();List&lt;Integer&gt; intList = Collections.emptyList(); 타입 매개변수와 wildcard간 선택12public static &lt;E&gt; void swap(List&lt;E&gt; list,int i ,int j) // 타입매개변수 사용public static void swap(List&lt;?&gt; list,int i ,int j) // 와일드카드 사용 generic을 활용해 method 선언시 wildcard와 타입매개변수중 어떤것을 사용해야 할까? method 선언에 타입 매개변수가 한번만 나오면 wild card로 대체하는 것을 권고한다. 위 예제는 하나의 매개변수만 나옴으로, wildcard를 선택하였으나, wildcard collection은 null이외의 값을 넣을 수 없다. 123public static void swap(List&lt;?&gt; list,int i ,int j){ list.set(i,list.set(j,list.get(i)));} 책에서는 해결방안으로 wildcard 의 실제 타입을 알려주는 private 도우미 method를 활용하라고 제시하고 있다. 1234567public static void swap(List&lt;?&gt; list,int i ,int j){ swapHelper(list,i,j);}private static &lt;E&gt; void swapHelper(List&lt;E&gt; list,int i , int j){ list.set(i,list.set(j,list.get(i)));} 정리generic type에 wildcard type을 PECS 규칙을 사용해 적용하면 generic의 장점과 generic의 불공변 제약으로 부터 유연함을 동시에 취할 수 있다.","link":"/2022/01/03/2022-01-03-Item31/"},{"title":"Item32.  Generic과 가변인수를 함께 쓸떄는 신중하라","text":"가변인수에 Generic은 타입 안전하지 않다.가변인수(varargs) method와 Generic은 JDK 5때 함께 추가되었다. 가변인수 method를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다. 가변인수 type을 실체화 불가 타입으로 선언하면 heap pollution 이 생길 수도 있다는 compile 경고가 뜬다. 아래와 같은 상황에서 heap pollution이 발생할수 있기 떄문이다. 1234567 static void dangerous(List&lt;String&gt; ... stringList){// List&lt;String&gt;[] stringList = stringList; Object[] objects = stringList; List&lt;Integer&gt; integers = List.of(42); objects[0] = integers; String s = stringList[0].get(0); } 매개 가변변수 stringList는 Generic 배열타입이 되고, 배열은 공변이기 떄문에 Object[] 타입으로 받을 수 있다. 따라서 Object 배열에 다른 타입매개변수를 갖는 Generic을 넣는 경우, 값을 꺼낼떄 문제가 생긴다. @SafeVaraagrsJDK 7에서 부터 추가되어, Method 작성자가 해당 Method가 타입안전함을 보장해주는 기능을 하며, Generic 가변인수 method 작성자가 client측에 발생하는 경고를 숨길 수 있게 해준다. Generic 가변인수 method는 다음과 같을떄 타입안전하다고 한다. Generic 배열에 아무것도 저장되지 않으면서, 배열의 참조가 외부로 노출되지 않는 경우 다음과 같이 배열의 참조를 반환하는 경우 타입안전하지 않다. 12345678910111213static &lt;T&gt; T[] toArray(T...args){ return args;}static &lt;T&gt; T[] pickTwo(T a,T b ,T c){ switch (ThreadLocalRandom.current().nextInt(3)){ case 0: return toArray(a,b); case 1: return toArray(a,c); case 2: return toArray(b,c); } throw new AssertionError();} 3개의 parameter를 넘겨주고 그중 무작위로 선택된 2개의 배열을 반환받는 method가 있다고 가정했을떄 직접 실행해보면 runtime에 class cast exception이 터진다. 123public static void main(String[] args) { String[] strings = pickTwo(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); //ClassCastException} 그이유는 toArray(T..args) method에서 내부적으로 parameter를 받을 Object[] 배열을 만드는 코드를 생성하기 때문이다. 반환된 Object 배열은 client 측에서 compiler에 의해 String 배열로 자동 형변환된다.이떄 Object[]는 String[] 의 하위타입이 아니기 떄문에 형변환은 실패한다. 예외 @SafeVarargs로 제대로 annotation된 또 다른 varargs method에 Generic 배열을 넘기는 건 안전하다. Generic 배열 내용의 일부 함수를 호출만 하는 일반 method에 넘기는 것도 안전하다. 다음은 Generic 가변인수 매개변수를 안전하게 사용하는 예제이다. Generic 배열의 참조값을 반환하지도, Generic 배열에 값을 삼입하지도 않고 있다. 123456789@SafeVarargsstatic &lt;T&gt; List&lt;T&gt; flatten(List&lt;? extends T&gt; ... lists){ // List&lt;? extends T&gt;[] = lists; List&lt;T&gt; result = new ArrayList&lt;&gt;(); for (List&lt;? extends T&gt; list : lists) { result.addAll(list); } return result;} @SafeVarargs 작성 규칙 Generic이나 매개변수화 타입의 varargs 매개변수를 받는 모든 method에 @SafeVarargs를 달아야 사용자를 헷갈리게 하는 compiler 경고를 제거할 수 있다. @SafeVarargs annotation을 달기전에 타입 안전한지 (heap pollution은 없는지) 확인하고, 달아야 한다. 추가로 해당 method를 overriding시에도 타입 안전한지는 보장할수 없으므로, JDK 8에서부터는 overriding 불가능한 static method와 final method에만 붙일 수 있다. JDK9 부터는 private method에도 허용된다. 가변인수 대신 List 사용Generic 가변인수를 받는 method가 있을떄 타입안전한지 확인하고, overriding할수 없는 상태인지 확인하고 , @SafeVarargs를 붙여주는 방법도 있겠지만 그냥 List 타입으로 변경해주는 해결방안도 있다. 1234567static &lt;T&gt; List&lt;T&gt; flatten(List&lt;List&lt;? extends T&gt;&gt; lists){ List&lt;T&gt; result = new ArrayList&lt;&gt;(); for (List&lt;? extends T&gt; list : lists) { result.addAll(list); } return result;} client에서 flatten method에 값을 전달할떄는 List.of(…) method를 사용하면 된다. 이 방식의 장점은 개발자가 실수로 타입 안전하다고 잘못판단할 가능성이 없으며 , 단점은 client코드가 조금 지저분해진다는 단점을 가지고 있다. 또한 이방식은 이전 예제코드인 타입 불안전한 toArray method를 사용하지 않고, 우회할떄에도 사용가능하다. 12345678910111213static &lt;T&gt; T[] toArray(T...args){ return args;}static &lt;T&gt; T[] pickTwo(T a,T b ,T c){ switch (ThreadLocalRandom.current().nextInt(3)){ case 0: return toArray(a,b); case 1: return toArray(a,c); case 2: return toArray(b,c); } throw new AssertionError();} 이를 List.of(…)로 타입안전하게 변경하면 다음과 같이 변경할 수 있다. 12345678static &lt;T&gt; List&lt;T&gt; pickTwo(T a,T b ,T c){ switch (ThreadLocalRandom.current().nextInt(3)){ case 0: return List.of(a,b); case 1: return List.of(a,c); case 2: return List.of(b,c); } throw new AssertionError();} 정리가변인수에 Generic을 넣으면 내부적으로 Generic 배열이 생성되어 heap pollution이 발생하는 등 타입 안전하지 않을수도 있다. 따라서 Generic 배열의 참조를 반환하지 않고, 값도 넣지 않음을 확인하고 @SafeVarargs 을 붙이던지, 가변인수 자체를 제거하고 List로 변경하자.","link":"/2022/01/04/2022-01-04-Item32/"},{"title":"Entity 기본 키 매핑 전략 - SEQUENCE&#x2F;TABLE&#x2F;IDENTITY","text":"Entity - DB table mappingJpa를 사용해서 테이블과 매핑할 class를 @Entity를 필수로 붙여야하며, @Entity가 붙은 class를 entity라고 부른다. @Entity 적용 시 다음과 같은 전제조건을 만족해야한다. 기본생성자 final class , enum , interface , inner class가 아니여야 한다. 저장할 필드에 final 키워드가 붙으면 안된다. Jpa는 다양한 mapping annotation을 지원하는데 , 크게 4가지로 분류될 수 있다. 객체와 테이블 매핑 : @Entity , @Table 기본 키 매핑 : @Id Field와 Column 매핑 : @Column 연관관계 매핑 ex) @ManyTone , @JoinColumn 기본키 매핑 전략DB id값을 client측에서 넘겨줄 수 있겠지만, 인조키의 경우 DB vendor에서 생성할 수도 있다.DB vendor 마다 기본키를 생성하는 방식이 다르다, 예를 들면 oracle에서는 sequence 객체를 만들고, mysql에서는 auto_increment기능을 사용한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Provides for the specification of generation strategies for the * values of primary keys. * * &lt;p&gt; The &lt;code&gt;GeneratedValue&lt;/code&gt; annotation * may be applied to a primary key property or field of an entity or * mapped superclass in conjunction with the {@link Id} annotation. * The use of the &lt;code&gt;GeneratedValue&lt;/code&gt; annotation is only * required to be supported for simple primary keys. Use of the * &lt;code&gt;GeneratedValue&lt;/code&gt; annotation is not supported for derived * primary keys. * * &lt;pre&gt; * * Example 1: * * &amp;#064;Id * &amp;#064;GeneratedValue(strategy=SEQUENCE, generator=&quot;CUST_SEQ&quot;) * &amp;#064;Column(name=&quot;CUST_ID&quot;) * public Long getId() { return id; } * * Example 2: * * &amp;#064;Id * &amp;#064;GeneratedValue(strategy=TABLE, generator=&quot;CUST_GEN&quot;) * &amp;#064;Column(name=&quot;CUST_ID&quot;) * Long id; * &lt;/pre&gt; * * @see Id * @see TableGenerator * @see SequenceGenerator * * @since 1.0 */@Target({METHOD, FIELD})@Retention(RUNTIME)public @interface GeneratedValue { /** * (Optional) The primary key generation strategy * that the persistence provider must use to * generate the annotated entity primary key. */ GenerationType strategy() default AUTO; /** * (Optional) The name of the primary key generator * to use as specified in the {@link SequenceGenerator} * or {@link TableGenerator} annotation. * &lt;p&gt; Defaults to the id generator supplied by persistence provider. */ String generator() default &quot;&quot;;} 생성 전략은 @Id가 붙은 key 필드에 @GeneratedValue(strategy = “사용할 전략”) 을 명시해준다, 123456789101112131415161718192021222324252627282930313233public enum GenerationType { /** * Indicates that the persistence provider must assign * primary keys for the entity using an underlying * database table to ensure uniqueness. */ TABLE, /** * Indicates that the persistence provider must assign * primary keys for the entity using a database sequence. */ SEQUENCE, /** * Indicates that the persistence provider must assign * primary keys for the entity using a database identity column. */ IDENTITY, /** * Indicates that the persistence provider should pick an * appropriate strategy for the particular database. The * &lt;code&gt;AUTO&lt;/code&gt; generation strategy may expect a database * resource to exist, or it may attempt to create one. A vendor * may provide documentation on how to create such resources * in the event that it does not support schema generation * or cannot create the schema resource at runtime. */ AUTO} 생성 전략은 총 4개가 있는데 하나씩 정리하였다. 기본키 매핑 전략 - IDENTITYIDENTITY 전략은 기본 키 생성을 데이터베이스에 위임하는 전략으로, 주로 MySQL, PostgreSql , Sql server 에서 사용 한다. 예를 들어 MySQL vendor를 사용한다고 하면 DDL 의 key값에 auto_increment 가 추가된다. 1234567create table member ( id bigint not null auto_increment, age integer, name varchar(255), primary key (id)) engine=InnoDB 기본적으로 entity가 영속 상태가 되려면 식별자가 필요한데 IDENTITY 전략은 식별자의 생성 주체가 DB이기 때문에 DB에 entity를 저장하고 나서, 식별자를 조회할 수 있다. 때문에 식별자가 바로 필요하기 떄문에 em.persist(entity)로 저장을 하면 write buffering 이 일어나지 않고, 바로 query가 나가고 조회된 식별자로 영속성 컨텍스트에 entity를 보관한다. 1234567891011121314151617181920212223@Testpublic void createMember(){ EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); Member memberB = Member.builder() .age(20) .build(); Member memberA = Member.builder() .age(21) .build(); em.persist(memberA); System.out.println(&quot; ===== before write buffering ===== &quot;); em.persist(memberB); System.out.println(&quot; ===== transaction commit ===== &quot;); transaction.commit();} JDBC3 에서 추가된 Statement.getGeneratedKeys() API를 사용하면 데이터 저장과 동시에 생성된 기본키를 가지고 올 수 있는데 hibernate는 이 method를 사용하기 떄문에 entity를 저장한 직후에 식별자를 다시 조회하더라도 SELECT Query가 나가지 않는다 (DB와 한번만 요청을 주고 받는다.) 기본키 매핑 전략 - SEQUENCESEQUENCE 전략은 Oracle 처럼 DB내에서 유일한 값을 순서대로 생성하는 sequence 객체를 가진 경우, 이 sequence를 이용해서 기본키를 생성하는 전략이다. sequence 전략은 DB에 sequence 객체를 생성하고 매핑해주어야하는데 이를 Entity class내부에서 @SequnceGeneator 로 생성 및 매핑해줄 수 있다. 1234567891011121314151617@Entity@SequenceGenerator( name = &quot;member_seq_generator&quot;, sequenceName = &quot;member_seq&quot;, initialValue = 1 , allocationSize = 1)public class Member { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE , generator = &quot;member_seq_generator&quot;) private Long id; @Column(name = &quot;NAME&quot; ) private String username; private Integer age; 실제 나가는 query를 보면 다음과 같이 sequence object도 같이 생성된다. 1234567create sequence member_seq start with 1 increment by 1create table member ( id number(19,0) not null, age number(10,0), name varchar2(255 char), primary key (id) ) @SequenceGeneator의 주요속성은 다음과 같다. name : 식별자 생성기 이름 sequenceName : 시퀀스 이름 initialValue : 시퀀스 초기 시작값 allocationSize : 시퀀스 한번에 증가하는 수 default 50 내부 동작 방식은 IDENTITY 방식과 어떻게 다를까?실제 수행되는 query를 보면 다음과 같다. 앞선 IDENTITY 전략에서는 write buffering 없이, entity를 저장함과 동시에 쿼리가 나가서 DB 식별자값을 가지고 영속성 컨텍스트에 저장하는 원리였다면 SEQUENCE전략은 먼저 DB sequence 객체에서 식별자 값을 가져와 entity에 할당한뒤 영속성 컨텍스트에 저장한다.그 이후 transaction commit 시점에 flsuh 되어 insert query가 한꺼번에 나간다 (write buffering 있음) 정리하면 IDENTITY 전략은 entity 저장 후 식별자를 가져오는 방식임으로 write buffering 불가, SEQUENCE 전략은 entity 저장 전에 sequence 객체로부터 식별자를 가져와서 write buffering 수행한다 기본키 매핑 전략 - TABLETABLE 전략은 key 생성 전용 테이블을 하나 만들어서 DB Sequence를 흉내내는 전략이다. key 생성 전용 테이블은 Entity class에 @TableGenerator를 이용해 생성할 수 있다. 123456789101112@Entity@TableGenerator( name = &quot;member_seq_generator&quot;, table = &quot;member_seq&quot;, pkColumnName = &quot;seq&quot;, allocationSize = 1)public class Member { @Id @GeneratedValue(strategy = GenerationType.TABLE , generator = &quot;member_seq_generator&quot;) private String id; ddl-auto : create 로 설정하면 application 실행시 다음과 같은 query문이 나가는 것을 볼 수 있다. 1234567create table member_seq ( seq varchar(255) not null, next_val bigint, primary key (seq)) engine=InnoDBinsert into member_seq(seq, next_val) values ('member',0) @TableGenerator option에 대한 설명은 공식 레퍼런스에더 자세히 적혀있지만 https://docs.oracle.com/javaee/5/api/javax/persistence/TableGenerator.html 정리하면 다음과같다 . name (필수값) : 식별자 생성기 이름 table : table 명 pkColumnName : seq 컬럼명 valueColumnName : seq 값 컬럼명 initialValue : 초기값 allocationSize : 시퀀스 한번 호출시 증가하는 수로 성능최적화에 사용된다 default는 50 원리는 SEQUENCE전략과 동일하다.먼저 DB table의 key값을 조회(SELECT) 하고, 다음 값으로 증가시키기 위해 Update query가 나가므로 I/O통신을 2번한다.이후에 영속성 컨텍스트에 조회된 식별자값과 entity를 보관하고 있다가 transaction commit 시점에 한번에 flush 한다(write buffering) SEQUENCE,TABLE 전략 최적화SEQUENCE 전략은 sequence 객체로부터 먼저 식별자값을 조회한다.따라서 I/O 요청이 2번 일어난다. 이를 최적화하기 위해서 @SequenceGenerator( … ,allocationSize = x , …) 의 allocationSize값을 조정하여 메모리에 sequence 값을 할당해놓고 사용할 수 있다. sequence 값을 캐싱해놓고, DB에는 캐싱한 값까지는 I/O요청을 안보낸다. TABLE 전략도 마찬가지다. 대신 table전략에서는 말그대로 DB table을 생성해서 키값을 관리하는데, 이때 나가는 update query를 allocationSize값을 조정해서 최적화 할 수 있다. 기본키 매핑 전략 - AUTOAUTO 전략은 설정한 데이터베이스 방언에 따라 위 3가지 전략(IDENTITY/SEQUENCE/TABLE) 중에 한가지를 자동으로 선택한다. 개발 초기 단계시 활용될 수 있다. 1234567891011@Entitypublic class Member { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @Column(name = &quot;NAME&quot; ) private String username; private Integer age; DB 스키마 자동 생성 전략마지막으로 spring.jpa.hibernate.ddl-auto 속성에 따라 application이 실행될떄 DB 스키마 자동 생성 전략을 지정할 수 있다. 12345// application.yamlspring: jpa: hibernate: ddl-auto: create-drop 참고로 spring.jpa.hibernate.ddl-auto의 값은 hibernate 구현체의 hibernate.hbm2ddl.auto 속성 값으로 전달된다.(ref - https://stackoverflow.com/questions/42135114/how-does-spring-jpa-hibernate-ddl-auto-property-exactly-work-in-spring) spring.jpa.hibernate.ddl-auto에서 사용할 수 있는 전략은 4가지다. create : DROP + CREATE create-drop : DROP + CREATE , application 종료시 DROP update : 매핑 변경 사항만 수정 ex) alter table ~ validate : 실제 DB 스키마와 application entity간 매핑을 확인하고 일치하지 않으면 경고를 남기고 application은 실행하지 않는다. none Entity class에 제약조건 명시 다음과 같이 DDL 생성시 제약조건이나 타입 크기등을 조절할 수 있다. 123456789101112131415@Entity// unique 제약조건 추가 @Table(name = &quot;MEMBER&quot;,uniqueConstraints = {@UniqueConstraint( name = &quot;NAME_AGE_UNIQUE&quot;, columnNames = {&quot;NAME&quot;,&quot;AGE&quot;})})public class Member { @Id @Column(name = &quot;ID&quot;) private String id; // ddl : name varchar(10) not null, @Column(name = &quot;NAME&quot; , nullable = false , length = 10 ) private String username; private Integer age; 정리sequence , table 전략은 원리는 동일하지만 sequence object를 사용하느냐, table 을 사용하느냐의 차이이다.sequence , table 전략은 식별자를 가지고 와서 영속성 컨텍스트에 저장을 한다. I/O 요청이 allocationSize =1 이라고 하면 2번 나간다. write buffering이 가능하다. identity 전략은 식별자를 entity 저장시점에 알 수 있기 때문에 entity 저장시점에 바로 query가 나가서 entity를 먼저 저장하고 식별자 값을 가져와서 영속성 컨텍스트에 저장한다. I/O 요청이 1번 나간다 (hibernate의 경우에는) write buffering 이 불가능하다.","link":"/2022/01/05/2022-01-05-Jpa-Entity-Mapping/"},{"title":"Item 33. 타입 안전 이종 컨테이너를 고려하라","text":"Generic은 Collection과 단일 원소 컨테이너에서도 흔히 사용된다. 123Set&lt;E&gt;;Map&lt;K,V&gt;;ThreadLocal&lt;T&gt;; 이런 타입들의 경우 매개변수화되는 대상은 컨테이너 자신이다. 따라서 하나의 컨테이너에서 매개변수화 할 수 있는 타입의 수가 정해져있다. Type safe heterogeneous container pattern타입 안전 이종 컨테이너 패턴(Type safe heterogenous container pattern) 컨테이너 대신에 컨테이너의 키값을 매개변수하는 방식 일급 Collection : Collection을 Wrapping하면서, 그 외 다른 멤버 변수가 없는 상태로 Collection의 상태와 행위를 한곳에서 관리 (SRP) (ref- https://jojoldu.tistory.com/412) 12345678910111213public class Favorites { // collection의 key값을 매개변수화 private Map&lt;Class&lt;?&gt;,Object&gt; favorites = new HashMap&lt;&gt;(); // type token public &lt;T&gt; void putFavorite(Class&lt;T&gt; type,T instance){ favorites.put(Objects.requireNonNull(type),instance); } public &lt;T&gt; T getFavorite(Class&lt;T&gt; type){ return type.cast(favorites.get(type)); }} 타입 안전 이종 컨테이너 패턴의 예시로, 타입별로 주요 사용되는 객체를 저장하는 Favorites class 예시를 들 수 있다. wrapping되고 있는 collection의 key는 비한정적 wildcard type으로 어떤 class도 받을 수 있다. (실체화 불가 타입 제외 ex) List&lt;String&gt;.class) wrapping되고 있는 collection의 value는 object type으로 key와 value사이의 타입정보를 유지하지 않지만, getFavorite method에서 Class.cast() method를 통해 타입을 runtime에 동적으로 형변환해준다. 굳이 다음과 같이 형변환하지 않고 Class.cast() method를 사용해서 형변환하는 이유는 무엇일까? client에게 compiler 경고가 나오는데 Class.cast method는 타입 안전함을 확인하고 비검사 경고를 제거해주기 떄문이다. 1234567@SuppressWarnings(&quot;unchecked&quot;)@HotSpotIntrinsicCandidatepublic T cast(Object obj) { if (obj != null &amp;&amp; !isInstance(obj)) throw new ClassCastException(cannotCastMsg(obj)); return (T) obj;} getFavorite(Class&lt;T&gt; type) method는 container의 키와 타입 정보를 건네주는데, 이처럼 타입 정보를 알아내기 위해 건내주는 class literal을 type token이라고 한다. type token : compile time 타입 정보와 run time 타입 정보를 알아내기 위해 method간에 주고받는 class literal 1234567891011121314// 타입 안전 이종 컨테이너 - client public static void main(String[] args) { Favorites favorites = new Favorites(); favorites.putFavorite(String.class,&quot;Java&quot;); favorites.putFavorite(Integer.class,20); favorites.putFavorite(Class.class,Favorites.class); String favoriteStr = favorites.getFavorite(String.class); Integer favoriteInt = favorites.getFavorite(Integer.class); Class&lt;?&gt; favoriteClz = favorites.getFavorite(Class.class); System.out.printf(&quot;%s %d %s&quot;,favoriteStr,favoriteInt,favoriteClz.getName());} Type safe heterogeneous container pattern 제약사항현재 Favorite class의 제약은 다음과 같다. 악의적인 client가 generic이 아닌 raw type으로 넘기는 경우 타입 안전성이 꺠진다. 123Favorites favorites = new Favorites();favorites.putFavorite( ((Class) Integer.class),&quot;not generic type&quot;);// Integer result = favorites.getFavorite(Integer.class); ClassCastException ! 이를 해결하는 방안으로 값을 넣을떄에도 매번 동적 형변환하는 방법이 있다. 1234public &lt;T&gt; void putFavorite(Class&lt;T&gt; type,T instance){ favorites.put(Objects.requireNonNull(type),type.cast(instance));}// 값넣기이전에 ClassCastException이 터진다. 실체화 불가 타입에는 적용이 불가능하다. ex)List&lt;String&gt;.class 그 이유는 Generic간의 class는 같은 Class 객체를 공유하기 떄문이다. 예를 들어 List&lt;String&gt;.class와 List&lt;Integer&gt;.class 는 List.class라는 같은 Class객체를 공유한다. 추가적으로 현재 예제에서 사용하고 있는 Favorite class는 타입 token 에 제약이 없지만, 이를 한정적 타입매개변수로 제약할 수 있다. 1234// Number class 하위 타입의 타입매개변수를 가진 Generic만 넣을 수 있음. public &lt;T extends Number&gt; void putFavorite(Class&lt;T&gt; type,T instance){ favorites.put(Objects.requireNonNull(type),type.cast(instance));} java.lang.reflect.AnnotatedElement interface의 getAnnotation method는 명시한 타입의 annotation이 대상 요소에 달려있다면 그 annotation을 반환하고, 없다면 null을 반환한다. 한정적 타입매개변수로 입력 타입매개변수에 Annotation type만 오도록 하였다. favorites 예제와 유사하게 annotation된 요소는 key가 annotation 타입 매개변수임으로 타입 안전 이종 컨테이너라고 볼 수 있다. 12345678910111213/** * Returns this element's annotation for the specified type if * such an annotation is &lt;em&gt;present&lt;/em&gt;, else null. * * @param &lt;T&gt; the type of the annotation to query for and return if present * @param annotationClass the Class object corresponding to the * annotation type * @return this element's annotation for the specified annotation type if * present on this element, else null * @throws NullPointerException if the given annotation class is null * @since 1.5 */ &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass); 만약 Class&lt;?&gt; 타입의 객체를 getAnnotation method에 넘기려면 아래와 같이 Annotation type으로 한정적 타입매개변수로 형변환할 수 있겠지만, 이는 비검사임으로 compiler 경고가 뜬다. 1Class&lt;? extends Annotation&gt; clazz = (Class&lt;? extends Annotation&gt;) wildCardInstance; 형변환해주는 방법 대신에 Class 클래스에서 제공하는 asSubClass method를 활용하면 parameter로 넘어온 클래스로 형변환해줄 수 있다. 123456789static Annotation getAnnotation(AnnotatedElement element, String annotationTypeName){ Class&lt;?&gt; annotationType = null; try{ annotationType = Class.forName(annotationTypeName); } catch (Exception e) { throw new IllegalArgumentException(); } return element.getAnnotation(annotationType.asSubclass(Annotation.class));} 정리container (일급 collection) 자체를 generic class로 만드는 것보다 key 값만 generic으로 변경한 타입 안전 이종 컨테이너는 타입 제약에서 비교적 자유로우며, Class를 key 로 써서 값을 넣고 뺀다, 이떄 parmeter로 넘어오는 class literal을 type token이라고도 부른다.","link":"/2022/01/05/2022-01-05-Item33/"},{"title":"Junit5 Parameterized Test","text":"Parameterized Test1234567891011121314151617public class SetTest { private Set&lt;Integer&gt; numbers; @BeforeEach void setUp(){ numbers = new HashSet&lt;&gt;(); numbers.add(1); numbers.add(1); numbers.add(2); numbers.add(3); } @Test void contains() { assertThat(numbers.contains(1)).isTrue(); assertThat(numbers.contains(2)).isTrue(); assertThat(numbers.contains(3)).isTrue(); }} 위와 같이 Set의 API에 대한 학습테스트를 수행한다고 하였을떄 각 원소를 포함했는지 중복코드가 발생한다. Junit 5부터는 이를 ParameterizedTest 로 테스트에 여러개의 매개변수를 넣어주게 해줌으로써 테스트 코드 리팩토링을 원할하게 해준다. 필요한 library dependency는 다음과 같다. 12345678910// maven&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-params&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;//gradletestCompile(&quot;org.junit.jupiter:junit-jupiter-params:5.8.1&quot;) Argument Sourceparameterized test 에는 @ParameterizedTest annotaion을 명시하고 , 테스트할 매개변수들이 필요한데, Junit에서는 이를 @~source로 annotation에 입력값을 넣도록 제공하고 있다. ValueSource 다음과 같이 홀수를 판별하는 method가 있다고 가정하자. 12345public class Numbers { public static boolean isOdd(int number){ return number % 2 != 0; }} @ValueSource는 literal 값 타입의 매개변수를 전달해준다. 12345@ParameterizedTest@ValueSource(ints = {1, 3, 5, 7, 9})void isOdd_shouldReturnTrueForOddNum(int num){ assertThat(Numbers.isOdd(num)).isTrue();} 허용되는 타입은 다음과 같다. Supported types include shorts, bytes, ints, longs, floats, doubles, chars, booleans, strings, and classes. Note, however, that only one of the supported types may be specified per @ValueSource declaration. The supplied literal values will be provided as arguments to the annotated @ParameterizedTest method. @ValueSource는 null 을 매개변수로 전달할수 없다는 제약을 가지고 있다. NullSource null은 별도로 @NullSource annotaion을 통해 매개변수로 받을 수 있다. 12345@ParameterizedTest@NullSourcevoid isNull(String src){ assertThat(src).isNull();} EmptySource null 이 아닌 빈 문자열은 @EmptySource annotaion을 통해 매개변수로 받을 수 있다. 12345@ParameterizedTest@EmptySourcevoid isEmpty(String src){ assertThat(src).isEmpty();} @NullAndEmptySource 다음과 같이 null 또는 빈 문자열인지 판단하는 method가 있다고 가정하자 12345public class Strings { private static boolean isNullOrEmpty(String src){ return src == null || src.trim().isEmpty(); }} @NullAndEmptySource는 매개변수에 null과 빈문자열을 넣어준다 . (method가 2번 호출된다. ) src = null src = 12345@ParameterizedTest@NullAndEmptySourcevoid isNullOrEmpty(String src){ assertThat(Strings.isNullOrEmpty(src)).isTrue();} @ValueSource, @Null,EmptySource는 하나의 test에 같이 적용이 가능하다. 123456@Test@NullAndEmptySource@ValueSource(strings = { &quot;\\n&quot; , &quot; &quot;,&quot;\\t&quot;})void isNullOrEmpty(){ assertThat(isNullOrEmpty(&quot;\\n&quot;)).isTrue();} @EnumSource @EnumSource는 Enum타입 매개변수를 테스트에 넘겨줄떄 사용한다. name 속성값에 특정 Enum 만 명시할 수 있지만, 명시하지 않을 경우 전체 이넘이 넘어간다. 1234567@ParameterizedTest@EnumSource(Month.class)void getValueForAMonth_IsAlwaysBetweenOneAndTwelve(Month month){ System.out.println(&quot;month = &quot; + month); int monthNumber = month.getValue(); assertThat(monthNumber &gt;= 1 &amp;&amp; monthNumber &lt;= 12).isTrue(); } value속성에 Enum class 타입을 명시해주고, name 속성에 Enum 값을 넣어주면 해당 Enum들만 매개변수로 받을 수 있다 123456@ParameterizedTest@EnumSource(value = Month.class,names = {&quot;APRIL&quot;, &quot;JUNE&quot;,&quot;SEPTEMBER&quot;,&quot;NOVEMBER&quot;})void someMonths_Are30DaysLong(Month month){ final boolean isALeapYear = false; assertThat( month.length(isALeapYear)).isEqualTo(30);} mode 속성에 name 에 명시한 Enum 값을 포함할건지 제외할건지 옵션을 줄 수 있다. default는 포함이고 제외하고 싶다면 아래와 같이 EXCLUDE 옵션을 주면 된다. 12345678910@ParameterizedTest@EnumSource( value = Month.class, names = {&quot;APRIL&quot;,&quot;JUNE&quot;,&quot;SEPTEMBER&quot;,&quot;NOVEMBER&quot;,&quot;FEBRUARY&quot;}, mode = EnumSource.Mode.EXCLUDE)void exceptFourMonths_OthersAre31DaysLong(Month month){ final boolean isALeapYear = false; assertThat(month.length(isALeapYear)).isEqualTo(31);} @CsvSource csvSource 는 ,로 구분되는 입력값,예상결과값 문자열 배열을 받아서 매개변수로 넣어준다 {“입력값1,예상결과값1” , “입력값2,예상결과값2”} 와 같은 형식이다. 123456@ParameterizedTest@CsvSource({&quot;test,TEST&quot;,&quot;tEst,TEST&quot;,&quot;Java,JAVA&quot;})void toUpperCase_ShouldGenerateTheExpectedUppercaseValue(String input,String expected){ String actualValue = input.toUpperCase(); assertThat(actualValue).isEqualTo(expected);} , 로 구분되지 않고 다른 구분문자를 사용하고 싶으면 delimitter 옵션으로 변경할 수 있다. @MethodSource 복잡한 매개변수를 던질떄는 매개변수를 전달하는 부분을 별개의 method로 추출해서 @MethodSource에 method이름을 명시해주면 된다. 123456789@ParameterizedTest@MethodSource(&quot;argumentProvider&quot;) void isBlank_ShouldReturnTrueForNullOrBlankStringsOneArgument(String input){ Assertions.assertThat(isNullOrEmpty(input)); }private static Stream&lt;String&gt; argumentProvider() { return Stream.of(null, &quot;&quot;, &quot; &quot;); } 꼭 Argument stream 을 반환하지 않고, Argument의 List 등 collection interface를 반환해도 괜찮다. 123private static List&lt;Arguments&gt; argumentProvider() { return List.of(Arguments.of(null, &quot;&quot;, &quot; &quot;));} 정리Junit 5부터는 테스트 코드에서 매개변수를 받아 리팩토링 여지를 줄 수 있는 ParameterizedTest 를 제공한다. 입력값 또는 입력값에 대한 예상결과값을 별개의 annotation , method로 분리하여 매개변수로 전달해준다.","link":"/2022/01/05/2022-01-05-junit-Parameterized-test/"},{"title":"Item34. int 상수 대신 열거 타입을 사용하라","text":"Enum Type 정의Enum type은 일정 개수의 상수 값을 정의한 다음 그 외의 값들은 허용하지 않는 타입이다. Enum Type은 다음과 같은 특징을 가지고 있다. 1234public enum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY } (https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html) enum type 자체는 java.lang.Enum 추상 class를 상속받고 있는 class이다. (Java에서는 중복 상속이 불가하므로 다른 class는 상속받을 수 없다.) 12public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable { 상수당 자신의 instance를 하나씩 만들어 public static final 필드로 공개한다. (enum class내 상수는 public static final 필드와 같음 ) 외부에서 접근할 수 있는 생성자를 제공하지 않는다. 때문에 singleton은 원소가 하나뿐인 열거타입이라고도 볼 수 있다. Enum Type의 장점 안티 패턴인 정수 열거 패턴, 문자열 열거 패턴을 대체한다. 1234567891011// 정수 열거 패턴 public class Fruit { public static final int APPLE_FUJI = 0; public static final int APPLE_PIPPIN = 1; public static final int APPLE_GRANNY_SMITH = 2; public static final int ORANGE_NAVEL = 0; public static final int ORANGE_TEMPLE = 1; public static final int ORANGE_BLOOD = 2;} 정수 열거 패턴은 다음과 같은 단점을 가지고 있다. 타입 안전을 보장할 방법이 없다. (== 연산자로 비교) 프로그램이 깨지기 쉽다, 컴파일하면 상수 값이 그 client 파일에 그대로 쓰여지기 때문에 값이 바귀면 반드시 재컴파일해야 한다. 1234567// 문자열 열거 패턴 public class Operation { public static final String PLUS = &quot;+&quot;; public static final String MINUS = &quot;-&quot;; public static final String DIVIDE = &quot;/&quot;; public static final String MULTIPLY = &quot;*&quot;;} 문자열 열거패턴은 문자 상수 대신 문자 값을 그대로 하드코딩하는 개발자가 있는 경우 runtime error가 발생할 소지가 있다. compile time 타입 안전성을 제공한다. 다음과 같이 enum type을 method로 받는 경우 type 자체가 해당 enum type이 아니라면 compile error가 발생한다. 1void doSomething(Fruit fruit){} enum type에는 상수 필드마다 각자의 namespace 가 존재한다. 문자열 열거,정수 열거패턴과 다르게 enum class는 상수별로 객체화(싱글톤)되어 이름이 같은 상수도 공존할 수 있다. enum class 임의의 필드나 method를 추가할 수 있다. 더불어 상속하고 있는 java.lang.Enum type에서 이미 Object method를 구현해놓았으며, 기타 편의 method) 와 Comparable,Serializable도 구현해놓았다. 1234567891011121314151617public enum Season { WINTER(-5.1), SUMMER(23.1), SPRING(14.2), FALL(8.4); private final Double averageTemp; // 계절별 평균온도 Season(Double avgTemp){ this.averageTemp = avgTemp; } public Double avgTemp(){ return averageTemp; }} 12345Arrays.stream(Season.values()).forEach(season-&gt; System.out.println(season.name() + &quot; : &quot; + season.avgTemp() + &quot;C&quot;));// WINTER : -5.1// SUMMER : 23.1// SPRING : 14.2// FALL : 8.4 Enum Type을 어떻게 사용해야 하는가 널리쓰이는 enum type은 top-level class로 만들고, 특정 top-level class에서만 쓰인다면 해당 클래스의 member class로 만든다. 12345public class FileReader { enum Extension{ CSV,XLSX,TSV }} java library의 예시를 들면 소수 자릿수의 반올림 모드를 뜻하는 열거타입인 java.math.RoundingMode는 BigDecimal이 사용하는데, RoundingMode enum type 이BigDecimal과 관련 없는 영역에서도 유용한 개념이라 library 설계자는 RoudingMode를 top-level로 올림으로서 API 가 더 일관된 모습을 갖추도록 하였다. Enum type 상수마다 동작이 달라지는 코드 Enum type 상수마다 동작이 달라지는 경우 어떻게 코드를 구현하는게 좋을까 switch문 사용1234567891011121314public enum Operation { PLUS,MINUS,TIMES,DIVIDE; public double apply(double x , double y){ switch (this){ case PLUS:return x+y; case MINUS:return x-y; case TIMES:return x*y; case DIVIDE:return x/y; } throw new AssertionError(&quot;알 수 없는 연산: &quot; + this); }} 123public static void main(String[] args) { double result = Operation.PLUS.apply(1, 2);} switch문을 사용해서 구현하는 경우 단점은 다음과 같다. 연산이 추가될때마다 case문 내부 코드를 수정해야하는데, 수정하지 않아도 compile error가 뜨지 않는다. 상수별 메소드 구현 abstract method를 선언하고, 상수별로 재정의한다 1234567public enum Operation { PLUS{ public double apply(double x, double y) { return x+y;}}, MINUS{ public double apply(double x, double y) { return x-y;}}, TIMES{ public double apply(double x, double y) { return x*y;}}, DIVIDE{ public double apply(double x, double y) { return x/y;}}; public abstract double apply(double x, double y);} 상수별 method방식은 다음과 같은 장점을 갖는다. 상수별 메소드 구현 방식은 추상 method를 사용하므로, 특정 상수가 추상 method를 구현하지 않았다면 compile error를 띄워준다. 상수별 필드와 결합해서 사용가능하다. 1234567891011121314151617181920public enum Operation { PLUS(&quot;+&quot;){ public double apply(double x, double y) { return x+y;}}, MINUS(&quot;-&quot;){ public double apply(double x, double y) { return x-y;}}, TIMES(&quot;*&quot;){ public double apply(double x, double y) { return x*y;}}, DIVIDE(&quot;/&quot;){ public double apply(double x, double y) { return x/y;}}; private final String symbol; Operation(String symbol){ this.symbol = symbol; } @Override public String toString(){ return this.symbol; } public abstract double apply(double x, double y);} 위 예제는 Operation enum type에 연산자 문자를 필드로 추가로 받았다. 12345double x = Double.parseDouble(args[0]);double y = Double.parseDouble(args[1]);for (Operation op : Operation.values()) { System.out.printf(&quot;%f %s %f = %f \\n&quot;, x , op , y , op.apply(x,y));} 추가된 필드는 다음과 같이 재정의한 추상 method 와 함께 사용될 수 있다. toString 을 overriding할떄는 반대로 toString한 문자열로부터 Enum Type을 만들 수 있는 fromString 편의 method를 만드는 것을 고려할 수 있다. 12345678// key = symbol , value = Operation Enum type private static final Map&lt;String,Operation&gt; stringToEnum = Stream.of(values()). collect(toMap(Objects::toString,e-&gt;e));public static Optional&lt;Operation&gt; fromString(String symbol){ return Optional.ofNullable(stringToEnum.get(symbol));} 위 Operation Enum type이 stringToEnum map에 추가되는 시점은 열거 타입 상수 생성 후 정적 필드가 초기화될떄이다. enum type의 static 필드 중 enum type의 생성자에 접근할 수 있는 건 상수 필드 뿐이다. Jvm이 Jvm내부의 class loader system에 의해 enum class 의 bytecode가 Jvm이 OS로부터 할당받은 memory 영역 중 method 영역에 올라가고, class가 초기화될때 상수 필드(static field)가 가장 먼저 초기화 되고, 이후에 다른 static field가 초기화된다 –&gt; enum type 생성자 실행 시점에는 static field들이 초기화 되기 전이다.(ref - https://stackoverflow.com/questions/12639038/when-do-enum-instances-get-created) 상수별 method 구현 방식에는 enum type 상수끼리 코드를 공유하기 어렵다는 단점도 있다. 123456789101112131415161718192021public enum PayrollDay { MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY; public static final int MINS_PER_SHIFT = 8*60; int pay(int minutesWorked , int payRate){ int basePay = minutesWorked * payRate; int overTimePay; switch (this){ case SATURDAY: case SUNDAY: overTimePay = basePay / 2; break; default: overTimePay = minutesWorked &lt;= MINS_PER_SHIFT ? 0 : (minutesWorked - MINS_PER_SHIFT) * payRate / 2; } return basePay+overTimePay; }} 위 코드는 휴가와 같은 새로운 열거 타입이 추가되었을떄 case문에 추가해야한다. 이를 해결하기 위한 방안으로 책에서는 3가지를 제시하고 있다. 상수별로 중복 코드 삼입 (지양) 도우미 method를 작성해 각 상수가 자신에게 필요한 method를 적절히 호출 상수 추가시마다 전략 enum type을 선택하는, 전략 열거 타입 패턴. 아래 예시는 잔업수당을 계산하는 enum class인데, 요일별로 다른 잔업수당 계산 로직을 선택할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041public enum PayrollDay { MONDAY(PayType.WEEKDAY), TUESDAY(PayType.WEEKDAY), WEDNESDAY(PayType.WEEKDAY), THURSDAY(PayType.WEEKDAY), FRIDAY(PayType.WEEKDAY), SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND); private final PayType payType; PayrollDay(PayType payType){ this.payType = payType; } int pay(int minuteWorked , int payRate){ return payType.pay(minuteWorked,payRate); } enum PayType { WEEKDAY { int overtimePay(int minutesWorked, int payRate) { return minutesWorked &lt;= MINS_PER_SHIFT ? 0 : (minutesWorked - MINS_PER_SHIFT) * payRate / 2; } }, WEEKEND { int overtimePay(int mins, int payRate) { return mins * payRate / 2; } }; abstract int overtimePay(int minutesWorked, int payRate); public static final int MINS_PER_SHIFT = 8 * 60; int pay(int minutesWorked, int payRate) { int basePay = minutesWorked * payRate; return basePay + overtimePay(minutesWorked,payRate); } }} 이 패턴은 switch문 대신에 하위 enum class를 추가하였으므로, 요일별로 잔업 수당 계산 로직의 변경이 필요할 경우에는 상수의 잔업 수당 전략만 변경해주면 된다. 12// MONDAY(PayType.WEEKDAY) MONDAY(PayType.WEEKEND) // 월요일 연차 사용 ~ 앞선 예제들에서는 switch 문은 enum type의 상수별 동작을 구현하는데 적합하지 않다고 설명하였으나, 기존 enum type에 상수별 동작을 혼합해 넣을때는 switch문을 선택하는게 좋을떄도 있다. 예를 들면 외부 library에서 가져온 enum type 의 상수별 동작을 변경할떄이다. 123456789public static Operation inverse(Operation op){ switch (op){ case PLUS: return Operation.MINUS; case MINUS: return Operation.PLUS; case DIVIDE: return Operation.TIMES; case TIMES: return Operation.DIVIDE; default: throw new AssertionError(); }} Enum type 을 언제 사용해야 하는가 필요한 원소를 compile time에 알 수 있는 상수 집합인 경우 항상 Enum type을 사용할것을 권고한다. 또한 enum type에 추가로 상수를 정의하더라도 binary 수준에서 호환되도록 설계되었기 떄문에 enum type에 정의된 상수 개수가 영원히 고정 불변일 필요는 없다. 정리Enum Type은 정수 , 상수 열거 패턴보다 compile time에 타입 안전하며,Enum type 내 상수별로 다르게 동작하는 method가 필요할떄에는 enum class 에 추상 method를 선언해서 상수마다 method를 overriding해서 사용할 수 있다.상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 사용할 수 있다.","link":"/2022/01/06/2022-01-06-Item34/"},{"title":"Process","text":"Process concept program : disk 상에 존재하며, 명령어의 모음 process : program이 os로부터 메모리를 할당받아 실행중인 상태로 memory 부분이 code / data(전역변수,static 변수) / stack(지역변수,함수 매개변수,함수 return주소) / heap(malloc과 같은 system call을 호출하여 동적으로 할당되는 영역) 영역과 program counter 나뉜다 정확히 얘기하면 초기 OS 에서는 program의 전체 영역을 메모리에 올렸지만, 현대 OS에서는 필요한 영역만 메모리에 올리는 데 이 부분은 paging , swapping 과 관련된 개념이다. (ref - https://gabrieletolomei.wordpress.com/miscellanea/operating-systems/in-memory-layout/ ) Process State new state : process가 처음 메모리에 load된 상태 ready state : process가 cpu에 의해 실행될 수 있는 상태 ready state에서 OS의 scheduling 정책에 따라 cpu를 할당해줄 process를 선택한다. 선택된 process는 running state가 된다. running state : process가 cpu에 의해 실행되고 있는 상태 running state에서는 3가지 state로 분기할 수 있다. ready state : OS는 선점형 (pre-emptive) 방식으로 time quantuam (일반적으로 10ms) 간격으로 process가 termination state 가 되지 않으면 timer interrupt를 걸어준다. (Time sharing , 시분할 시스템 ) 따라서 timer interrupt 된 process는 다시 ready state가 된다. waiting state : process가 I/O 요청시 I/O응답이 오기전까지 CPU는 다른 process를 실행한다. I/O 작업 완료전까지는 waiting state가 되고, I/O 작업이 완료되면 다시 ready state가 된다. termination state: process가 time quantuam이내에 정상 수행 종료된다. 정상 상태는 아니지만 예외적인 process 상태가 있다. UNIX system 에서는 zombie process 라고 부르는데 부모 process 가 fork() system call을 통해 부모 process와 동일한 code를 가진 자식 process를 생성하면 , 자식 process 는 exec() system call을 통해 새로운 code로 덮어씌워진 뒤 실행된다. 부모 process는 자식 process가 종료될떄까지 기다리고 자식 process 가 사용한 resource를 os에게 회수를 요청한다 (reaping) 부모 process , 자식 process 종료가 비정상적으로 일어났을때 나타날수 있는 process 상태는 다음과 같다. zombie process : 자식 process가 비정상적으로 종료되어 부모 process는 waiting 중인 상태로 child process 의 resource가 반납이 안되고 있는 상태 부모 process가 kernel에게 resource 회수를 요청하지 못하고 있는 상태로 memory 누수현상이 발생한다. orphan process : 반대로 parent process 가 wait() 하지않고 종료된 경우 자식 process는 orphan process가 된다. Process 관련 자료구조 Process Control Block (PCB) : process 는 os에서 PCB라는 자료구조로 관리된다. 앞서 정리한 process state도 이 process control block 자료구조에 필드로 가지고 있다. PCB 에 포함된 필드들은 다음과 같다. PID (process id) process state program counter : process의 다음에 실행할 명령어를 가르키는 pointer cpu registers : process가 cpu에 의해 실행중일떄 cpu register 의 상태값을 저장해둔다. interrupt 되고나서 다시 rescheduling되었을때 process context를 복구하기 위해서 저장한다. CPU-scheduling information : process priority나 scheduling parameter 등을 저장한다. Memory-management information : base,limit register 값이나 page table 또는 segment table에 대한 참조값을 저장한다. I/O status information : 해당 process가 열고 있는 file 이나, process에 할당된 I/O Device 정보등을 저장한다.","link":"/2022/01/08/2022-01-08-os-process/"},{"title":"Item35. Enum type ordinal method 대신 member field를 사용하라","text":"Enum type의 ordinal method1234567891011121314/** * Returns the ordinal of this enumeration constant (its position * in its enum declaration, where the initial constant is assigned * an ordinal of zero). * * Most programmers will have no use for this method. It is * designed for use by sophisticated enum-based data structures, such * as {@link java.util.EnumSet} and {@link java.util.EnumMap}. * * @return the ordinal of this enumeration constant */public final int ordinal() { return ordinal;} 대부분 열거타입 상수는 하나의 정수값과 대응되는데, ordinal method는 특정 상수가 그 열거타입에서 몇번쨰 위치인지를 반환하는 method이다. 예를 들면 아래와 같이 합주단 종류 enum type내에서 몇번쨰 위치하고 있는지 알아낼때 사용한다. 123456789public enum Ensemble { SOLO,DUET,TRIO,QUARTET,QUINTET, SEXTET,SEPTET,OCTET,NONET,DECET; public int positionOfMusicians(){ return ordinal()+1; }} ordinal method의 단점 상수의 위치를 변경하면 해당 ordinal()출력값도 당연히 바뀐다. 이미 사용중인 상수와 값이 동일한 상수는 추가할 수 없다. 높은 상수 위치 값이 필요한 상황에서 값을 중간에 비워둘수가 없다.–&gt; 중간에 dummy 상수를 추가해주어야 작동한다. 전반적으로 유지보수성이 매우 떨어진다. ordinal method의 대체방안해당 상수의 위치값을 활용하고 싶으면, ordinal method 대신에 위치값을 멤버 필드로 가지고 반환하자. 12345678910111213public enum Ensemble { SOLO(1),DUET(2),TRIO(3),QUARTET(4),QUINTET(5), SEXTET(6),SEPTET(7),OCTET(8),DOUBLE_QUARTET(8), NONET(9),DECET(10),TRIPLE_QUATET(12); private final int position; Ensemble(int pos){ this.position = pos; } public int getPosition(){ return this.position; }}","link":"/2022/01/08/2022-01-08-Item35/"},{"title":"MVC pattern","text":"Model-View-Controller,MVC pattern은 사용자 인터페이스로부터 비즈니스 로직을 분리해서 application의 시각적인 요소에 변경사항이 비즈니스 로직에 영향없이 변경될 수 있도록 도와주는 패턴이다. MVC 패턴은 Model , View , Controller로 구성되는데 Model : application의 데이터 , bussiness logic , business rule 을 뜻한다.*Model 을 뷰에 담을 데이터라고 한정적 정의하는 경우도 있고 (ref- https://developer.mozilla.org/ko/docs/Glossary/MVC)dao , service 계층의 business logic 을 모두 포함해 model 이라고 하는 경우도 있습니다.(ref - https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)중요한 포인트는 UI와 application 비즈니스 로직을 분리시켜 서로 독립적으로 개발이 가능하도록 했다는 점입니다.dao, service , view에 대한 명확한 계층 구분은 multi-tier architecture에서 다루고 있습니다. (ref - https://en.wikipedia.org/wiki/Multitier_architecture) View : 사용자 인터페이스 요소 (UI) Controller : Model과 View 사이의 상호동작을 관리한다. 사용자의 요청에 따라 모델/뷰를 업데이트한다. MVC 패턴 특징 사용자는 View 랑만 상호작용한다. view는 모델을 보여주는 사용자 인터페이스로서 , 사용자가 view에 어떤 작업을 했을때 controller에게 사용자가 어떤 일을 했는지 알려주고, 사용자가 상황에 맞게 작업을 처리한다. Controller에서 Model에게 상태변경을 요청한다. Controller는 사용자의 요청에 따라 Model을 어떤식으로 조작하는지 결정하고 처리한다. Controller에서 View를 변경해달라고 요청할 수 있다. View에서 Model에게 상태를 요청한다. Model 1 Architecture , Model 2 (MVC) Architecture model1 과 model2(MVC)로 나뉜다. Model 1 model1은 view에 controller logic이 섞여있다. template engine으로 jsp를 사용한다고 하면 한 jsp 페이지에서 다른 jsp 페이지로 갈때, 해당 페이지에서 controller + view 기능을 모두 하는 것이다. DB 데이터를 가져올 경우에는 JavaBean 객체, 주로 Dao (Data access object) 로부터 DB로부터 데이터를 받아, 받은 데이터를 Dto (Data transfer object, 계층간 데이터 교환을 위한 객체) 에 매핑해주어서 가져온다. 예시용 코드를 보면 view에 controller 로직이 포함되어 있음을 확인할 수 있다. 1234567891011121314151617181920212223// example toy code &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ page import=&quot;boardmanage.*&quot; %&gt; &lt;% String title = request.getParameter(&quot;title&quot;); String content =request.getParameter(&quot;contents&quot;); Board board=new Board(); board.setTitle(title); board.setContent(content); BoardDao dao=new BoardDao(); dao.save(board); %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; 등록되었습니다. &lt;a href=&quot;list.jsp&quot;&gt;목록으로 가기&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; Model 1의 장점 구조가 단순하며, 정말 작은 프로젝트 수행 시 빠른 개발 속도 Model 1의 단점 계층간 분할 , 모듈이 세분화되어 동작하는 시스템이 아니기떄문에 테스트 코드를 짜기힘듬 유지보수 힘듬UI와 controller간에 변경이 동시에 발생하지 않는다. UI만 변경될 수도 있는데, 동일한 파일에 변경되는 부분 변경되지 않는 부분만 섞여있기 때문에 유지보수가 힘들다는 것이다. Model 2 model2는 controller , view , model을 모두 모듈화한 구조로, controller (servlet) 이 사용자 요청을 받아, 적합한 model 을 실행시키고, 데이터를 담는다 , view를 forwarding 또는 redirect 해준다. 추가로 forward와 redirect의 차이점은 다음과 같다. redirect : client가 재요청 forward : 서버내부에서 view rendering 해서 client에게 보여줌 (client는 forwarding여부를 모른다.) 12345678910111213141516171819202122@WebServlet(name = &quot;mvcMemberSaveServlet&quot;, urlPatterns = &quot;/members/save&quot;)public class MvcMemberSaveServlet extends HttpServlet { private MemberRepository memberRepository = MemberRepository.getInstance(); @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String username = request.getParameter(&quot;username&quot;); int age = Integer.parseInt(request.getParameter(&quot;age&quot;)); Member member = new Member(username, age); memberRepository.save(member); //Model request.setAttribute(&quot;member&quot;, member); String viewPath = &quot;/WEB-INF/views/save-result.jsp&quot;; RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request, response); }} 위 예제 코드처럼 controller가 사용자 요청을 받아 적합하게 model을 업데이트하고, view로 forwarding 해주는 것을 볼 수 있다. MVC pattern의 장점 모듈이 세분화되어 독립적으로 개발이 가능하다 확장 용이성 유지 보수성 model1 에 비해 코드 가독성 등 MVC pattern의 한계점 controller가 많아질 경우 여러 controller에서 공통으로 처리해야 할 로직이 중복된다. 이러한 한계점을 보완하기 위해 나온게 front controller pattern인데, 쉽게 정리하면 여러 controller 앞단에서 동작할 main controller를 하나 두는 방식으로 spring framework에서 바로 front controller pattern을 사용하고 있다. MVC 패턴기반의 다른 디자인 패턴MVC 에 기반을 둔 몇 가지 다른 디자인 패턴으로는 MVVM (모델-뷰-뷰모델), MVP (모델-뷰-프리젠터), MVW (모델-뷰-왓에버) 가 있다.","link":"/2022/01/08/2022-01-08-MVC-pattern/"},{"title":"packet switching","text":"network 구성 요소 network edge : application (ex) web server ) , host network core : routers communication link : network 구성요소들을 이어주는 물리적인 cable protocol 둘 이상의 통신 개체간에 교환되는 메시지 포맷과 순서뿐 아니라 , 메시지의 송수신과 다른 이벤트에 따른 행동들을 정의한다. (통신매체간 통신 규약) network core 내 router간 데이터 교환 방식 circuit switching (회선 교환) 종단 system (network edge)간에 통신을 제공하기 위해 경로상에 필요한 자원 (link 전송률,buffer)를 통신 기간동안 미리 확보(예약) 해두는 방식 packet switching(패킷 교환) : 현재 인터넷에서 사용중인 방식 circuit switching 방식과는 다르게 on-demand방식으로 네트워크 자원을 사용하기 떄문에 더 많은 사용자 수용가능 송신측은 송신할 데이터를 packet이라고 하는 단위로 분할해서 송신. router 에서 packet을 store-and-forwarding transmission (저장-후-전달 전송) 방식으로 전달함 sources of packet delay router에서 packet을 받고난뒤에 packet를 queue에 저장하고, packet의 목적지를 확인해서 다음 hob(router)에 forwarding하는데 packet delay로 인해 router내 packet queue가 꽉차면 packet loss가 생길 수 있다. 예를 들면 해당 router로 도착하는 packet은 router 내 queue에 저장되고 한 link로 전송되야하는데 해당 link에 이미 다른 packet이 전송중이라면 queue에 대기해야 하는데 queue가 꽉차면 packet이 소실될 수 있다는 말이다. Nodal processing delay : packet 검사해서 bit error가 있는지 확인하고 , 적절한 output link 를 결정 Queuing delay : pakcet이 queue 에서 transmission 되기 전까지 기다리는 시간 Transimission delay : packet (bit 집합) 의 첫번쨰 bit부터 마지막 bit 까지 출력링크로 나가는데 걸리는 시간 Transmission delay 는 다음과 같이 정의된다. Transmission delay = L/R (L : packet lenghts (bits) , R = link bandwidth(bps,전송률)) 4. Propagation delay : 다음 router까지 packet이 전송되는 시간으로 link 길이에 비례","link":"/2022/01/09/2022-01-09-network-packet-switching/"},{"title":"Front Controller Pattern","text":"Front controller patternfront controller pattern 은 주로 web 환경에서 client 요청이 들어오면 먼저 공통적인 로직을 처리하는 하나의 controller를 두고, 해당 controller가 적합한 controller 를 호출하는 패턴이다. front controller의 정확한 정의는 다음과 같다. Front Controller is defined as “a controller that handles all requests for a Web site”. It stands in front of a web-application and delegates requests to subsequent resources. It also provides an interface to common behavior such as security, internationalization and presenting particular views to certain users (ref - https://www.baeldung.com/java-front-controller-pattern) Front controller pattern의 장점 front controller 가 결국 모든 controller이전에 수행됨으로 controller에서 발생할 수 있는 공통로직을 front controller에서 처리하고, 중복코드를 제거하고 유지보수성을 높여준다. front controller를 제외한 나머지 controller는 servlet을 사용하지 않아도 된다. Front controller pattern 은 MVC pattern과 함께 자주 쓰인다. 대표적으로 spring framework에서 사용하고 있으며,org.springframework.servlet.dispatcherServlet이 front controller이다. UML diagram front controller pattern은 front controller와 요청을 위임할 class (controller) 로 구성된다. 이떄 요청을 위임할 class는 공통 abstract class 또는 interface를 상속하고 있다. 예시UML diagram에서 AbstractCommand 클래스 위치가 Controller 이다. FrontController는 member field로 구현체가 아닌 Controller 인터페이스 (DIP)를 value가 가진 hashMap을 가지고 있다, FrontController가 client 요청 URI를 보고 적합한 controller를 찾아서 호출해주고, controller에서 반환되는 viewName을 활용해 rendering 해주는 기능을 가지고 있다. 123public interface Controller { String process(Map&lt;String, String&gt; paramMap, Map&lt;String, Object&gt; model);} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@WebServlet(name = &quot;frontController&quot;,urlPatterns = &quot;/&quot;)public class FrontController extends HttpServlet { private Map&lt;String , Controller&gt; controllerMap = new HashMap&lt;&gt;(); private static final String EXTENSION = &quot;.jsp&quot;; private static final String VIEW_PATH = &quot;/WEB-INF/views/&quot;; public FrontController(){ controllerMap.put(&quot;/front-controller/members/new-form&quot;,new MemberFormController()); controllerMap.put(&quot;/front-controller/members/save&quot;,new MemberSaveController()); controllerMap.put(&quot;/front-controller/members&quot;,new MemberListController()); } @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String requestURI = request.getRequestURI(); Controller controller = controllerMap.get(requestURI); if (controller == null) { response.setStatus(HttpServletResponse.SC_NOT_FOUND); return; } Map&lt;String, String&gt; paramMap = createParamMap(request); Map&lt;String, Object&gt; model = new HashMap&lt;&gt;(); //추가 String viewName = controller.process(paramMap, model); MyView view = viewResolver(viewName); view.render(model, request, response); } private MyView viewResolver(String viewName) { return new MyView(VIEW_PATH + viewName + EXTENSION); } private Map&lt;String, String&gt; createParamMap(HttpServletRequest request) { Map&lt;String, String&gt; paramMap = new HashMap&lt;&gt;(); request.getParameterNames().asIterator() .forEachRemaining(paramName -&gt; paramMap.put(paramName, request.getParameter(paramName))); return paramMap; }} 12345678910111213141516171819202122public class MyView { private String viewPath; public MyView(String viewPath) { this.viewPath = viewPath; } public void render(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request, response); } public void render(Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { modelToRequestAttribute(model, request); RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request, response); } private void modelToRequestAttribute(Map&lt;String, Object&gt; model, HttpServletRequest request) { model.forEach((key, value) -&gt; request.setAttribute(key, value)); } Spring의 Front Controllerspring은 front controller를 org.springframework.web.servlet.DispatcherServlet 으로 제공한다.(https://docs.spring.io/spring-framework/docs/3.0.0.M4/reference/html/ch15s02.html)Dispatcher servlet은 controller를 바로 호출하는게 아니라 adapter를 호출함으로서 다른 종류의 interface를 구현한 클래스라고 할지라도 ModelAndView를 반환하게 해준다.interface별로 adapter 구현체를 가져서 interface의 반환값이 무엇이든 adapter가 중간에서 Front Controller에서 사용할 modelAndView를 반환하게 해주는 것이다.( adapter 와 관련된 자세한 내용은 GOF- Adapter pattern 에 나와있다. ) DispatcherServlet은 HttpServlet을 상속받고 있으며, doService -&gt; doDispatch -&gt; handlerAdapter 을 찾아 호출한다. 12345678910111213141516171819public class DispatcherServlet extends FrameworkServlet{ @Override protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception { //... try { doDispatch(request, response); } finally { if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) { if (attributesSnapshot != null) { restoreAttributesAfterInclude(request, attributesSnapshot); } } ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request); } }} DispatcherServlet 내부구현doDispatch 내부 로직을 보면 adapter를 찾아서 , modelAndView로 반환해주는 것을 볼 수 있다. 123456protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception{ //... // Actually invoke the handler. ModelAndView mv=ha.handle(processedRequest,response,mappedHandler.getHandler()); //... } 반환된 modelAndView에서 view 이름을 가져와서 resolveView method를 통해 view resolver가 view 이름으로부터 실제 view객체를 반환해준다. 123456789String viewName = mv.getViewName();if (viewName != null) { // We need to resolve the view name. view = resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) { throw new ServletException(&quot;Could not resolve view with name '&quot; + mv.getViewName() + &quot;' in servlet with name '&quot; + getServletName() + &quot;'&quot;); }} 12345678910111213141516171819202122232425262728 /** * Resolve the given view name into a View object (to be rendered). * &lt;p&gt;The default implementations asks all ViewResolvers of this dispatcher. * Can be overridden for custom resolution strategies, potentially based on * specific model attributes or request parameters. * @param viewName the name of the view to resolve * @param model the model to be passed to the view * @param locale the current locale * @param request current HTTP servlet request * @return the View object, or {@code null} if none found * @throws Exception if the view cannot be resolved * (typically in case of problems creating an actual View object) * @see ViewResolver#resolveViewName */@Nullableprotected View resolveViewName(String viewName, @Nullable Map&lt;String, Object&gt; model, Locale locale, HttpServletRequest request) throws Exception { if (this.viewResolvers != null) { for (ViewResolver viewResolver : this.viewResolvers) { View view = viewResolver.resolveViewName(viewName, locale); if (view != null) { return view; } } } return null; } view resolver가 하는 일은 view name에 prefix,suffix 설정해준다 (경로 설정)최종적으로 view객체를 사용해 model과 함께 rendering 해준다. 1view.render(mv.getModelInternal(), request, response); 실제 DispatcherServlet 내부구현은 휠씬복잡한데, 이중에서 adapter가 ModelAndView 객체를 반환해주고,반환된 ModelAndView의 view 이름으로부터 view resolver가 실제 사용할 View 객체를 반환해서 model과 함께 rendering해주는 주요 코드부분을 가져왔다.","link":"/2022/01/09/2022-01-09-front-controller-pattern/"},{"title":"Item36. 비트 필드 대신 EnumSet을 사용하라","text":"열거한 값들이 주로 집합으로 사용될 경우, 예전에는 각 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용해왔다. 다음과 같이 비트별 OR를 사용해 여러 상수를 하나의 집합으로 모을 수 있으며, 이렇게 만들어진 집합을 bit field라 한다. 12345678910public class Text { public static final int STYLE_BOLD = 1 &lt;&lt; 0; public static final int STYLE_ITALIC = 1 &lt;&lt; 1; public static final int STYLE_UNDERLINE = 1 &lt;&lt; 2; public static final int STYLE_STRIKETHROUGH = 1 &lt;&lt; 3; // 매개변수 styles는 0개 이상의 STYLE_상수를 비트별 OR한 값 public void applyStyles(int styles){...}} bit field의 문제점은 비트별 연산을 통해 집합 연산은 효율적으로 수행할 수 있으나, 정수 열거 상수의 단점들에 추가로 비트 필드값이 그대로 출력되면 해석하기 더 어렵다는 단점이 있다. EnumSet비트 필드의 대안으로 EnumSet class는 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현해준다. (내부는 비트 벡터로 구현되어 있다. ) 12345public class Text { public enum Style { BOLD,ITALIC,UNDERLINE,STRIKETHROUGH} public void applyStyles(Set&lt;Style&gt; styles){}} 1text.applyStyles(EnumSet.of(Style.ITALIC, Style.UNDERLINE));","link":"/2022/01/11/2022-01-11-Item36/"},{"title":"Item37. ordinal indexing 대신 EnumMap을 사용하라","text":"다음과 같이 식물 class가 있고 이 class를 LifeCycle enum type을 key로 set에 분류해서 담고 싶다고 가정하자. 1234567891011121314151617public class Plant { enum LifeCycle{ANNUAL,PERENNIAL , BIENNIAL} final String name; final LifeCycle lifeCycle; public Plant(String name, LifeCycle lifeCycle) { this.name = name; this.lifeCycle = lifeCycle; } @Override public String toString() { return name; }} 한가지 방법은 Set 배열에 ordinal method()로 가져온 LifeCycle Enum type의 index 값으로 배열에 indexing 해 저장하는 것이다. 1234567891011Set&lt;Plant&gt;[] plantsByLifeCycle = (Set&lt;Plant&gt;[]) new Set[Plant.LifeCycle.values().length];for(int i = 0 ; i &lt;plantsByLifeCycle.length; i++){ plantsByLifeCycle[i] = new HashSet&lt;&gt;();}for (Plant p : garden) { plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);}for(int i = 0; i&lt; plantsByLifeCycle.length ; i++){ System.out.printf(&quot;%s: %s %n&quot;, Plant.LifeCycle.values()[i],plantsByLifeCycle[i]);} 위 코드는 다음과 같은 문제점을 가지고 있다. Generic 배열 : 타입안전하지 않음 배열은 각 Index가 무슨 Enum type인지 모름 상수의 위치가 변경될 경우 바로 고장남 (Item 35. ordinal() method는 사용하지 말라고 권고 ) EnumMapEnumMap을 쓰면 위와 같이 ordinal method로 indexing 하는 단점을 제거해주고, 추가로 출력 문자열도 자체로 제공해준다.EnumMap은 runtime에서 generic type 정보 제공을 위해 생성자에서 key 로 사용할 class 객체를 받는다. 12345678Map&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt; plantsByLifeCycle = new EnumMap&lt;&gt;(Plant.LifeCycle.class);for(Plant.LifeCycle lc : Plant.LifeCycle.values()){ plantsByLifeCycle.put(lc,new HashSet&lt;&gt;());}for (Plant p : garden) { plantsByLifeCycle.get(p.lifeCycle).add(p);}System.out.println(&quot;plantsByLifeCycle = &quot; + plantsByLifeCycle); Stream 방식아래와 같이 stream을 사용해서 맵을 관리하면 코드를 더 줄일 수 있으나,EnumMap 구현체를 사용한게 아니라 고유한 Map 구현체를 사용했기 때문에 공간과 성능 이점이 사라진다. EnumMap 은 항상 enum 당 하나의 중첩 map을 만들지만, stream은 해당 enum type이 있을때에만 만든다. 12Map&lt;Plant.LifeCycle, List&lt;Plant&gt;&gt; result = garden.stream().collect(Collectors.groupingBy(Plant::getLifeCycle)); groupBy의 2번쨰 parameter인 결과가 삼입될 map을 다음과 같이 EnumMap 객체를 생성해주는 람다식을 넣어주면 EnumMap 객체의 장점을 활용할 수 있다. 1garden.stream().collect(groupingBy(Plant::getLifeCycle,()-&gt;new EnumMap&lt;&gt;(LifeCycle.class),toSet())); 추가로 3개의 parameter 를 받는 groupBy Function의 1번쨰 parameter는 분류 방식, 2번쨰 parameter는 결과가 삼입될 빈 Map 객체를 반환해주는 supplier , 3번째 parameter는 결과를 집계해줄 collector를 받는다. 123Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream) ordinal method를 사용하는 안좋은 예를 또 들면, 두 가지 상태(Phase) Enum 를 전이(Transition) Enum과 매핑하도록 구현한 프로그램이다. 12345678910111213141516171819public enum Phase { SOLID, LIQUID , GAS; public enum Transition{ MELT,FREEZE,BOIL,CONDENSE,SUBLIME,DEPOSIT; // 행은 from의 ordinal 을 , 열은 to의 ordinal을 index로 사용한다. public static final Transition[][] TRANSITIONS = { {null,MELT,SUBLIME}, {FREEZE,null,BOIL}, {DEPOSIT,CONDENSE,null} }; // 한 상태에서 다른 사앹로의 전이를 반환한다. public static Transition from(Phase from, Phase to){ return TRANSITIONS[from.ordinal()][to.ordinal()]; } }} 마찬가지로 ordinal method는 위에 설명한 이유들로 사용하면 안된다.이를 EnumMap으로 다음과 같이 구현할 수 있다. 아래는 중첩 map으로 &lt;이전상태,&lt;이후상태,전이&gt;&gt; 형태로 EnumMap을 초기화하였다. 12345678910111213141516171819202122232425262728293031public enum Phase {SOLID, LIQUID , GAS;public enum Transition { MELT(SOLID,LIQUID),FREEZE(LIQUID,SOLID), BOIL(LIQUID,GAS),CONDENSE(GAS,LIQUID), SUBLIME(SOLID,GAS),DEPOSIT(GAS,SOLID); private final Phase from; private final Phase to; Transition(Phase from, Phase to) { this.from = from; this.to = to; } public Phase getFrom() { return from; } public static final Map&lt;Phase, Map&lt;Phase,Transition&gt;&gt; m = Stream.of(values()).collect( groupingBy(Transition::getFrom, ()-&gt;new EnumMap&lt;&gt;(Phase.class), toMap( t-&gt;t.to, t-&gt;t, (x,y)-&gt;y, ()-&gt;new EnumMap&lt;&gt;(Phase.class) )));} groupBy method에서 이전 상태를 기준으로 묶고, 이를 결과로 받을 EnumMap을 생성하고, 다시 Map으로 집계하는데, Map으로 집계할때는 다음과 같이 4개의 parameter가 사용되었다. 123456 toMap( t-&gt;t.to, // 이후 상태를 key로 사용 t-&gt;t, // value는 전이값 (x,y)-&gt;y, // 동일 key 시 처리 로직인데, 실제로는 사용되지 않음 ()-&gt;new EnumMap&lt;&gt;(Phase.class) // 결과를 담을 빈 Map 객체 생성 ) toMap method api 설명을 보면 첫번쨰 parameter는 key를 생성해주는 함수, 두번쨰는 value를 생성해주는 함수 , 세번째는 같은 key 를 가지는 value를 어떻게 merge 할지에 대한 처리로직, 네번쨰는 결과가 삼입될 빈 map 객체를 만들어주는 함수를 작성하면 된다고 한다. 이전 oridinal method 방식에 비해 요구사항이 변경되었을때도 map을 생성하는 로직이 변경되지 않는다. 1234567891011public enum Phase { SOLID, LIQUID , GAS , PLASMA; public enum Transition { MELT(SOLID,LIQUID),FREEZE(LIQUID,SOLID), BOIL(LIQUID,GAS),CONDENSE(GAS,LIQUID), SUBLIME(SOLID,GAS),DEPOSIT(GAS,SOLID), IONIZE(GAS,PLASMA),DEIONIZE(PLASMA,GAS); // ...코드 변경되지 않음 }}","link":"/2022/01/11/2022-01-11-Item37/"},{"title":"Item39. 명명패턴보다는 annotation을 사용하라","text":"도구나 프레임워크가 특별히 다뤄야 할 프로그램 요소에는 구분되는 명명 패턴을 적용해왔다 예를 들면 JUnit 은 버전 3까지 테스트 method 이름을 test로 시작하게끔 하였다. 명명패턴의 단점명명 패턴의 단점은 다음과 같다. 오타시 runtime 예외가 발생 올바른 프로그램 요소에 사용됨을 보장하지 못함 예를 들면 클래스 이름에 TestSafetyMechanism이라고 명명한다고 하여도 해당 class에 있는 method들은 실행되지 않는다.3. 매개변수 전달 방법이 없음 특정 예외가 터져야 성공하는 test가 있을때 매개변수로 예외 class type을 전달해줄수 없다. AnnotaionJunit 4부터는 annotation을 명명패턴 대신에 도입하였다. annotation에 관한 기본내용은 다음과 같다. Meta-annotation : @Retention, @Target과 같은 annotation 선언에 다는 annotation @Retention SOURCE : 소스코드까지만 annotation이 남아있고, compiler에 의해 .class file에는 제거된다. CLASS : class file 까지 남아있고, run time 시에는 사라진다. (reflection 불가) , default값 RUNTIME : run time까지도 남아있는다. 1234567891011121314151617181920package java.lang.annotation;public enum RetentionPolicy { /** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * / RUNTIME} @Target : annotation이 적용될 target 요소를 설정해준다. (The constants ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE, and TYPE_PARAMETER correspond to the declaration contexts in JLS 9.6.4.1.) @Documented : 해당 annotation을 Javadoc에 포함시킨다. @Inherited : 자식 class가 해당 annotation을 가지는 부모 class로부터 annotation을 상속받도록 한다. Marker annotation : 아무런 데이터도 가지지 않는 annotation Test Framework 에서 annotation 활용1234567/*** * Test method임을 선언하는 annotation으로 매개변수없는 정적 method 전용이다. */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Test {} @Test annotation을 테스트하고자 하는 method에 추가하였다. 123456789101112131415public class Sample { @Test public static void m1(){} public static void m2(){} @Test public static void m3(){ throw new RuntimeException(&quot;fail&quot;); } public static void m4(){} @Test public void m5(){} // not static method public static void m6(){} @Test public static void m7(){ throw new RuntimeException(&quot;fail&quot;); } public static void m8(){}} @Test를 붙은 method를 테스트하는 프로그램은 다음과 같이 작성될 수 있다. 123456789101112131415161718192021222324public class RunTests{ public static void main(String[] args) throws ClassNotFoundException { int tests = 0; int passed = 0; Class&lt;?&gt; testClass = Class.forName(&quot;study.effectivejv.ch03.item39.Sample&quot;); for (Method m : testClass.getDeclaredMethods()) { // annotation이 붙어있는지 확인 if(m.isAnnotationPresent(Test.class)){ tests++; try{ m.invoke(null); // 예외가 터지지 않으면 정상적으로 pass++ passed++; } catch (InvocationTargetException e) { Throwable exc = e.getCause(); System.out.println( m + &quot; 실패:&quot; + exc); } catch (Exception e) { System.out.println(&quot;잘못 사용한 @Test: &quot; + m ); } } } System.out.printf(&quot;성공 : %d . 실패: %d \\n&quot;,passed,tests-passed); }} 만약 특정 예외를 던지는 경우 성공한것으로 간주하려면 Throwable을 확장한 클래스 객체를 매개변수로 받는 새로운 annotation이 필요하다 123456//예외를 매개변수로 받는 annotation type @Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface ExceptionTest { Class&lt;? extends Throwable&gt; value();} 12345678910111213141516171819//Test 대상 classpublic class Sample2 { @ExceptionTest(ArithmeticException.class) public static void m1(){ int i = 0; i = i/ i; //success } @ExceptionTest(ArithmeticException.class) public static void m2(){ int[] a= new int[0]; int i = a[1]; // fail } @ExceptionTest(ArithmeticException.class) public static void m3(){ // fail }} 아래 코드에서는 Exception annotation의 매개변수값 (예외 class 객체) 를 가져와서, 실제로 발생한 예외와 일치하는 지 확인하는 로직이 추가로 들어가 있다. 12345678910111213141516171819202122Class&lt;?&gt; testClass = Class.forName(&quot;study.effectivejv.ch03.item39.Sample2&quot;);for (Method m : testClass.getDeclaredMethods()) { if(m.isAnnotationPresent(ExceptionTest.class)){ tests++; try{ m.invoke(null); System.out.printf(&quot;테스트 %s 실패 : 예외를 던지지 않음. \\n&quot; , m); } catch (InvocationTargetException e) { Throwable exc = e.getCause(); Class&lt;? extends Throwable&gt; excType = m.getAnnotation(ExceptionTest.class).value(); if(excType.isInstance(exc)){ passed++; }else{ System.out.printf(&quot;테스트 %s 실패 : 기대한 예외 %s , 발생한 예외 %s \\n&quot; , m ,excType.getName() , exc); } } catch (Exception e) { System.out.println(&quot;잘못 사용한 @ExceptionTest: &quot; + m ); } }}System.out.printf(&quot;성공 : %d . 실패: %d \\n&quot;,passed,tests-passed); 조금 더 응용해 하나의 예외가 아니라 배열로 매개변수를 받아서, 여러개의 예외 class 객체중 하나만 일치하여도 성공할 수 있게 만들 수 있다. 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface ExceptionTest { Class&lt;? extends Throwable&gt;[] value();} 123456789public class Sample3 { @ExceptionTest({IndexOutOfBoundsException.class,NullPointerException.class}) public static void doublyBad(){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.addAll(5,null); }} list.addAll(5,null) methods는 IndexOutOfBoundsException 또는 NullPointerException을 던질 수 있다. 123456789101112131415161718192021222324Class&lt;?&gt; testClass = Class.forName(&quot;study.effectivejv.ch03.item39.Sample3&quot;);for (Method m : testClass.getDeclaredMethods()) { if (m.isAnnotationPresent(ExceptionTest.class)) { tests++; try { m.invoke(null); System.out.printf(&quot;테스트 %s 실패 : 예외를 던지지 않음. \\n&quot;, m); } catch (Throwable e) { Throwable exc = e.getCause(); int oldPassed = passed; Class&lt;? extends Throwable&gt;[] excTypes = m.getAnnotation(ExceptionTest.class).value(); for (Class&lt;? extends Throwable&gt; excType : excTypes) { if (excType.isInstance(exc)) { passed++; break; } } if (passed == oldPassed) { System.out.printf(&quot;테스트 %s 실패 : %s \\n&quot;, m, exc); } } } System.out.printf(&quot;성공 : %d . 실패: %d \\n&quot;, passed, tests - passed);} @RepeatableJava 8부터는 배열 값을 받는 annotation 를 @Repeatable meta annotation을 활용해 구현할수도 있다.@Repeatable meta annotation은 하나의 프로그램 요소에 여러 번 달 수 있다. @Repeatable annotation 사용방법 @Repeatable 단 annotation 을 반환하는 container annotation을 하나 더 정의하고, @Repeatable의 매개변수로 container annotation의 class 객체를 매개변수로 넘겨야한다. container annotation은 내부 annotation type의 배열을 반환하는 value method를 정의해야 한다. container annotation 에는 @Retention , @Target meta annotation을 달아야 한다. 1234567891011121314// repeatable annotation @Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Repeatable(ExceptionTestContainer.class)public @interface ExceptionTest{ Class&lt;? extends Throwable&gt; value();}// container annotation @Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface ExceptionTestContainer { ExceptionTest[] value();} @Repeatable 을 단 annotation은 다음과 같이 동일한 프로그램 요소에 여러 번 사용할 수 있다. 123456@ExceptionTest(IndexOutOfBoundsException.class)@ExceptionTest(NullPointerException.class)public static void doublyBad(){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.addAll(5,null);} @Repeatable annotation 사용주의점 두 개 이상의 @Repeatable annotation을 받았을떄는 container annotation type이 적용된다. 12345678910111213// container annotation type@ExceptionTest(NullPointerException.class)@ExceptionTest(ArithmeticException.class) void testMethod() {}@Test@DisplayName(&quot;Repeatable annotaion 2개이상부터는 Container type을 반환합니다.&quot;)public void shouldReturnContainerAnnotation() throws NoSuchMethodException { Method testMethod = this.getClass().getDeclaredMethod(&quot;testMethod&quot;); Assertions.assertThat(testMethod.getAnnotation(ExceptionTest.class)).isNull(); Assertions.assertThat(testMethod.getAnnotation(ExceptionTestContainer.class)).isNotNull(); // pass} getAnnotationsByType method는 이 둘(container annotation type과 repeatable annotation type)을 구분하진 않지만, isAnnotationPresent method는 이 둘을 구분한다. 따라서 위 방법을 적용했을떄는 다음과 같이 로직이 변경된다. 12345678910111213141516171819202122232425Class&lt;?&gt; testClass = Class.forName(&quot;study.effectivejv.ch03.item39.Sample3&quot;);for (Method m : testClass.getDeclaredMethods()) { if (m.getAnnotationsByType(ExceptionTestContainer.class)) { tests++; try { m.invoke(null); System.out.printf(&quot;테z스트 %s 실패 : 예외를 던지지 않음. \\n&quot;, m); } catch (Throwable e) { Throwable exc = e.getCause(); int oldPassed = passed; // getAnnotationByType method ExceptionTest[] excTests = m.getAnnotationsByType(ExceptionTest.class); for (ExceptionTest excTest : excTests) { if (excTest.value().isInstance(exc)) { passed++; break; } } if (passed == oldPassed) { System.out.printf(&quot;테스트 %s 실패 : %s \\n&quot;, m, exc); } } } System.out.printf(&quot;성공 : %d . 실패: %d \\n&quot;, passed, tests - passed);}","link":"/2022/01/13/2022-01-13-Item39/"},{"title":"Item38. 확장할 수 있는 Enum type이 필요하면 interface를 사용하라","text":"enum type은 상속이 불가능하다. 확장한 타입의 원소는 기반 타입으로 받을 수 있지만, 반대로 기반 타입은 확장한 타입으로 받을 수 없으며, 기반 타입과 확장한 타입들의 원소를 모두 순회할 방법도 마땅치 않다. enum type의 확장그럼에도 불구하고 enum type의 확장시 유용한 경우가 종종 있는데, 그 예중에 하나가 연산 코드이다. enum type은 상속이 불가능한 대신 interface 구현은 가능하다. 따라서 interface를 통해 간접적으로 확장이 가능하다. client 가 접근할 interface를 두고, 그 interface의 구현체별로 enum type을 정의하는 방법이다. client가 접근할 operation interface를 두고 operation interface의 구현체로 enum class를 생성하였다. 1234public interface Operation { double apply(double x, double y);} 12345678910111213141516171819202122232425262728293031323334public enum BasicOperation implements Operation{ PLUS(&quot;+&quot;){public double apply(double x, double y) { return x+y;}}, MINUS(&quot;-&quot;){public double apply(double x, double y) { return x-y;}}, TIMES(&quot;*&quot;){public double apply(double x, double y) { return x*y;}}, DIVIDE(&quot;/&quot;){public double apply(double x, double y) { return x/y;}}; private final String symbol; BasicOperation(String symbol) { this.symbol = symbol; } @Override public String toString() { return symbol; }}public enum ExtendedOperation implements Operation{ EXP(&quot;^&quot;){public double apply(double x, double y) { return Math.pow(x,y);}}, REMAINDER(&quot;%&quot;){public double apply(double x, double y) { return x%y;}}; private final String symbol; ExtendedOperation(String symbol) { this.symbol = symbol; } @Override public String toString() { return symbol; }} client측에서는 Operation 인터페이스를 사용하도록 작성되어 있기만 하면 구현체가 추가되어도 변경없이 동작할 수 있다. 12345678public class Client { public static void reportResult(Operation op,double x, double y){ System.out.printf(&quot;%f %s %f = %f \\n&quot;,x,op,y,op.apply(x,y)); } public static void main(String[] args) { reportResult(BasicOperation.DIVIDE,10,2); // 5 }} 뿐만 아니라 타입 수준에서 class literal을 넘겨 특정 구현체의 원소를 모두 사용할수도 있다. 123456789101112private static &lt;T extends Enum&lt;T&gt; &amp; Operation &gt; void test(Class&lt;T&gt; opEnumType , double x , double y){ for (Operation op : opEnumType.getEnumConstants()) { System.out.printf(&quot;%f %s %f = %f \\n&quot;,x,op,y,op.apply(x,y)); }}public static void main(String[] args) { double x = Double.parseDouble(args[0]); double y = Double.parseDouble(args[0]); test(BasicOperation.class,x,y);} 위에는 한정적 타입매개변수를 사용하였지만, 두번째 대안으로 한정적 wildcard type을 넘길수도 있다. 12345private static void test(Collection&lt;? extends Operation&gt; opSet , double x, double y){ for (Operation op : opSet) { System.out.printf(&quot;%f %s %f = %f \\n&quot;,x,op,y,op.apply(x,y)); }} 이 방법은 유연하게 여러 구현 타입의 연산을 다음과 같이 조합해 호출할 수 있다. 1test(List.of(BasicOperation.DIVIDE,ExtendedOperation.EXP),10.1,20.3); interface 확장 방식의 문제점 enum type 은 상속이 불가능하므로, 중복된 로직이 일부 추가될 수 있다. 아무 상태도 의존하지 않는 경우라면 default method를 interface에 추가할 수도 있다. 예를 들면 연산기호(symbol)을 저장하고 찾는 로직이 구현체마다 중복되어 있다. 만약 구현체가 많다면 별도의 정적 도우미 method 혹은 class로 분리해야 한다. 정리 enum type 은 상속이 불가능하나 interface를 두고 구현체를 여러개 만들어 확장하는 효과를 낼 수 있다.","link":"/2022/01/12/2022-01-12-Item38/"},{"title":"Transaction","text":"TransactionTransaction은 작업의 논리적인 단위로서 , 예를 들면 은행에서 출금 후 입금을 한다고 가정하였을떄 실제로 DB query문은 여러 번 나가겠지만 하나의 논리적인 작업 단위로 볼 수 있다.Transaction이 필요한 이유는 데이터베이스 연산 중간에 일관되지 않은 상태가 존재하기 떄문이다. 2개의 연산중에 하나만 수행되고 하나는 아직 수행되지 않은 상태가 존재할 수도 있다.따라서 데이터베이스는 작업의 완전성을 보장해주기 위해서 , 일련의 연산들을 사용자 입장에서 마치 단일 연산인것처럼 보이게 해준다. 추가로 transaction은 다음과 같은 특징을 갖는다. Transaction은 recovery 단위이다. 실제로 DB에 쓰여지는 과정에서 system failure시 write ahead log (WAL) 라고 하는데 log라는 자료구조에 먼저 transaction을 쓰고나서 commit처리를 해준다. 즉 commit 이후에 system failure시에는 이 log를 보고 복구가 가능하다. 아래에 Transaction 특성 중에 Isolation (독립성) 이 있다. 서로 다른 transaction은 독립적으로 수행될 수 있어야 하는데 , 이를 위해서는 concurrency control (동시성 제어) mechanism 이 필요하다. Transaction의 특성 (ACID)Transaciton 은 작업의 완전성을 보장하기 위해서 다음과 같은 4개의 특성을 갖는다. Atomicity (원자성): 원자성을 가지므로, 전부 실행되거나 (commit) 혹은 전부 실행되지 않는다 (rollback) Consistency(일관성) : Transaction은 데이터베이스의 일관성을 유지해야 한다. 즉 일관된 상태에서 일관된 상태로 변환해야 한다. Isolation(독립성): Transaction은 서로 독립적으로 수행될 수 있어야 한다. Durability(지속성) : Transaction이 commit되면 DB에 영구적으로 저장되야 한다. Transaction 상태 transaction은 다음과 같은 상태를 가진다. Active state : transaction이 아직 실행중인 상태 Partially committed state : transaction의 마지막 연산까지 전부 수행되었지만 commit 하기전의 상태 Failed : transaction중 오류가 발생해 중단된 상태 committed : transaction이 성공적으로 종료되어서 DB에 영구적으로 반영된 상태 aborted : transaction이 비정상적으로 종료되어서 rollback 연산을 통해서 작업을 취소하여 transaction 수행 이전의 일관된 DB 상태로 돌아간 상태 transaction의 병행수행 제어 기법 (concurrency control mechanism )다른말로 동시성 제어인데, 여러가지 transaction 이 공유자원 (DB 데이터)를 동시에 접근할떄 여러가지 문제가 발생할 수 있다 대표적으로 다음과 같은 문제가 생길 수 있다 lost update problem(갱신 분실 문제) : transaction A 가 수행한 update가 transaction B가 수행한 update를 덮어씌움. uncommitted dependency problem (비완료 의존성 문제) : transaction A 가 완료되지 않은 상태에서 갱신한 데이터를 transaction B 가 갱신했는데, transaction A가 rollback됨. Lockinglocking은 어떤 database object(tuple) 을 transaction 이 접근할떄, 다른 transaction들이 그 object를 변화시키지 못하도록 방지하는 것으로 2 종류의 lock이 존재한다. X lock (exclusive lock, 독점 로크) S lock (shared lock , 공유 로크) transaction A가 tuple 에 대해 X lock을 가지고 있다면 다른 transaction은 해당 tuple에 대한 어떤 형태의 lock 요구도 거절된다. 즉 접근이 불가하다. 반면 S lock을 가지고 있다면 일부분의 상황에 대해서는 허용해준다. X lock 요구는 거절한다 S lock 요구는 허용된다. 즉 두 transaction이 하나의 tuple에 대해 S lock을 가질 수 있다. 이러한 X,S lock에 대한 규칙은 아래의 호환성 행렬로 자세히 파악할 수 있다. Lock 작동 방식 , locking protocoltransaction이 어떤 tuple에 대해서 연산을 수행하려면 그전에 lock 과 관련된 처리들이 일어난다. transaction이 tuple을 검색하려면 먼저 그 tuple에 대한 S lock을 획득해야 한다. transaction이 tuple을 갱신하려면 먼저 그 tuple에 대한 X lock을 획득해야 한다. transaction이 가지고 있는 lock 때문에 다른 transaction이 lock를 획득하지 못하면 해당 transaction은 lock를 획득할떄까지 대기 해야한다. X,S lock모두 일반적인 경우 transaction이 끝날떄까지 유지된다. 2단계 로킹 protocol 2단계 로킹이란 lock을 요청하는 phase, lock을 반납하는 phase로 2단계로 나뉘는데 transaction이 연산을 수행하기전에 필요한 lock을 모두 획득한다. (확장단계) 그리고 연산을 수행한뒤 보유하고 있던 lock을 반납한다 (수축단계) Locking 자체의 문제, DeadLockLock 자체가 transaction간에 교착상태 (DeadLock)을 야기할 수 있다. 예를 들면 transaction A가 X라는 자원에 X lock을 가지고 Y라는 자원에 접근하고자 하는데 transaction B는 Y라는 자원에 X lock을 가지고 X자원에 접근하는 상황을 가정해보면 두 transaction은 서로가 가진 lock을 획득하기 위해서 무한히 대기할 것이다. (Deadlock 상태) Deadlock을 꺠트릴려면 결국에 하나의 transaction 은 victim 으로 선택해 해당 transaction은 rollback 시킴으로서 lock를 풀어주어야 한다.","link":"/2022/01/13/2022-01-13-transaction/"},{"title":"Index","text":"Index 정의Disk I/O를 최소화시키면서 원하는 데이터를 효율적으로 검색하기 위한 자료구조로 Data file과 분리된 index file 에 보관되며, 데이터 필드에 대한 탐색 키값과 record 물리적 위치를 가르키는 포인터로 구성된다. Index의 크기는 data file에 비해 휠씬 작다. 하나의 data file에 여러 개의 index가 정의될 수 있다. (하나의 희소인덱스와 여러개의 밀집 인덱스를 가질 수 있다. ) Index가 정의된 table의 필드를 탐색 키라고 한다. Index 종류data file 에 대해 직접적으로 index file 이 있는 경우를 단일 단계 인덱스, Index에 대한 또다른 Index 등 여러개의 index file 이 있는 경우를 다단계 인덱스라고 한다. 단일 단계 인덱스 다단계 인덱스 primary index (기본 인덱스)index key가 data file의 primary key 인 index 로, 희소 인덱스 (sparse index)에 속하는데, 물리적인 주소값에 대한 포인터를 각 Block 당 하나씩 가진다. primary key에 대해 정렬된 상태로 유지되야 희소 인덱스를 가질 수 있다. (그렇지 않으면 밀집 인덱스를 사용할 수밖에 없음) clustering index (클러스터링 인덱스)데이터와 인덱스값이 말그대로 군집화되어, 인덱스가 table의 데이터의 물리적 정렬 순서를 결정한다 . 즉 탐색 키값에 따라 정렬된 table에 대해 정의된다. 데이터 column이 정렬되어 있어야 함으로 table당 하나의 clustering index만 가지고 있다. clustering index 장점clustering index는 범위 질의에 유용하다. 범위의 시작 값에 해당하는 index entry를 먼저 찾고, 범위에 속하는 index entry를 따라가면서 record를 검색할떄 디스크에서 읽어오는 block수가 최소화된다. clustering index 단점table 에 data가 INSERT된다고하면 해당 table의 지정된 column은 모두 재정렬되야하며 (대참사, 검색에는 성능이 좋지만 입력성능은 최악이다. ) , index 생성시 해당 data file을 다시 정렬한다. non-clustering index (= secondary index , 보조인덱스)일반적으로 밀집 인덱스 (dense index)에 속하는데 , index file에서 record 별로 물리적인 주소값에 대한 포인터를 가지고 있다. non-clustering index 장점 clustering index와 다르게 밀집 인덱스이므로 정렬되지 않은 field도 탐색키로 사용할 수 있다. non-clustering index 단점밀집 인덱스이므로, 레코드에 접근할떄 Disk I/O 횟수가 증가한다. Index 설계 조건 갱신이나 삼입이 자주 일어나지 않으며 검색이 빈번한 field에 사용하는게 효과적이다. domain cardnality(해당 필드내 상이한 값들의 개수)가 적은 경우에는 index를 사용하지 않는게 효과적이다. table의 크기가 작은 경우에는 index를 사용하지 않는게 효과적이다. B+tree IndexRDB에서 사용되는 Index는 구조에 따라 다음과 같은 3가지로 분류될 수 있다. B+tree Index Bitmap Index Hash Index 이중에서 B+tree가 가장 범용적으로 사용된다. 대표적으로 RDBMS vendor 인 Oracle,PostegrreSql,MySQL 은 이 B+tree를 사용하고 있다. B+Tree는 B tree에 비해 검색을 효율적으로 만든 자료구조인데, B+Tree는 다음과 같은 특성을 추가로 갖는다. 모든 data가 leef node에 모여있다. leef node간에 linked list로 연결되어 있어, leef node간에도 선형검사를 수행할 수 있다.","link":"/2022/01/12/2022-01-12-db-index/"},{"title":"Git 개념 정리 (1) - Git vs SVN , Git file status","text":"Git 이란?형상관리(버전관리)를 하기 위한 tool로써 소스코드를 효과적으로 관리하기 위해 개발된 분산형 버전 관리 시스템이다.형상관리를 하기 위한 또다른 대표적인 tool로 SVN (subversion)이 존재한다. SVN은 Git은 분산형 버전 관리 시스템임에 비해 중앙집중관리식이다. 즉 local PC에서 commit을 하면 바로 중앙저장소에 반영되는 반면에 Git은 각 개발자마다 로컬저장소가 있어, push 전에는 중앙저장소에 반영되지 않는다. Git Repository : Git repository는 변경 이력별로 구분되어 소스코드가 저장되는데, 원격 저장소, 로컬 저장소로 나뉜다. Remote Repository (원격 저장소) : 파일이 원격 저장소 서버에 저장되며 , 협업하는 개발자들과 공유 가능 Local Repository (로컬 저장소) : 말 그대로 로컬 PC에 파일이 저장되며 개인 저장소이다. Git은 로컬저장소가 있음으로 성능상에 SVN에 비해 얻을 수 있는 장점도 있다.프로젝트의 history를 조회하거나 어떤 파일의 현재 버전과 한달전 버전을 비교하고자 할떄 네트워크 요청없이 수행될 수도 있다. Git 파일 상태 Git은 파일을 Committed , Modified , Staged 이렇게 3가지 상태로 관리한다. Committed : data 가 local repository에 안전하게 저장되었음 (git commit 이후 상태 ) Modified : data 가 수정되었으나 local repository 에 저장되지 않았음 Staged : 현재 수정한 file을 곧 commit 할것이라고 표시한 상태 (git add 이후 상태) Commit 파일(소스코드)의 변경사항이 있을떄 저장소에 반영하고자 하면 Git commit 명령어를 통해 수행될 수 있다. 각 commit 은 40자리의 id값을 부여받는데 , SHA-1 해시를 사용해서 checksum을 만든다. 저장소에는 이 id값을 보고 commit을 구분한다. Git 사용자 정보 등록Git 설치 이후 최초에는 사용자 정보 등록을 해야한다. 프로젝트마다 다르게 설정하고 싶으면 –global option을 주지 않는다. 12$ git config --global user.name &quot;devcs96&quot;$ git config --global user.email katd6@naver.com Git 저장소 생성 Git 저장소는 2가지 방법 중 하나로 쓰기 시작할 수 있다. 아직 버전 관리하지 않은 로컬 directory에서 git init 123456789101112cs@gimchansuui-iMac hello-git % git init .hint: Using 'master' as the name for the initial branch. This default branch namehint: is subject to change. To configure the initial branch name to use in allhint: of your new repositories, which will suppress this warning, call:hint: hint: git config --global init.defaultBranch &lt;name&gt;hint: hint: Names commonly chosen instead of 'master' are 'main', 'trunk' andhint: 'development'. The just-created branch can be renamed via this command:hint: hint: git branch -m &lt;name&gt;Initialized empty Git repository in /Users/cs/Desktop/hello-git/.git/ git init 명령어로 로컬 저장소를 만들면 .git directory가 생성되고 현재 directory가 working directory가 된다. 1drwxr-xr-x 9 cs staff 288 1 14 14:34 .git 원격의 Git 저장소에서 git clone 주로 github에서 저장소를 생성하고 생성된 원격 저장소를 clone해서 생성할수도 있다. git clone 명령어를 수행하면 원격 서버에 있는 프로젝트 데이터를 모두 받아오고, .git directory를 만들며, 해당 directory가 working directory가 된다. 1git clone https://github.com/devcs96/git.git working directory 내 파일 상태git init . 또는 git clone &lt;url&gt; 이후에 해당 working directory에는 .git sub directory가 생긴다. working directory내 파일 상태는 크게 2가지로 나뉜다. untracked : git 에 의해 관리되고 있지 않음 tracked : git 에 의해 관리되고 있음 123456789cs@gimchansuui-iMac hello-git % touch hello.txtcs@gimchansuui-iMac hello-git % git status On branch masterUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) hello.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) working directory에 파일을 위와 같이 생성하면 untracked file status를 볼 수 있다. git log를 보면 track 상태로 바꾸려면 즉 git이 관리하게 만드려면 git add 명령어를 치라고 로그가 찍혀있다. tracked 상태는 처음 “Git 파일 상태” 단락에 추가한 내용과 동일하다 git add 이후에는 staged 상태가 된다 (commit 이전 상태) 1234567cs@gimchansuui-iMac hello-git % git status On branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: hello.txtcs@gimchansuui-iMac hello-git % git commit 명령어를 실행하게 되면 git add 를 실행한 시점(staged 상태)의 파일이 commit되어 저장소 history에 남게된다. 이 상태로 file을 수정하면 modified 상태로 변경된다. 12345678910111213cs@gimchansuui-iMac hello-git % vim hello.txt // 파일 내용 수정 cs@gimchansuui-iMac hello-git % git status .On branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: hello.txtChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: hello.txtcs@gimchansuui-iMac hello-git % 다시 변경 내역을 staged상태로 변경하려면 git add 명령어를 통해 staged상태로 변경할 수 있다. .gitignoreworking directory내에서 git이 관리할 필요가 없는 파일을 개발자가 직접명시해줄수 있다. 대표적으로 build , node_modules 등과 같은 바이트 코드와 library 코드들은 .gitignore를 통해 원격저장소에 올리지 않을 수 있다. .gitignore에 입력할 패턴은 다음과 같은 규칙을 따르는데 reference에서 그대로 가져왔다 .gitignore 파일에 입력하는 패턴은 아래 규칙을 따른다. 아무것도 없는 라인이나, #로 시작하는 라인은 무시한다. 표준 Glob 패턴을 사용한다. 이는 프로젝트 전체에 적용된다. 슬래시(/)로 시작하면 하위 디렉토리에 적용되지(Recursivity) 않는다. 디렉토리는 슬래시(/)를 끝에 사용하는 것으로 표현한다. 느낌표(!)로 시작하는 패턴의 파일은 무시하지 않는다. 1234567891011121314151617# 확장자가 .a인 파일 무시*.a# 윗 라인에서 확장자가 .a인 파일은 무시하게 했지만 lib.a는 무시하지 않음!lib.a# 현재 디렉토리에 있는 TODO파일은 무시하고 subdir/TODO처럼 하위디렉토리에 있는 파일은 무시하지 않음/TODO# build/ 디렉토리에 있는 모든 파일은 무시build/# doc/notes.txt 파일은 무시하고 doc/server/arch.txt 파일은 무시하지 않음doc/*.txt# doc 디렉토리 아래의 모든 .pdf 파일을 무시doc/**/*.pdf git diff추가로 modified된 file 이 어떤 내용이 staged 상태와 다른지 확인하려면 git diff 명령어로 확인할 수 있다 123456789cs@gimchansuui-iMac hello-git % git diffdiff --git a/hello.txt b/hello.txtindex d1c6469..7e7bc4b 100644--- a/hello.txt+++ b/hello.txt@@ -1 +1 @@-hello git!+hello git!!!cs@gimchansuui-iMac hello-git % git commitgit commit 명령어로 git add 명령어를 통해 staged 상태로 만든 file들을 local 저장소에 저장할 수 있다. git commit을 치면 commit message를 통해 어떤 변경사항이 생겼는지 기록을 남기는데 , 회사마다 convention이 있겠지만 대표적으로 AngularJS Git Commit Message Conventions 이 있다.(Ref - https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.uyo6cb12dt6w) commit 내역은 git log 명령어를 통해 확인할 수 있다. 참고로 commit 26735a693a2305950d2e2bdf722bbd70f854e4fd 이 부분은 git에서 각 commit을 구분하기 위한 checksum이다. 12345678910111213cs@gimchansuui-iMac hello-git % git logcommit 26735a693a2305950d2e2bdf722bbd70f854e4fd (HEAD -&gt; master)Author: devcs96 &lt;katd6@naver.com&gt;Date: Fri Jan 14 15:15:16 2022 +0900 initial commitcommit b4c460c8ffa32fab0bbcad9e056c6cc39fecc95cAuthor: devcs96 &lt;katd6@naver.com&gt;Date: Fri Jan 14 14:37:41 2022 +0900 initial version controlcs@gimchansuui-iMac hello-git % git commit 되돌리기완료한 commit을 수정해야할떄 , 파일을 수정하고나서 git add 명령어로 staging 상태로 만든 다음에 git commit –amend 옵션을 주어 commit을 재작성할 수 있다. git commit –amend 명령어를 쳤는데 만약 수정된 내용이 없다면 commit message만 수정된다. 123456789101112131415161718cs@gimchansuui-iMac hello-git % git commit --amend [master b4ed6d1] initial commit 이 내용 넣는 것을 깜빡했네요 Date: Fri Jan 14 15:15:16 2022 +0900 1 file changed, 1 insertion(+) create mode 100644 hello.txtcs@gimchansuui-iMac hello-git % git logcommit b4ed6d19078cbbc1cb5b47085b6756c633bf7d10 (HEAD -&gt; master)Author: devcs96 &lt;katd6@naver.com&gt;Date: Fri Jan 14 15:15:16 2022 +0900 initial commit 이 내용 넣는 것을 깜빡했네요commit b4c460c8ffa32fab0bbcad9e056c6cc39fecc95cAuthor: devcs96 &lt;katd6@naver.com&gt;Date: Fri Jan 14 14:37:41 2022 +0900 initial version control 기존 커밋을 덮어씌우는 개념이다. staged 상태를 unstaging 상태로 변경하기1234567cs@gimchansuui-iMac hello-git % git add *cs@gimchansuui-iMac hello-git % git status On branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: hello.txt modified: index.txt 실수로 다음과 같이 git add * 을 호출해 원하지 않는 파일도 staged 상태로 변경하였다. 이를 unstaged 상태로 변경하려면 git reset HEAD &lt;file명&gt; 으로 unstaging상태로 변경할 수 있다. 12345678910111213cs@gimchansuui-iMac hello-git % git reset HEAD hello.txtUnstaged changes after reset:M hello.txtcs@gimchansuui-iMac hello-git % git status .On branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: index.txtChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: hello.txt modified 상태를 변경전 상태의 파일로 원상복구하기 1234567891011121314151617cs@gimchansuui-iMac hello-git % head index.txtindex.txt수정 cs@gimchansuui-iMac hello-git % git status .On branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: index.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)cs@gimchansuui-iMac hello-git % git checkout -- index.txtcs@gimchansuui-iMac hello-git % head index.txt index.txtcs@gimchansuui-iMac hello-git % git status .On branch masternothing to commit, working tree clean index.txt 파일을 수정하고나서 modified된 상태를 변경 전 내용으로 원상복구하고 싶다면git checkout – &lt;file명&gt; 을 통해 변경 전 내용으로 원상복구 할 수 있으나, branch 를 사용하는 방법을 권고한다. Remote Repository 등록git remote 명령어를 통해 현재 project에 등록된 원격 저장소를 확인할 수 있다. 참고로 git clone을 사용하면 clone한 repository가 자동으로 “origin”이라는 이름의 원격 저장소로 등록된다. 123cs@gimchansuui-iMac git % git remote -vorigin https://github.com/devcs96/git.git (fetch)origin https://github.com/devcs96/git.git (push) git init을 통해 working directory를 생성하면 등록된 원격저장소가 없는 상태이다. 이때 다음과 같이 원격저장소를 등록해줄 수 있다. git remote add &lt;원격저장소 단축이름&gt; &lt;원격저장소url&gt; 12345cs@gimchansuui-iMac hello-git % git remote -vcs@gimchansuui-iMac hello-git % git remote add hello https://github.com/devcs96/git.gitcs@gimchansuui-iMac hello-git % git remote -vhello https://github.com/devcs96/git.git (fetch)hello https://github.com/devcs96/git.git (push)","link":"/2022/01/14/2022-01-14-git01/"},{"title":"Git 개념 정리 (2) - Git Branch , Merge","text":"Git Branch코드를 통쨰로 복사하고 나서 다른 개발자들과 독립적으로 개발을 진행할 수 있도록 branch를 나눌 수 있다. Git branch는 commit 사이를 이동할 수 있는 포인터와 비슷한 개념으로, 기본적으로 Git은 master branch를 먼저 만든다. 이후 commit을 하게 되면 master branch 는 자동적으로 가장 마지막(최근) commit을 가르킨다. branch 생성하기git branch 는 git branch &lt;branch명&gt; 명령어로 만들 수 있다. branch를 새로 만들면 가장 마지막 commit을 가르키게 된다. 1C:\\Users\\katd6\\OneDrive\\바탕 화면\\hello-git&gt;git branch testbranch 그럼 두 branch중에 현재 working directory에서 작업중인 branch를 어떻게 나눌까? Git은 HEAD라고 하는 로컬 Branch를 가르키는 특수한 pointer가 존재한다. 123C:\\Users\\katd6\\OneDrive\\바탕 화면\\hello-git&gt;git branch -a* master testbranch branch 이동하기 git checkout git branch 는 checkout 명령어로 이동할 수 있다. 아까 정리했던것처럼 Git은 HEAD라고 하는 현재 작업중인 Local branch를 가르키는 pointer인 HEAD가 존재한다고 하였다. git checkout 명령어로 로컬 branch를 바꾼다는 것은 결국에 이 pointer가 가르키는 branch를 변경하겠다는 말이랑 동일하다. 12345678910C:\\Users\\katd6\\OneDrive\\바탕 화면\\hello-git&gt;git branch -a* master testbranchC:\\Users\\katd6\\OneDrive\\바탕 화면\\hello-git&gt;git checkout testbranchSwitched to branch 'testbranch'C:\\Users\\katd6\\OneDrive\\바탕 화면\\hello-git&gt;git branch -a master* testbranch 변경된 branch에서 파일을 변경 (modified status) 및 add (Staged ) 및 commit 하게 되면 어떻게 될까? 1234567891011121314C:\\Users\\katd6\\OneDrive\\바탕 화면\\hello-git&gt;git status .On branch testbranchUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) newfile.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track)C:\\Users\\katd6\\OneDrive\\바탕 화면\\hello-git&gt;git add newfile.txtC:\\Users\\katd6\\OneDrive\\바탕 화면\\hello-git&gt;git commit -m &quot;update from testbranch&quot;[testbranch 9201770] update from testbranch 1 file changed, 1 insertion(+) create mode 100644 newfile.txt 다음과 같이 testbranch에서 file을 add, commit해보았다. 이전까지 master , testbranch는 가장 최근 commit 을 동일하게 가르켰지만, 이젠 testbranch는 방금전 수행한 commit을 가르키고 , master branch 는 master branch에서 가장 최근에 수행한 commit을 가르키고 있다. master branch에서 또다른 commit을 수행하고 각각 두 branch에서 git log 를 찍어보았다. test branch , master branch가 분기해서 각각의 최근 commit을 가르키는 것을 볼 수 있으며, 이는 HEAD pointer에 의해 가르켜진다. branch 사용예제Git pro (https://git-scm.com/book/ko/v2) 에 따르면 git branch 사용 예시는 다음과 같다. 1234567891011실제 개발과정에서 겪을 만한 예제를 하나 살펴보자. 브랜치와 Merge는 보통 이런 식으로 진행한다.웹사이트가 있고 뭔가 작업을 진행하고 있다.1. 새로운 이슈를 처리할 새 Branch를 하나 생성한다.2. 새로 만든 Branch에서 작업을 진행한다.이때 중요한 문제가 생겨서 그것을 해결하는 Hotfix를 먼저 만들어야 한다. 그러면 아래와 같이 할 수 있다.1. 새로운 이슈를 처리하기 이전의 운영(Production) 브랜치로 이동한다.2. Hotfix 브랜치를 새로 하나 생성한다.3. 수정한 Hotfix 테스트를 마치고 운영 브랜치로 Merge 한다.4. 다시 작업하던 브랜치로 옮겨가서 하던 일 진행한다. 먼저 이슈가 발생했다고 가정하면 이슈처리용 branch를 생성 및 이동한다. 12C:\\Users\\katd6\\OneDrive\\바탕 화면\\hello-git&gt;git checkout -b iss53Switched to a new branch 'iss53' 참고로 git checkout -b 는 git branch 생성 후에 해당 branch로 HEAD pointer를 이동하라는 명령어다. 다음으로 issue에 대해 어떤 코드를 작성하고 commit을 하였다고 가정하자 이떄 도중에 다른 긴급한 이슈가 생겼다고 하면 먼저 master branch로 이동하고, 해당 issue에 대한 branch를 또하나파서 작업한다. 이렇게 작업하면 issue별로 branch를 따서 서로 독립적으로 개발이 가능하다. 고친 issue를 master branch 와 병합하고 싶으면 git merge &lt;병합할branch명&gt; 명령어를 통해서 두 branch를 합칠 수 있다. 이떄 두 branch가 공동 선상에 있다면 fast-forward 방식으로 HEAD pointer를 이동시켜줄 수 있다. branch 가 합쳐진 이후에 고친 issue branch가 필요없다면 다음과 같이 제거하고, 원래 개발자가 수행하던 issue로 돌아가면 된다. issue 가 모두 종료되어 master branch에 해당 issue도 merge 한다고 가정하자 이떄는 아까처럼 fast-forward 방식이 아니다. 그 이유는 두 branch가 동일 선상에 있는기 떄문에 두 branch간 공통조상 하나를 사용해서 3way merge를 한다.3way merge 방법은 단순히 branch pointer (HEAD)를 최신 commit으로 이동시키는 방법이 아니다, 3way merge 병합 결과 자체를 새로운 commit으로 만들어서 두 branch 모두를 부모로 갖게 만든다. Merge commit : 3 way merge 방식에 의해 2 branch를 부모로 갖는 commit branch 관리branch 관리하는데 필요한 그 외 명령어는 다음과 같으며, 자세한 내용은 git branch –help를 통해 api 문서를 보면 된다. git branch -v : 현재 작업 branch 내역과 마지막 commit message들 git branch –merged: 현재 branch 기준으로 merge된 branch git branch –no-merged: 현재 branch 기준으로 merge되지 않은 branch git branch -d &lt;branch명&gt; : 해당 branch 삭제 git branch workflowbranch를 만들고 merge하는 방식에 대해 convention처럼 workflow가 만들어진것이 있다. Long-Running branch master branch는 안정된 코드 (배포할 코드) 만 두고, 개발 진행하는 과정에서 기능이 추가될 branch 는 develop branch에 둔다.이후 test code를 작성해서 정상적으로 pass되면 master branch에 merge 한다. remote branchremote branch란 원격 저장소에 있는 branch,tag등을 의미한다. git ls-remote &lt;원격저장소&gt; 를 통해 해당 원격저장소에 있는 remote branch를 조회할 수 있다. remote branch (정확히는 remote tracking branch인데, local에 있지만 서버에 연결될때마다 자동으로 갱신된다.) 는 &lt;원격저장소명&gt;/&lt;branch명&gt; 형식으로 되어 있다. 예를 들어 어떤 원격저장소에 있는 프로젝트를 clone해서 local로 가져오면 다음과 같은 일이 벌어진다. git clone 명령어는 이전에 말햇던것처럼 자동으로 origin 이라는 이름으로 원격저장소를 등록해준다. 또한 원격의 master branch를 가르켜주는 (origin/master) pointer를 만들어주는데, 이 pointer는 개발자가 조종할수 없다. git pull vs fetch원격저장소로부터 저장소 정보를 동기화 하려면 git fetch &lt;원격저장소명&gt; 을 통해 새로운 정보가 있으면 모두 내려받고, origin/master pointer를 최신 commit으로 이동시켜준다. 반면 git pull 은 원격저장소로부터 저장소 정보를 동기함과 더불어 자동으로 로컬 branch와 병합까지 수행한다. 원격 저장소에 push 하기local branch를 서버로 전송하려면 write 권한이 있는 원격 저장소에 push해야 한다. git push &lt;원격저장소명&gt; &lt;push할branch명&gt; remote branch 삭제git push &lt;원격저장소명&gt; –delete &lt;삭제할branch명&gt;","link":"/2022/01/14/2022-01-14-git02/"},{"title":"Item40. @Override annotation을 일관되게 사용하라","text":"@OverrideJava가 기본으로 제공하는 annotation중 @Override는 상위 타입 method를 재정의하였을때 달릴 수 있다. @Override annotation을 사용함으로 여러 가지 버그들을 컴파일 시점에 예방해 줄 수 있다. 예를 들어 다음과 같은 영어 알파벳 2개로 구성된 문자열을 표현하는 클래스가 있다고 할때, main method에서 26개의 소문자를 set에 넣어준뒤 출력하면 당연히 26개의 size가 출력되야하지만 실제로는 260 개의 size가 나온다. 12345678910111213141516171819202122232425public class Bigram { private final char first; private final char second; public Bigram(char first, char second) { this.first = first; this.second = second; } public boolean equals(Bigram o) { return first == o.first &amp;&amp; second == o.second; } public int hashCode() { return Objects.hash(first, second); } public static void main(String[] args) { Set&lt;Bigram&gt; s = new HashSet&lt;&gt;(); for(int i = 0; i&lt; 10 ; i++){ for (char ch = 'a'; ch &lt;= 'z';ch++){ s.add(new Bigram(ch,ch)); } } System.out.println(s.size()); // 260 }} 그 이유는 바로 equals method를 실수로 parameter 를 Bigram type으로 받아 overrloading하였기 때문이다. @Override 를 붙여주면 바로 compile error를 보여준다. 따라서 상위 class의 method를 재정의하는 모든 method는 @Override annotation을 달 것을 권고한다. 추가로 구체 class에서 상위 추상 class의 추상 method를 재정의하는 상황에서 개발자가 실수로 method overrloading시에는 어차피 compile error가 터지기에 @Override annotation을 안달아도 되지만, 일관성을 위해서 달아도 무관한다.","link":"/2022/01/14/2022-01-15-Item40/"},{"title":"Graph","text":"Graph 정의정점(Vertex)과 간선(Edge)의 집합 그래프 용어 정리 방향 그래프 (Directed Graph) : 간선에 방향이 있는 그래프 무방향 그래프(Undirected Graph) : 간선에 방향이 없는 그래프 차수(Degree) : 임의의 정점에 인접한 정점의 수 경로 : 시작 정점 u로부터 도착 정점 v까지의 정점들 단순 경로 : 경로 내 모든 정점들이 다른 경우 Cycle : 시작 정점과 도착 정점이 동일한 경우 연결 성분 (Connected Component) : 그래프에서 정점들이 서로 연결되어 있는 부분 가중치 그래프 (Weighted Graph) : 간선에 가중치가 부여된 그래프 신장트리 (Spanning Tree) : 그래프가 하나의 연결성분으로 구성되어 있을 때, 그래프의 모든 정점들을 cycle없이 연결하는 부분 그래프 그래프 구현 방법그래프를 구현하기 위한 방법으로 2가지가 존재한다. 인접행렬 (Adajacent Matrix) : 2차원 배열로 표현하는 방법으로 n개의 정점이 존재한다고 하였을 떄 , n x n 배열로 표현하여 그래프의 정점 i 와 정점 j 간에 연결선이 존재하면 1을 표시하고, 연결선이 존재하지 않으면 0을 표시하여 구성한다. dense graph를 표현할떄 유리하다. 장점 : 정점간의 연결선 여부를 O(1) 으로 파악 가능 단점 : O(N^2)의 공간 복잡도를 가짐 인접 리스트 (Adjacency List) : 정점과 해당 정점에 인접한 정점들을 연결리스트로 표현하는 방식으로, n개의 정점이 존재한다고 하였을떄, n x n 연결리스트로 구성된다. sparse graph를 표현할떄 유리하다. 장점: O(N+E)의 공간 복잡도를 가짐 단점 : 정점간의 연결선 여부를 O(N) 으로 파악가능 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Graph&lt;T&gt; { // 연결리스트 private Map&lt;Vertex&lt;T&gt;, List&lt;Vertex&lt;T&gt;&gt;&gt; adjVertices = new HashMap&lt;&gt;(); void addVertex(T label){ adjVertices.putIfAbsent(new Vertex(label),new ArrayList&lt;&gt;()); } void removeVertex(T label){ Vertex vertex = new Vertex(label); adjVertices.values().stream().forEach((e)-&gt;e.remove(vertex)); adjVertices.remove(vertex); } void addEdge(T label1,T label2){ Vertex&lt;T&gt; v1 = new Vertex(label1); Vertex&lt;T&gt; v2 = new Vertex(label2); adjVertices.get(v1).add(v2); adjVertices.get(v2).add(v1); } void removeEdge(T label1, T label2){ Vertex v1 = new Vertex(label1); Vertex v2 = new Vertex(label2); List&lt;Vertex&lt;T&gt;&gt; vertices1 = adjVertices.get(v1); List&lt;Vertex&lt;T&gt;&gt; vertices2 = adjVertices.get(v2); if(vertices1 != null){ vertices1.remove(v2); } if(vertices2 != null){ vertices2.remove(v1); } } List&lt;Vertex&lt;T&gt;&gt; getAdjvertices(T label ){ return adjVertices.get(new Vertex(label)); } public class Vertex&lt;T&gt;{ T label; Vertex(T label){ this.label = label; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Vertex vertex = (Vertex) o; return Objects.equals(label, vertex.label); } @Override public int hashCode() { return Objects.hash(label); } }} 그래프 탐색그래프 탐색은 2가지 방식으로 모든 정점을 방문할 수 있다. DFS(Depth First Search,깊이우선탐색) BFS(Breadth First Search,너비우선탐색) 그래프 탐색 - DFS임의의 정점에서 시작하여 , 이웃하는 하나의 정점을 방문하고, 방금 방문한 정점의 이웃 정점들 방문하는 식으로 탐색한다.연결할 수 있는 정점이 있을때까지 위와 같은 방식으로 탐색하고, 없다면 바로 이전 정점으로 되돌아가 탐색을 다시 수행한다.DFS 의 시간복잡도는 O(N+M)인데, N은 정점의 수, M은 간선의 수이다. +) 미로 출구 찾기랑 비슷하다고 생각하면 편하다 , 미로가 막혔을때 이전 분기점으로 되돌아가 탐색을 진행한다.아래는 재귀적으로 구현한 방법과 while loop를 사용한 iteration 방법을 구현하였다. 재귀적으로 호출하는 것도 결국에는 system stack을 사용한다. 1234567891011121314151617181920212223242526272829303132333435363738public class GraphSearch { @SuppressWarnings(&quot;unchecked&quot;) static &lt;T&gt; Set&lt;T&gt; iterativeDfs(Graph&lt;T&gt; graph , T root ){ Set&lt;T&gt; visited = new LinkedHashSet&lt;&gt;(); Stack&lt;T&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()){ T vertex = stack.pop(); if(! visited.contains(vertex)){ visited.add(vertex); for (Graph&lt;T&gt;.Vertex&lt;T&gt; adjvertex : graph.getAdjvertices(vertex)) { Graph&lt;T&gt;.Vertex&lt;T&gt; castedVertex = adjvertex; stack.push(castedVertex.label); } } } return visited; } static &lt;T&gt; List&lt;T&gt; recursiveDfs(Graph&lt;T&gt; graph, T root){ List&lt;T&gt; isVisited = new ArrayList&lt;&gt;(); recursiveDfs(graph,root,isVisited); return isVisited; } static &lt;T&gt; void recursiveDfs(Graph&lt;T&gt; graph , T root , List&lt;T&gt; visited ){ List&lt;Graph&lt;T&gt;.Vertex&lt;T&gt;&gt; adjvertices = graph.getAdjvertices(root); for (Graph&lt;T&gt;.Vertex&lt;T&gt; adjvertex : adjvertices) { if(!visited.contains(adjvertex.label)){ visited.add(adjvertex.label); recursiveDfs(graph,adjvertex.label,visited); } } }} 깊이우선 신장트리(Depth First Spanning Tree) : 입력 그래프가 하나의 연결 성분으로 되어있을떄, DFS를 수행하며 만들어진 트리 그래프 탐색 - BFSBFS는 임의의 정점 s에서 시작하여 s의 이웃하는 모든 정점들을 방문하고, 방문한 정점들의 이웃 정점들을 방문하는 식이다.Tree에서의 Level Order Traveral(레벨순회)랑 동일하다. BFS에서는 Queue 자료구조를 사용한다. (정확히는 dequeue)BFS의 시간복잡도는 O(N+M)이다. ( N은 정점의 수, M은 간선의 수이다. ) 123456789101112131415161718static &lt;T&gt; Set&lt;T&gt; bfs(Graph&lt;T&gt; graph,T root){ LinkedHashSet&lt;T&gt; visited = new LinkedHashSet&lt;&gt;(); // deque 사용 Deque&lt;T&gt; deque = new ArrayDeque&lt;&gt;(); deque.push(root); visited.add(root); while(!deque.isEmpty()){ T vertex = deque.pollFirst(); List&lt;Graph&lt;T&gt;.Vertex&lt;T&gt;&gt; adjvertices = graph.getAdjvertices(vertex); for (Graph&lt;T&gt;.Vertex&lt;T&gt; adjvertex : adjvertices) { if(!visited.contains(adjvertex.label)){ visited.add(adjvertex.label); deque.push(adjvertex.label); } } } return visited;} 너비우선 신장트리 (Breadth First Spanning Tree) : 입력 그래프가 하나의 연결 성분으로 되어 있을떄, BFS를 수행하며 만들어진 트리 그래프 알고리즘 그래프 알고리즘에는 대표적으로 최소 신장 트리를 찾기 위한 알고리즘인 Kruskal, Prim , Solin 알고리즘이 있다. 최소 신장 트리 (Minimum Spanning Tree ,MST): 무방향 가중치 그래프에서 간선의 가중치의 합이 최소인 신장 트리 그래프 알고리즘에 관한 내용은 알고리즘 카테고리에 정리해서 포스팅하려고 한다.","link":"/2022/01/15/2022-01-15-dtst-graph/"},{"title":"Item41. 정의하려는 것이 타입이라면 marker interface를 사용하라","text":"marker interface : 아무 method도 없으며, 단지 자신을 구현하는 class가 특정 속성을 가짐을 표시해주는 인터페이스 ex) Serializable interface : 직렬화 가능함을 표시 marker interface 의 장점marker interface는 2가지 측면에서 marker annotation 에 비해 유리하다. 타입으로 사용 가능하다 적용대상을 더 정밀하게 지정이 가능하다. 특정 인터페이스를 구현한 class에만 적용하고 싶은 marker interface 가 있다고 하면 해당 인터페이스를 확장하면 된다. marker annotation 의 장점 annotation 기반으로 작동하는 framework에서는 해당 framework의 지원을 받을 수 있다. 어떤 때에 marker interface 또는 marker annotation을 사용해야 하는가?class,interface가 아닌 프로그램 요소(method,local variable,module…)에 적용할떄는 marker annotation, class,interface에 적용할때는 marking된 객체를 매개변수로 받는 method가 있다면 marker interface, 없다면 marker annotation 을 사용한다.","link":"/2022/01/17/2022-01-17-Item41/"},{"title":"Item42. 익명 클래스보다 람다를 사용하라","text":"함수 객체(function object) : 추상 method를 하나만 담은 interface 의 instance (JDK1.1이전) 익명 class : Jdk 1.1이 등장하면서 함수 객체를 만드는데 사용됨. 1234567// 익명 class 예시 Collections.sort(words, new Comparator&lt;String&gt;() { @Override public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); }}); 익명 class의 단점으로 추상 method를 하나만 구현하는데, 코드가 길어진다는 단점이 존재한다. Lambda expression Functional Interface : 추상 method 를 하나만 가지고 있는 interface 123456@FunctionalInterfacepublic interface FI { void doSomething(); // default method는 있어도 상관없음 default void print(String str){ System.out.println(&quot;str = &quot; + str); }} Lambda expression, Lambda : Function interface의 객체를 간결하게 구현할 수 있도록 지원해줌 람다식을 이용하면 기존에 길었던 익명 class 코드를 줄일 수 있다. (paramter 의 type 추론도 지원해줌.) 1Collections.sort(words,(s1,s2)-&gt;Integer.compare(s1.length(),s2.length())); 주의사항 : compiler가 람다식의 매개변수 타입을 추론할때, generic raw type 을 사용하면 추론이 불가능해짐으로, 꼭 타입매개변수를 적어주어야 함. 메소드 참조 표현식 ( method reference expression )method reference 는 람다식에서 기존에 존재하던 하나의 정적,인스턴스 method를 호출만할떄, 불필요한 매개변수를 제거하고 람다식을 더 간결하게 사용할 수 있게 해줌(ref - https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html) method reference 의 종류는 다음과 같다, 다음 Item 43에서 자세한 종류를 확인할 수 있다. Static 메소드 레퍼런스 Instance 메소드 레퍼런스 Constructor 메소드 레퍼런스 12// static method reference 사용 Collections.sort(words,comparingInt(String::length)); Item34에서 소개했던 Enum 상수값별로 동작이 달라질떄 Enum type내 추상 method를 정의하고 상수별로 class 몸체를 만드는 방식도 람다를 적용하면 더 간결하게 표현이 가능하다 1234567891011121314151617181920public enum Operation { // class 몸체 구현 PLUS(&quot;+&quot;){ public double apply(double x, double y) { return x+y;}}, MINUS(&quot;-&quot;){ public double apply(double x, double y) { return x-y;}}, TIMES(&quot;*&quot;){ public double apply(double x, double y) { return x*y;}}, DIVIDE(&quot;/&quot;){ public double apply(double x, double y) { return x/y;}}; private final String symbol; Operation(String symbol){ this.symbol = symbol; } @Override public String toString(){ return this.symbol; } // 상수별 동작이 달라지는 추상 method public abstract double apply(double x, double y); 람다를 적용하면 다음과 같이 간결해진다. 1234567891011121314public enum Operation { PLUS(&quot;+&quot;, (x,y) -&gt; x+y ), MINUS(&quot;-&quot;,(x,y) -&gt; x-y), TIMES(&quot;*&quot; , (x,y) -&gt; x*y), DIVIDE(&quot;/&quot;, (x,y) -&gt; x/y); private final String symbol; private final DoubleBinaryOperator op; // DoubleBinaryOperator 는 double 타입 인수 2개를 받아, double 타입 인수 1개를 반환해주는 함수형 인터페이스이다. ㅂ Operation(String symbol , DoubleBinaryOperator op){ this.symbol = symbol; this.op = op; }} Lambda 사용 주의점 이름이 없으며, 문서화가 불가능하다 따라서 동작이 명확하지 않거나, 코드가 길어지면 람다를 쓰지 않는것을 권고한다. 함수형 인터페이스에만 적용가능함으로, 그 외에는 익명class를 사용해야 한다. this가 자기 자신이 아닌, 바깥 인스턴스를 가르킨다. 반면 익명 class는 this가 자기 자신을 가르킨다. Jvm 구현체별로 직렬화 형태가 다를 수도 있으니, 직렬화는 하면 안된다. 외부에 있는 값을 변경하는 등 상태을 가지지 않도록 final 또는 상태를 변경하지 않는게 보장된 effectively final 이 아니면 compile error를 던져준다. 외부 상태에 의존하지 않는 다는 내용은 함수형 프로그래밍 개념의 순수 함수 개념과 관련이 있다. 순수 함수 (pure function ) : 함수 외부에 있는 값을 변경하지 못하는 등 상태가 없어 사이드 이펙트를 만들 수 없다. 이외에도 함수형 프로그래밍의 주요 특징은 아래와 같다. 고차 함수 (high-order function ) : 함수가 함수를 매개변수로 받을 수 있고 함수를 리턴할 수도 있다. 일급객체 (first-class object) : 함수를 일급 객체로 사용할 수 있다, 즉 함수를 변수에 할당하고, 인자로 전달할 수 있다. 불변성 (Immutable)","link":"/2022/01/18/2022-01-18-Item42/"},{"title":"연관관계 매핑","text":"객체 연관관계와 테이블 연관관계의 차이점 객체는 참조(주소)값을 기준으로 연관관계를 맺는다.(단방향)ex) X-&gt;Y , Y-&gt;X 테이블은 외래키를 기준으로 연관관계를 맺는다. (JOIN operation , 양방향)ex) X JOIN Y 는 Y JOIN X 도 가능하다. 단방향 연관관계 두 entity 중 어느 한쪽만 다른 한쪽을 참조하는 경우을 단방향이라고 한다. 1234567891011121314151617181920212223242526272829//회원 entity@Entitypublic class Member { @Id @Column(name = &quot;member_id&quot;) private String id; private String username;}// 게시글 entity @Entitypublic class Board { @Id @Column(name = &quot;board_seq&quot;) @GeneratedValue(strategy = GenerationType.IDENTITY) private Long seq; private String title; private String content; // 연관관계 @ManyToOne @JoinColumn(name = &quot;member_id&quot;) private Member member;} 예를 들어 회원이 여러개의 게시글을 사용할 수 있는 다대일(게시글 N : 회원 1) 상황을 고려하면 단방향에서는 회원-&gt;게시글을 참조하거나, 게시글-&gt;회원을 참조하거나 어느 한쪽만 참조하는 경우를 생각할 수 있다. 위 예시 코드는 게시글이 회원을 참조하는 상황을 가정하였다. 연관관계 매핑을 위한 annotation은 다음과 같이 사용되었다. @ManyToOne : 다대일 관계 매핑 @JoinColumn : 외래키 매핑 , name 속성에 외래키 이름을 지정한다. 여기서는 member_id값이 외래키가 된다. 양방향 연관관계 두 entity간에 서로 참조하는 관계를 양방향 연관관계라고 한다. 위 예에서 Member -&gt; board는 일대다 연관관계이다. 일대다 연관관계에서 ‘다’측의 객체는 Collection (List,Set,Map…) 으로 매핑될 수 있다. (정확히 말하면 단방향 연관관계 2개를 application에서 양방향인 것 처럼 보이게 할 뿐이다.) 단방향 연관관계에 비해 갖는 장점은 반대 방향으로도 객체 그래프 탐색 기능이 추가되었다는 장점이 있다. 반면 단점으로는 연관관계를 매핑할때 객체에서 양쪽 방향을 모두 관리해야 된다는 단점이 있다. 12345678910111213@Entitypublic class Member { @Id @Column(name = &quot;member_id&quot;) private String id; private String username; @OneToMany(mappedBy = &quot;member&quot;) private List&lt;Board&gt; boardList = new ArrayList&lt;&gt;();} @OneToMany : 일대다 관계 mappedBy 속성 : 양방향 매핑일떄 반대쪽 (Board) entity에서 자신이 매핑된 필드 이름 값 연관관계의 주인양방향 연관관계에서는 주의할점이 있다. 두 연관관계중에 하나를 연관관계의 주인으로 정해야 한다는 것이다.연관관계의 주인이라 함은 외래키를 가지고 있는 entity 를 말한다. 즉 외래키를 가지는 DB 와 매핑되는 Entity가 연관관계의 주인인 것이다. 연관관계의 주인이 아닌 entity가 mappedBy 속성을 사용해, 연관관계의 주인을 지정해야 한다. 123456789101112131415161718@Entitypublic class Member { //... @OneToMany(mappedBy = &quot;member&quot;) private List&lt;Board&gt; boardList = new ArrayList&lt;&gt;();}@Entitypublic class Board { // 연관관계의 주인이다. @ManyToOne @JoinColumn(name = &quot;member_id&quot;) private Member member;} 정리하면 연관관계의 주인만이 DB에서 외래키를 가진 table과 매핑되고, 외래키를 관리한다 , 즉 저장하려면 연관관계의 주인을 통해서 이루어져야 한다. 반면 연관관계의 주인이 아닌 entity는 읽기만 가능하다.따라서 연관관계(외래키)를 저장할떄에는 연관관계의 주인을 통해서만 저장할 수 있다. 1234567891011// 연관관계의 주인 board entitytransaction.begin();Member member = new Member(&quot;id1&quot;, &quot;user1&quot;);em.persist(member);Board boardA = new Board(&quot;title1&quot;,&quot;content1&quot;,member);em.persist(boardA);Board boardB = new Board(&quot;title2&quot;,&quot;content2&quot;,member);em.persist(boardB); 다음과 같이 연관관계의 주인이 아닌 다대일에서 ‘일’ 쪽인 entity가 연관관계를 저장하면 예외는 터지지 않으나, DB에는 null값이 할당된다. 12345678910Board boardA = new Board(&quot;title1&quot;,&quot;content1&quot;);em.persist(boardA);Board boardB = new Board(&quot;title2&quot;,&quot;content2&quot;);em.persist(boardB);Member member = new Member(&quot;id1&quot;, &quot;user1&quot;);member.getBoardList().add(boardA); // nullmember.getBoardList().add(boardB); // nullem.persist(member); 대개 연관관계는 다대일,일대다 등에서 ‘다’ 쪽이 연관관계의 주인이 된다. 그 이유는 DB 를 생각해도 당연하다. 따라서 @ManyToOne에는 애초에 mappedBy 속성이 없다. 123456789@Target({METHOD, FIELD}) @Retention(RUNTIME)public @interface ManyToOne { Class targetEntity() default void.class; CascadeType[] cascade() default {}; FetchType fetch() default EAGER; 반면 OneToMany는 연관관계의 주인을 지정하는 mappedBy속성이 있는 것을 확인할 수 있다. 123456public @interface OneToMany { Class targetEntity() default void.class; CascadeType[] cascade() default {}; FetchType fetch() default LAZY; String mappedBy() default &quot;&quot;; 양방향 연관관계의 주의점 위 내용에 따르면, 연관관계의 주인이 외래키를 관리(저장)한다고 하였다. 따라서 객체 관점에서는 연관관계의 주인쪽에서만 연관관계의 주인이 아닌 entity 필드에 값을 넣어주고, 연관관계의 주인이 아닌 entity는 연관관계의 주인인 entity 필드에 값을 넣어줄 필요가 없을까? JPA 기술 상으로는 문제가 없으나, 순수 객체의 관점에서는 불일치 상태가 된다. 예를 들면 아래와 같은 테스트 코드에서 실제 DB에는 정상적으로 연관관계가 저장되었을지는 몰라도, 두 entity간에는 다른 정보를 가지고 있다. 1234567891011@Testvoid testBiDirection(){ Member member = new Member(&quot;id1&quot;, &quot;user1&quot;); Board boardA = new Board(&quot;title1&quot;,&quot;content1&quot;); Board boardB = new Board(&quot;title2&quot;,&quot;content2&quot;); // 연관관계 설정 boardA.setMember(member); boardB.setMember(member); assertThat(member.getBoardList().size()).isEqualTo(2); // fail!!! } 연관관계 편의 메소드 위와 같이 객체간의 불일치한 상태를 일치시켜주기 위해서 두 entity중에 하나에 한번에 양방향 관계를 설정해주는 연관관계 편의 method를 정의한다.1234567891011@Entity@Getter@NoArgsConstructorpublic class Member { //... //연관관계편의 메소드 public void addBoard(Board board){ this.boardList.add(board); board.setMember(this); }} 테스트를 해보면 정상적으로 성공되는 것을 확인할 수 있다. 경우에 따라 기존의 연관관계를 삭제하고 연관관계를 추가해야하는 상황이 올수도 있으니, 이 또한 고려해야 한다. 1234567891011121314@Testvoid testBiDirection(){ EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); Member member = new Member(&quot;id1&quot;, &quot;user1&quot;); Board boardA = new Board(&quot;title1&quot;,&quot;content1&quot;); Board boardB = new Board(&quot;title2&quot;,&quot;content2&quot;); // 연관관계 설정 member.addBoard(boardA); member.addBoard(boardB); assertThat(member.getBoardList().size()).isEqualTo(2);} 추가로 양방향 매핑시에 두 entity간에 toString이 서로를 순환참조할 수 있으므로, 대개는 entity에 toString method를 overriding 하진 않지만 (dto사용)그래도 조심하자. 정리 단방향 매핑을 먼저 시도하고, 비즈니스 로직에 따라 양방향을 사용하도록 변경하자, 그 이유는 양방향을 매핑하면 객체에서 양쪽 방향을 모두 고려해야 되는데, 이는 코드도 복잡해지고 , 굳이 반대 방향으로 객체 그래프 탐색을 하지 않는다면 필요없는 기능이다. 양방향 매핑에서 외래키를 관리할 entity를 연관관계의 주인이라고 부르며 보통 다대일,일대다에서 ‘다’ 측의 entity이다.(‘일’측을 연관관계의 주인으로 설정할 수는 있지만, DB 외래키를 가진 table과 다른 entity가 외래키를 관리하게 된다.) 양방향 매핑을 사용해야 한다면 , Entity 객체간에 연관관계를 맺어주는 연관관계 편의 method를 활용하자. 그래야 객체 관점에서도 일관성 있는 정보를 가지게 되며 테스트하기도 용이해진다.","link":"/2022/01/18/2022-01-18-Jpa-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"},{"title":"Item44. 표준 함수형 인터페이스를 사용하라","text":"표준 함수형 인터페이스Java가 람다를 지원하면서 API를 작성하는 모범사례도 크게 바뀌었는데, 대표적으로 template pattern이 함수 객체를 받는 정적 팩토리 method나 생성자를 제공하는 형태로 변경되었다. 즉 함수 객체를 매개변수로 받는 생성자와 method를 더 많이 만들어야 하는데 , 이때 함수형 매개변수 타입을 올바르게 선택해야 한다. 예시로 LinkedHashMap의 removeEldestEntry method는 put method에 의해 호출되어 true를 반환하면 map에서 가장 오래된 원소를 제거한다. 123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest){ return size() &gt; 100;} 다음과 같이 100개 미만의 크기를 가진 map의 경우에는 원소를 제거하지 않고, 100개 이상부터 오래된 원소를 제거하도록 구현할 수 있는데, 이를 함수형 인터페이스로 변경가능하다. 주의할점은 위 method가 instance method이기 떄문에, 람다를 사용할떄에는 Map instance도 매개변수로 받아야 한다. 1234@FunctionalInterfacepublic interface EldestEntryRemovalFunction&lt;K,V&gt; { boolean remove(Map&lt;K,V&gt; map , Map.Entry&lt;K, V&gt; eldest);} 위처럼 직접 선언하는 것도 가능은 하지만 java 내장 library (java.util.function) 에 다양한 용도의 표준 함수형 인터페이스가 담겨 있다. 따라서 적절한게 있다면 직접 구현하지말고 표준 함수형 인터페이스를 사용하는게 좋다. 위의 직접 구현한 함수형 인터페이스인 EldestEntryRemovalFunction도 표준 함수형 인터페이스인 BiPredicate&lt;Map&lt;K,V&gt; , Map.Entry&lt;K,V&gt;&gt; 로 대체할 수 있다. 표준 함수형 인터페이스 종류 java.util.function에 총 43개의 함수형 인터페이스가 존재한다. 대표적인 표준 함수형 인터페이스들은 다음과 같다. Operator&lt;T&gt; 반환값과 매개변수의 타입이 같은 함수로, 인수가 1개인 UnaryOperator, 인수가 2개인 BinaryOperator로 나뉜다. UnaryOperator&lt;T&gt; 123456@ParameterizedTest@CsvSource({&quot;ABC,abc&quot;})void testUnaryOperator(String upperCase , String lowerCase ){ UnaryOperator&lt;String&gt; function = String::toLowerCase; assertThat(function.apply(upperCase)).isEqualTo(lowerCase);} BinaryOperator&lt;T&gt; 123456@ParameterizedTest@CsvSource({&quot;100,200,300&quot;})void testBinaryOperator(Integer x , Integer y , Integer expectResult){ BinaryOperator&lt;Integer&gt; function = Integer::sum; assertThat(function.apply(x,y)).isEqualTo(expectResult);} Predicate&lt;T&gt; 인수를 하나 받아서 boolean을 반환 하는 함수 12345678910@FunctionalInterfacepublic interface Predicate&lt;T&gt; { /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return {@code true} if the input argument matches the predicate, * otherwise {@code false} */ boolean test(T t); 다음과 같이 빈리스트인지 여부를 판단하는 함수를 만들 수 있다. 12345@Testvoid testPredicate(){ Predicate&lt;List&gt; function = List::isEmpty; assertThat(function.test(new ArrayList())).isTrue();} Supplier&lt;T&gt; 인수를 받지 않고 값을 제공하는 함수 123456public interface Supplier&lt;T&gt; { /** * Gets a result. * @return a result */ T get(); 사용예시는 다음과 같이 객체를 생성해주는 제공자로서도 사용할 수 있다. 123456@Testvoid testSupplier(){ Supplier&lt;Food&gt; function = Food::new; assertThat(function.get()).isInstanceOf(Food.class);}private static class Food{} Consumer&lt;T&gt; 인수를 하나 받고 반환값이 없이, 인수를 소비하는 함수 123456public interface Consumer&lt;T&gt; { /** * Performs this operation on the given argument. * @param t the input argument */ void accept(T t); 123456789101112@Testvoid testConsumer(){ Consumer&lt;List&gt; consumer = (list) -&gt; list.forEach(System.out::println); consumer.accept(List.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;)); // a // b // c // d // e // f // g} Function &lt;T.R&gt; T type 매개변수를 받아서 R type 반환 하는 함수 123456789public interface Function&lt;T, R&gt; { /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); 사용 예시는 다음과 같다. 123456@ParameterizedTest@CsvSource({&quot;ABC,abc&quot;})void main(String upperCase , String lowerCase) { Function&lt;String,String&gt; function = String::toLowerCase; assertThat(function.apply(upperCase)).isEqualTo(lowerCase);} 위의 Java.util.Function의 표준 함수형 인터페이스들은 primitive type인 int,long,double 별로 각각 3개씩의 변형이 생겨난다. 예를 들면 int를 받는 Predicate는 IntPredicate , long을 받는 predicate는 LongPredicate , double를 받는 predicate는 DoublePredicate 가 있다. 특히 FunctionInterface에서는 기본 타입을 반환하는 변형이 9개가 더 있는데, 예를 들면 다음과 같은 형식이다. 1Result srcToResultFunction(Src value); 123456789public interface LongToDoubleFunction { /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ double applyAsDouble(long value); 추가로 입력매개변수만 generic으로 받고, 반환타입은 정해져있는 형식도 있다. 1Result ToResultFunction(T value); 12345678910public interface ToLongFunction&lt;T&gt; { /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ long applyAsLong(T value);} 이외에도 인수를 2개씩 받는 변형들이 존재한다. 예를 들면 BiPredicate&lt;T,U&gt;,BiFunction&lt;T,U,r&gt; , BiConsumer&lt;T,U&gt; 가 있다. 인터페이스 자체가 43개기 떄문에 외우는건 당연히 불가능하고 필요할떄마다 API문서를 뒤져서 찾아서 사용하면 된다. 어떨때 표준 함수 인터페이스 대신 직접 함수 인터페이스를 정의해야 하는가? Compartor&lt;T&gt; 인터페이스 경우에는 구조적으로 ToIntBiFunction&lt;T,U&gt;과 동일한데도, 표준 함수 인터페이스를 사용하지 않았다. 다음과 같은 특징을 갖는다면 직접 정의할 것을 고려해볼만하다. 자주 쓰이며 이름이 용도를 명확하게 설명해준다. 반드시 따라야 하는 규약이 존재한다. 유용한 Default Method 제공 함수형 인터페이스 사용 주의점 기본 타입을 받는 함수형 인터페이스에 박싱된 기본 타입을 넣어서 사용하면 성능적 이슈가 있어 사용에 주의해야 한다. 추가로 직접 만든 함수형 인터페이스에는 @FuntionalInterface를 달아 명시적으로도 람다용으로 설계되었음을 표기하고, method를 추가로 정의시에 compile error를 던지도록 만드는 것을 권고한다. 서로 다른 함수형 인터페이스를 같은 위치의 인수로 사용하는 overloading을 피해야 한다. client에게 혼동을 줄 수도 있다.","link":"/2022/01/21/2022-01-21-Item44/"},{"title":"정규화 (Normalization)","text":"정규화 이론의 목표 가능한 데이터 중복성(Redundancy)를 제거해서 한가지 사실은 한 곳에서만 나타난다라는 원칙을 지키도록 한다. 즉 정규화 과정(Normalization procedure)란 중복을 최소화하기 위해 데이터를 구조화 하는 작업이다. 정규화 과정을 통해 특정 조건을 만족시키는 relation을 정규형이라고 한다. 제 1,2,3…정규형 등이 존재한다. 왜 정규화가 필요한가? 정규화를 하지 않는 경우에 data redundancy로 인해 다음과 같은 이상현상들이 발생할 수 있다. insert annomaly (삼입 이상 ) : 특정 데이터를 삼입하고 싶은데, 자료가 부족해 삼입할 수 없다. 예를 들면 공급자,도시,부품이라는 attribute가 있다고 하면 공급자가 어떤 도시에 살고 있다는 정보는 부품이라는 정보가 있어야만 삼입할 수 있다. deletion annomaly (삭제 이상) : 하나의 정보를 삭제하고 싶지만, 필요한 정보까지 삭제될 수 있다. 위 예와 동일한데, tuple을 삭제할 경우에 공급자가 어떤 도시에 살고 있다는 정보가 소실될 수 있다. update annomaly (갱신 이상) : 데이터 갱신 중간 과정에 일부 data는 update된 상태, 일부 data는 original 상태로 inconsistent한 상태가 생길 수 있다. 정규형 만족 조건 분해 집합은 무손실 조인, 무손실 분해 (nonloss decomposition)를 만족해야 한다. 분해 집합은 함수적 종속성(functional dependency)을 보존해야 한다. Nonloss Decomposition (무손실 분해) 이란? non-loss decomposition : 특정 relation 을 다른 relation으로 분해하는 것으로 , 이 과정은 정보의 손실이 있어서는 안된다. 즉 가역적이여야 한다. 가역적이란 말은 분해 이후 다시 table을 join 하였을떄 최초의 relation과 동일해야 한다는 말이다. Functional Dependency (함수적 종속성) 이란? 특정 relation 안에서 하나의 속성 집합에서 다른 속성으로의 다대일 (many-to-one)관계이다. 정확한 정의는 다음과 같다. R을 relation이라 하고, X와 Y를 R의 속성 집합의 임의의 부분집합이라고 할때, Y가 X에게 함수적으로 종속되기 위한 필요 충분 조건은 다음과 같다. R에 있는 각각의 X의 값이 정확하게 하나의 Y의 값과 관련을 갖는 것이다. 이를 “X가 Y를 함수적으로 결정한다.” 또는 기호로는 X-&gt;Y 로 표시한다. 예를 들면 아래와 같은 relation에서 S# -&gt; CITY FD를 만족한다. 그 이유는 CITY가 S#에게 함수적으로 종속되기 위한 필요 충분 조건은 S#의 값이 정확하게 하나의 CITY의 값을 가지는 것인데,동일한 S# attribute는 동일한 CITY값을 가지기 때문이다. S# -&gt; CITY 에서 좌변을 결정자(determinant) , 우변을 종속자(dependent)라고 자주 부른다. 만일 x가 relation 의 후보키 (candidate key) 라면 반드시 relation의 모든 속성들 y는 x에 함수적으로 종속되어야 한다. 이는 후보키 정의를 보면 당연한데, 후보키 는 다음과 같은 성질을 만족할떄 후보키라고 한다. 유일성 : 유일하게 tuple을 식별 비분해성 : 해당 후보키의 부분 집합 중에 유일성을 만족시키는 부분집합이 없음 즉 유일성 필요충분조건에 따라 나머지 모든 속성들은 후보키에 함수적으로 종속될 수 밖에 없다. 제 1 정규형 어떤 relation 이 1NF 이기 위해서는 모든 attribute가 domain에 속하는 단 하나의 값만을 가져야 한다. 즉 대부분의 relation은 1NF를 대부분 만족한다 제 2 정규형 모든 non-key attribute가 primary key에 대해 최소성으로 종속적이다. 즉 기본키에 대해서 나머지 attribute들이 종속적이라는 말이다. 완전 함수적 종속이라고도 표현한다. 제 2 정규형을 만족시키기 위해서는 기본키에 대해 비최소성을 가지는 함수적 종속성을 제거하면 된다. 제 3 정규형 2NF를 만족함과 동시에, 모든 non-key attribute과 primary key에 대해 비이행적(non-transitive dependency)으로 종속적이다. 제 3 정규형을 만족시키기 위해서는 기본키를 제외한 non-key attribute간에 상호 종속성을 제거하면 된다. ex) 예를 들면 기본키인 S# attribute가 있을떄, S# 에 의해 나머지 두 attribute (city,status) 가 최소성으로 종속적이다. 2NF를 만족하는데, city에 의해 status attribute가 결정된다. 즉 이행적 종속관계가 있다는 말이다. 해당 relation의 FD를 정의하면 다음과 같을 것이다. s# -&gt; city s# -&gt; status city -&gt; status 여기서 S#-&gt;city-&gt;status 임으로 s# -&gt; status 임은 유추될 수 있는 이행적 함수 종속성임으로 제거될 수 있는 FD이다. 따라서 이를 decomposition하여 2개의 relation으로 나누어야 한다. 예를 들면 r1(s#,city) , r2(city,status) 로 2개의 relation으로 나누어질 수 있을 것이다. BCNF (Boyce/Codd Normal Form) 정규형 BCNF 정규형이 왜 나왔는가? 이전 3 NF 까지는 후보키가 둘 이상이고, 두 후보키가 복합속성이면서 일부 속성이 겹치는 경우에 데이터 중복이 생기는 현상을 다루지 못했다. 비직관적 (non-trivial) , 좌변-최소성(left-irreducible) FD들이 후보키를 결정자로 갖는 것이다. 즉 relation이 BCNF 정규형을 만족시키는 필요충분조건은 오직 후보키들만이 결정자가 되는 것이다. 종속성 다이어그램에서 화살표가 후보키에서만 나오는 것이라고 보면 된다. 이외에도 고등 정규형 4NF,5NF가 있는데, 대체로 3NF,BCNF 까지 정규화를 수행한다고 한다. 고등 정규형 4NF,5NF에 대해서는 별도로 정리하여 다루도록 하려고 한다. 정규화 정리정규화 과정의 목적은 Data 중복성을 제거해 여러가지 이상현상(삼입,삭제,갱신 이상) 현상들을 제거 하고, 실세계에 가깝게 데이터베이스를 설계해서 직관적으로 이해되고 , 확장이 쉬운 구조로 만드는 것이다. 역정규화 (Denormalization) 정규화 과정의 성능적인 이슈 정규화 과정을 거치면서 하나의 relation을 물리적으로 여러개의 relation 으로 분해가 이루어진다. 즉 I/O작업이 이루어질떄는 원하는 데이터를 가져올때 그만큼 많은 JOIN연산이 이루어질 수 있다. 따라서 성능적으로 이점을 얻고자 일부 데이터 중복을 허용하면서 JOIN 연산을 피하는 것이 역정규화이다.","link":"/2022/01/19/2022-01-19-db-normalization/"},{"title":"Item46. Stream에서는 부작용 없는 함수를 사용하라","text":"stream 은 api긴 하지만 함수형 프로그래밍에 기초한 패러다임이다. stream 패러다임의 핵심은 계산 연산을 일련의 변환 단계들로 재구성하는 것이다. 각 변환 단계는 가능한 이전 단계의 결과를 받아서 처리하는 순수함수여야 한다. 순수 함수 : 오직 입력만이 결과에 영향을 주고, 다른 가변 상태를 참조하지도 않는 함수","link":"/2022/01/23/2022-01-23-Item46/"},{"title":"제한적 직접 실행 (Limited Direct Execution)","text":"제한적 직접 실행 (Limited Direct Execution) 제한적 직접 실행과 반대되는 개념인 직접 실행(Direct Execution)은 프로그램을 한번 실행하면 종료될떄까지 cpu상에서 그냥 직접 실행시키는 것을 말합니다. 하지만 직접 실행 방식은 아래와 같은 문제점을 가지고 있습니다. 악의적인 process의 경우 os가 제어 불가 시분할 기법(time sharing) 구현 불가 +) 참고로 시분할 기법이란 process가 실행될떄 일정한 time quantuam 값내에서만 실행되고, 시간이 초과되면 timer interrupt를 발생시켜 다른 process로 context switching 하는 기법을 말합니다. 시스템 자원에 대한 제어 불가 예를 들면 user process가 디스크 입출력 요청이나, cpu , memory와 같은 시스템 자원에 추가할당을 요청할때, user process가 직접 시스템 자원을 꺼내쓴다면 악의적인 process의 경우 시스템 자원을 모두 점유하는 문제점이 있을 것입니다. kernel mode , user mode 위 시스템 자원에 대한 제어권을 운영체제가 제어하기 위해서 나온 개념이 사용자 모드(user mode) , 커널 모드(kernel mode)입니다. user process가 실행될떄는 user mode로 전환됩니다. 이 user mode에서는 할 수 있는 일이 제한되는데, 예를 들면 시스템 자원에 대한 요청 (ex)입출력 요청등) 이 제한됩니다. 시스템 자원에 대한 요청은 kernel mode에서 가능합니다. user mode 에서 kernel mode로 전환이 일어나는 메카니즘은 system call입니다. system call 입출력 요청 , 디스크 읽기와 같은 명령어를 privilliged instruction 이라고 합니다. 이러한 privilliged instruction이 수행되기 위해서는 user process는 system call을 통해 kernel에게 요청해야 합니다. system call을 실행시키기 위해서는 user process는 trap 특수 명령어를 실행시킴으로서, kernel 안으로 코드가 분기됨과 동시에 user mode 에서 kernel mode로 조정됩니다. 이떄 trap 명령어를 실행한 시점에 각 process의 kernel stack에 해당 user process가 실행중이던 context (register 값, Program counter 값) 를 저장합니다. user process가 요청한 작업이 끝나면 운영체제는 return-from-trap 특수 명령어를 실행함을 통해서 다시 user mode로 조정하고, 분기되었던 코드로 return 하고, kernel stack의 데이터는 모두 제거됩니다. trap table trap 명령어을 통해 kernel mode로 전환하고 운영체제에게 user process가 시스템 자원에 대한 서비스를 요청한다는 게 위 내용들의 정리입니다. 그런데 kernel mode로 전환하고 나서 kernel이 어떤 코드를 실행할지에 대한 정보가 필요합니다. 예를 들면 interrupt 종류가 다양한데, timer interrupt , arithmetic exception … 어떤 interrupt가 발생했을떄,trap 명령어를 통해 어떤 커널의 함수 (handler) 를 실행할지에 대한 정보는 바로 trap table에 있습니다. 모든 system call은 고유의 번호(식별자)를 갖습니다. 따라서 user process가 원하는 system call을 호출하기 위해서는 해당 번호를 통해 trap 명령어를 호출합니다. 이떄 trap table를 보고 trap handler의 주소를 보고 호출합니다. &lt;1번,segment_fault method address&gt; 전체 제한적 직접 실헁 (limited direct execution ,LDE) 순서를 보면 위 표와 같습니다. 먼저 부팅시에 kernel은 trap table을 초기화하고, cpu는 이 trap table의 위치를 기억해둡니다. 이후에 user process를 실행하기 전에 해당 process에 대한 자료구조(pcb)를 추가하고, 메모리를 할당하는 작업이 일어납니다. user process가 실행중에 system call 요청하면 user process의 실행중인 상태 (context)를 kernel stack에 저장해두고, trap 명령어를 통해서 trap handler를 보고 해당 system call 번호에 맞는 trap handler를 실행합니다. 동시에 kernel mode로 조정됩니다. system call이 수행되고 나서는 return-from-trap 명령어를 통해 다시 user mode로 돌아가는 데, 이떄 kernel stack에 저장된 user process의 context를 복구하고, user process의 명령어가 실행중이던 위치를 program counter를 보고 다시 찾아가 해당 명령어부터 실행합니다. time sharing 앞선 방식으로 user process가 직접 시스템 자원을 마음대로 조절할수 없게 권한을 제한하였습니다. 그러면 process간 전환은 어떤 메카니즘으로 해결 가능하냐는 의문이 남아있습니다. 만약 process 간 전환을 제어하지 않는다면 특정 process가 cpu가 독점한다는 문제점이 있습니다. 위처럼 process간 전환을 제어하지 않고, user process가 system call을 호출해 운영체제가 제어권을 가질떄까지 기다리는 협조 방식이 있습니다. 이 방식은 system call이 호출되지 않는 상황이라면 여전히 process간 전환이 정상적으로 일어나지 않는다는 단점이 있습니다. preemptive scheduling system call이 없더라도 하드웨어적으로 process로부터 cpu제어권을 뺏는 방법이 있습니다. 바로 일정 time quantuam(대개 10ms) 이후에는 하드웨어 신호를 통해 timer interrupt를 발생시키는 것입니다. interrupt가 발생하게 되면 운영체제는 현재 실행중인 process를 중단시키고, 해당 interrupt에 대한 interrupt handler가 실행됩니다. process가 중단(blocked)되면 다음에 어떤 process를 실행시켜야 할지 결정해야 합니다. 이부분은 scheduler에 관련된 내용으로 scheduler 종류, 전략도 다양합니다. 어쩄든 scheduler를 통해 실행시킬 process가 결정되고 나면 context swithcing (문맥 교환) 을 통해 이전 process 의 context를 kernel stack에 저장하고, 새로이 실행될 process의 context를 kernel stack으로부터 복구합니다. 이후에는 pc 값을 보고 새로이 실행될 process가 cpu를 할당받아 실행됩니다. 이 과정을 표로 보면 다음과 같습니다. 참고로 context switching 을 하는데도 시간이 소요됩니다. (4~6 마이크로초 단위) 따라서 context switching이 너무 자주 일어나게 되면 오히려 cpu 가 user process의 코드를 실행하는 시간이 줄어들는 오버헤드가 발생합니다.","link":"/2022/01/24/2022-01-24-os-limited-direct-execution/"},{"title":"Item43. 람다보다는 메소드 참조를 사용하라","text":"method reference 메소드 참조 표현식 ( method reference expression )method reference 는 람다식에서 기존에 존재하던 하나의 정적,인스턴스 method를 호출만할떄, 불필요한 매개변수를 제거하고 람다식을 더 간결하게 사용할 수 있게 해줌(ref - https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html) 아래는 임의의 키와 Integer값을 매핑하는 map 인데, 이떄의 merge method는 키,값,함수를 매개변수로 받아서 주어진 키가 맵안에 없다면 키,값쌍을 그대로 저장하고, 키가 이미 있다면 세번쨰 인수로 들어온 함수에 현재 값과 주어진 값을 적용해 키,함수의 결과쌍을 저장한다. 1map.merge(key,1,(count,incr)-&gt;count+incr); 위에서 세번쨰 매개변수로 함수형 인터페이스를 구현한 람다는 그저 두 인수의 합을 반환하는 역할을 하는데 Integer의 static method인 sum을 이용하면 코드의 가독성을 증가시킬 수 있다. 1map.merge(key,1,Integer::sum); 또한 람다로 구현했을때, 코드가 너무 길거나 복잡한 경우에 람다의 코드를 method로 추출해서 해당 method reference를 사용하는 방식이다. 이렇게 하게 되면 method에 적합한 naming을 할 수 있게 해준다. 항상 그렇지는 않는데, 예를 들면 method가 람다와 같은 class안에 있을때는 그저 method를 호출하는게 더 간결할 수도 있다. 예를 들면 람다와 method가 간 아래와 같이 class 명을 가진 존재한다고 하면 1234// method reference 방식service.execute(GoshThisClassNameIsHumongous::action);// method 직접 호출 방식service.execute(()-&gt;action()); 람다식이 더 간결할 수도 있다. method reference 종류 static method를 가르키는 method reference 1Integer::parseInt instace method를 가르키는 method reference 수신 객체를 제한하는 한정적 instance method reference 수신 객체를 제한하지 않는 비한정적 instance method reference 한정적 instance method reference는 함수 객체가 받는 인수와 참조되는 method가 받는 인수가 똑같다. 1Instance.now()::isAfter 비한정적 instance method reference는 함수 객체를 적용하는 시점에 수신 객체를 알려준다. 주로 stream 파이프라인에서 매핑과 필터 함수에 사용된다. 1String::toLowercase() 클래스 생성자를 가르키는 method reference 1TreeMap&lt;K,V&gt;::new 배열 생성자를 가르키는 method reference 1int[]::new","link":"/2022/01/19/2022-01-19-Item43/"},{"title":"Item49. 매개변수가 유효한지 검사하라","text":"매개변수 검사 시점method와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 예컨대 인덱스 값은 음수이면 안되며, 객체 참조는 null이 아니어야 한다는 식이다. 이런 제약은 반드시 문서화해야 하며, method 몸체가 시작되기 전에 검사해야 한다. method 몸체가 실행되기 전에 매개변수를 확인한다면, 잘못된 값이 넘어왔을때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다.그렇지 않은 경우에는 다음과 같은 단점을 가질 수 있다. method가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다. 잘못된 결과가 나온다. 객체를 이상한 상태로 변경해서 , 해당 method에서는 정상적으로 수행되는 것 처럼 보이지만, 미래의 시점에서 해당 method와 관련없는 오류를 낸다. 매개변수 검사 관련 문서화public 과 protected method는 매개변수 값이 잘못됬을 떄 던지는 예외를 문서화해야한다. (@throws javadoc 이용)예를 들면 다음과 같다. 1234567891011121314/*** * 현재값의 나머지 값을 반환한다. * 이 method는 항상 음이 아닌 * @param m 계수 (양수여야 한다.) * @return 현재값의 나머지 값 * @throws ArithmeticException m이 보다 작으면 발생한다. * */public BigInteger mod(BigInteger m){ if(m.signum() &lt;= 0 ){ throw new ArithmeticException(&quot;계수(m)는 양수여야 합니다. &quot; + m); }//...} 만약 개별 method에 적용되는 사항이 아니라 전체 public method에 적용된다면 class애 기입하면 된다.위의 예에서도 매개변수가 null일떄, NullPointerException을 던진다는 설명은 class 수준에 기입되어 있다. jdk 7부터 추가된 java.util.Objects.requireNonNull method는 null검사를 수동으로 하지 않게 해주며, 원할경우 예외 메시지도 두번쨰 매개변수로 넘겨줄 수 있다. 1this.strategy = Objects.requireNonNull(strategy,&quot;전략&quot;); assert 예약어공개되지 않은 method라면 method가 호출되는 상황을 통제해야 한다. 오직 유효한 값만이 method에 넘어오는 것을 보증해야한다. 12345private static void sort(long a[], int offset , int length){ assert a != null; assert offset &gt;= 0 &amp;&amp; offset &lt;= a.length; assert length &gt;= 0 &amp;&amp; length &lt;= a.length - offset;} 위처럼 assert 를 사용해 매개변수 유효성을 검증할 수 있다.assert에서는 표현식을 확인해 무조건 참이라고 선언하고 실패하면 AssertionError를 던진다.runtime에 assert문을 활성화시키려면 java -ea , -enableassertions 로 실행해야한다.(https://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html) method가 직접 사용하진 않으나, 나중에 쓰기 위해 저장하는 매개변수는 특히 신경써서 검사해야 한다.또한 생성자에서도 매개변수 유효성검사는 클래스 불변식을 어기는 객체가 만들어지지 않도록꼭 필요하다. 예외사항 유효성검사 비용이 지나치게 높은 경우, 실용적이지 않은 경우와 계산 과정에서 암묵적으로 검사가 수행될 때 예를 들어 Collections.sort(List)의 List내 모든 객체는 상호 비교될 수 있어야 하며, 그렇지 않을 경우에는 해당 객체와 비교할떄 classCastException을 던진다. 따라서 method호출이전에 유효성검증을 하더라도 실효성이 없다. 추가로 던지기로 한 예외와 API문서 예외가 다르다면 예외 번역 (exception translate)관용구를 사용하여 API에 기재된 문서로 번역해주어야 하는데 이 부분은 Item 73에서 다룬다.","link":"/2022/01/27/2022-01-27-Item49/"},{"title":"Item48. Stream 병렬화는 주의해서 적용하라","text":"jdk 8 부터는 parallel method만 한번 호출하면 pipeline을 병렬 실행할수 있는 stream을 지원하기 시작했다. stream 병렬화는 함부로 사용하면 오히려 성능 저하를 야기할 수 있다. 아래와 같아 처음 20개의 메르센 소수를 생성하는 프로그램이 있다고 가정하자 123456789public static void main(String[] args) { primes().map(p-&gt;TWO.pow(p.intValueExact()).subtract(ONE)) .filter(mersenne -&gt; mersenne.isProbablePrime(50)) .limit(20) .forEach(System.out::println);}static Stream&lt;BigInteger&gt; primes(){ return Stream.iterate(TWO ,BigInteger::nextProbablePrime);} 이를 병렬로 처리하고자 stream pipeline의 .parallel() method를 호출하면 오히려 프로그램 수행 시간이 극단적으로 느려지게 된다. 그 이유는 stream library 가 pipeline을 병렬화하는 방법을 찾지 못했기 때문인데, 데이터 소스가 stream.iterate거나,중간 연산으로 limit를 쓰면 pipeline병렬화로는 성능개선을 기대할 수 없다. limit을 다룰때 CPU 코어개수가 남는다면 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정하는데, 위 메르센소수를 찾는 프로그램은 원소하나의 계산비용이 그 원소 이전에 계산한 모든 원소들의 비용을 합친 것 만큼 든다. 즉 메르센 소수를 찾는 프로그램의 경우 몇 개 더 처리한 후 제한된 개수 이후의 결과를 얻는 불필요한 비용 자체도 많이 든다. Stream 병렬화 효과가 좋은 데이터대체로 Stream의 Source가 ArrayList , HashMap , HashSet , ConcurrentHashMap 의 인스턴스거나 , 배열일때 병렬화의 효과가 가장 좋다. 위 병렬화에 적합한 자료구조들은 다음과 같은 특징을 가지고 있다. 원하는 크기로 정확하게 손쉽게 나눌 수 있다. 즉 다수의 thread에게 일을 분배하기 좋다는 특징이 있다. 참조 지역성(locality of reference)이 뛰어나다. 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있다 (공간 지역성)만약 참조 지역성이 낮으면 Thread는 데이터가 메모리로 전송될떄까지 대기하게 된다.따라서 참조지역성은 다량의 데이터를 처리하는 벌크 연산을 병렬화할때 아주 중요한 요소로 작동하는데, 참조 지역성이 가장 뛰어난 자료구조는 기본 타입 배열이다.(참조 지역성이란 기억 장치(SSD,HDD)로부터 데이터가 참조될때, 시간적/공간적/순차적으로 분포가 집중되는 성질 ) 병렬화에 적합한 종단 연산Stream pipeline에서는 종단 연산의 동작 방식 역시 병렬 수행 효율에 영향을 준다.종단 연산에서 수행하는 작업량이 pipeline 전체 작업에서 상당 비중을 차지하면서 순차적인 연산이라면 병렬 수행 효과는 제한 될 수 밖에 없다. 축소(reduction).축소는 pipeline에서 만들어진 모든 원소를 하나로 합치는 작업으로, Stream의 reduce method중 하나 , 혹은 min , max , count , sum과 같이 완성된 형태로 제공되는 method 중에 하나를 선택해 수행한다. anyMatch,allMatch,noneMatch 처럼 조건에 맞으면 바로 반환되는 method 반면 가변 축소를 수행하는 Stream의 collect method는 병렬화에 적합치 않은데, collection을 합치는 부담이 크기 떄문이다. 추가로 병렬화 성능을 높이고 싶다면 spliterator를 overriding 하고, 결과 stream의 병렬화 성능을 테스트하는 방안이 있다. 안전 실패 (safety failure)stream을 잘못 병렬화하면 성능 뿐 아니라 결과 자체도 원하지 않는 결과가 나올 수 있는데, 결과가 잘못되거나 오작동 하는 것을 안전 실패라고 한다. 안전 실패는 병렬화한 pipeline이 사용하는 mapper , filter 혹은 programmer가 제공한 다른 함수 객체가 명세대로 동작하지 않을떄 벌어질 수 잇다. 따라서 Stream 명세에 적힌 함수 객체에 대한 규칙을 지켜서 제공해야 한다. 예를 들면 Stream의 reduce 연산에 건내지는 accumulator , combiner 함수는 반드시 아래와 같은 규칙을 만족해야한다. 결합 법칙 만족 간섭받지 않아야 함 상태를 갖지 말아야 한다. stream 병렬화는 오직 성능 최적화 수단이다. 따라서 다른 최적화와 마찬가지로 변경 전후에 성능을 테스트해서 병렬화했을때, 성능이 올라갔는지 확인해보아야 한다. 좋은 병렬화 예시다음은 n보다 작거나 같은 소수의 개수를 계산하는 함수이다. 123456static long pi(long n){ return LongStream.rangeClosed(2,n) .mapToObj(BigInteger::valueOf) .filter(i-&gt;i.isProbablePrime(50)) .count();} 이를 병렬화시키면 약 3배 정도의 성능향상을 기대할 수 있다. 1234567static long pi(long n){ return LongStream.rangeClosed(2,n) .parellel() .mapToObj(BigInteger::valueOf) .filter(i-&gt;i.isProbablePrime(50)) .count();} 추가로 무작위로 이루어진 stream을 병렬화할떄는 ThreadLocalRandom,Random 보다는 SplittableRandom 을 사용하면 병렬화시 성능적 장점을 가질 수 있다.","link":"/2022/01/27/2022-01-27-Item48/"},{"title":"Scheduling","text":"FIFO (First in, First out)FIFO(First-in-First-out,선입선출) 또는 FCFS(First-Come-First-Served,FCFS) 스케쥴링이다. 말그대로 먼저 도착한 process부터 cpu를 할당받는 것이다. FIFO방식의 가장 큰 문제점은 작업 실행 시간이 긴 process가 먼저 왔을때, 뒤에 있는 process들이 이를 끝나기를 기다려야 한다는 점이다. 이를 convoy effect라고 부른다. SJF(Shortest Job First)가장 짧은 실행 시간을 가진 작업을 먼저 실행시킨다. FIFO에서 가지는 convoy-effect문제를 해결할 수 있으나, 모든 작업이 동시에 도착한다는 가정하에서다. 즉 긴 작업이 짧은 작업보다 먼저 도착한다면 여전히 convoy-effect문제가 발생할 수도 있다. 예를 들면 위처럼 작업시간이 긴 A라는 process가 먼저 도착했고, 그 뒤에 작업 시간이 짧은 B,C가 도착하였다. SJF는 비선점형이므로, A가 끝날떄까지 기다려야 한다. 위의 FIFO와 SJF는 비선점형 scheduler로 각 작업이 종료될떄까지 계속 수행된다. 이제부터 정리할 스케쥴링 알고리즘은 선점형 방식으로 작업이 종료되기 전에 다른 작업으로 전환이 가능하다 STCF (Shortest Time-to-Completion First)SJF 스케쥴링 알고리즘에 선점기능을 추가한 알고리즘이다. 즉 새로운 작업이 도착하면 현재 실행중인 작업의 잔여 실행시간과 새로운 작업의 작업 실행 시간을 비교해서 , 더 짧은 작업을 스케쥴링한다. STCF 방식은 스케쥴링 평가 기준이 단지 반환 시간 하나라면 좋은 알고리즘이겠지만, 응답 시간 (response time) 측면에서는 성능이 떨어질 수 있다. 응답시간 = 작업이 처음으로 도착하는 시점 - 작업이 처음으로 스케쥴 될 시점 STCF,SJF,FCFS 방식은 모두 작업의 실행시간을 사전에 알고 있다고 가정한다. Round Robin 응답 시간 문제를 해결하기 위해서 Round Robin 스케쥴링 알고리즘이 도입되었다. Round Robin 방식은 마찬가지로 선점형 스케쥴러로 일정시간 동안 작업을 실행 한후에 다음 작업으로 전환한다. 이떄 작업이 실행되는 일정 시간을 time slice , scheduling quantum이라 부른다. 위 figure와 같이 SJF 방식은 응답시간이 좋지 않다 반면 Round robin 방식은 매 time slice 마다 context switching을 통해서 응답시간을 빠르게 해준다. 하지만 반환 시간이라는 기준으로 보았을떄, round robin은 SJF 방식보다 좋지 않다. time slice의 길이가 round robin 성능에 중요한 영향을 끼치는데, 너무 짧게 설정하면 context switching overhead가 커지나, 응답시간은 빨리질것이다. 입출력 연산시 schedulingDisk I/O와 같은 작업시에 해당 process는 blocked되고, 다른 process가 scheduling 알고리즘에 따라 스케쥴링되고 cpu를 할당받는다. 입출력 완료시에는 다시 process는 준비 상태가 된다. 즉 입출력 연산과 cpu 사용을 병렬화하여 시스템 사용률을 향상시키는 방법을 사용하고 있다.","link":"/2022/01/27/2022-01-27-os-scheduling/"},{"title":"Item51. method 시그니처를 신중히 설계하라","text":"이번 아이템에서는 API 설계 권고 사항들을 정리하였다. method 이름을 신중히 짓자. 항상 표준 명명 규칙 (Item68)을 따라야 한다. 같은 패키지에 속한 다른 이름들과 일관되게 짓는게 최우선이다. 개발자 커뮤니티에서 널리 받아 들여지는 이름을 사용하자 긴 이름은 피하자 편의 method를 너무 많이 만들지 말자 method가 너무 많은 class는 익히고 , 사용하고, 문서화하고 , 테스트하고 유지보수하기 어렵다. 따라서 아주 자주 쓰일때만 편의 method로 만들자 매개변수 목록은 짧게 유지하자 매개변수가 4개를 넘어가면 가독성이 떨어진다. 같은 type의 매개변수가 여러개 연달아 나오는 경우에는 특히 순서가 변경되어도 그대로 실행됨으로 좋지 않다. 매개변수 목록을 줄이는 방법 여러 method로 분리하고, 분리한 method는 매개변수의 부분 집합을 받는다. method가 너무 많아질 수 있으나, 직교성을 높여 오히려 method수를 줄여주는 효과도 있다.여기서 직교성을 높인다는 말은 method간에 중복이 줄고, 결합성이 낮아져서 method들을 통해서 필요한 기능을 조합해서 만들수 있음으로 method수가 낮아질 수도 있다는 말이다. 매개변수 여러개를 묶어주는 도우미 class를 만든다. 일반적으로 이러한 도우미 class는 정적 멤버 class로 둔다. 빌더 패턴과 유사한 방식으로, 모든 매개변수를 하나로 추상화한 객체를 정의하고, client에서 이 객체의 setter method를 호출해 필요한 값을 설정하게 하는 것이다. 매개변수의 타입으로는 클래스보다는 인터페이스가 낫다.인터페이스를 넘기면, 그 인터페이스의 모든 구현체를 인수로 전달할 수 있다. 만약 클래스를 인수로 받게 하면 해당 구현체만 사용하도록 제한하게 된다. boolean 보다는 원소 2개짜리 열거 타입이 낫다.예를 들어 아래와 같이 화씨온도(FAHREHEIT) 와 섭씨온도(CELSIUS)를 원소로 정의한 열거 타입이 있다고 가정하자. 123public enum TemperatureScale { FAHRENHEIT , CELSIUS} 온도계 class가 있고, TemperatureScale enum class 타입에 따라 적합한 온도계 class를 생성한다고 하면 아래와 같은 정적 팩토리 method를 만들 수 있을 것이다. 123static Thermometer newInstance(TemperatureScale scale){ // ...} 만약 매개변수로 enum type을 받지 않고, boolean type으로 true이면 화씨온도계, false면 섭씨온도계로 온도계 class의 instance를 만든다면 가독성도 떨어지고, 확장성도 떨어진다.","link":"/2022/01/27/2022-01-27-Item51/"},{"title":"Item50. 적시에 방어적 복사본을 만들라","text":"클래스 불변식을 클라이언트가 꺠트릴 수 없도록 방어적으로 프로그래밍해야 한다. 다음과 같이 클래스 불변식을 유지하고자 하는 class가 있다고 가정하자 123456789101112131415161718192021222324252627public final class Period { private final Date start; private final Date end; /*** * @param start 시작 시간 * @param end 종료 시각 , 시작 시간보다 뒤여야 한다. * @throws IllegalArgumentException : 시작 시간이 종료시각보다 늦을떄 발생한다. * @throws NullPointerException : start나 end가 null이면 발생한다. */ public Period(Date start, Date end) { if(start.compareTo(end) &gt; 0){ throw new IllegalArgumentException(start + &quot; after &quot; + end); } this.start = start; this.end = end; } public Date start(){ return start; } public Date end(){ return end; }} Period class는 한번 값이 설정되면 변경되지 않는 것 처럼 보이나 Date class 자체가 가변이라는 사실을 이용하면 클래스 불변식을 꺠트릴 수 있다. 123456public static void main(String[] args) { Date start = new Date(); Date end = new Date(); Period p = new Period(start, end); end.setYear(68); // p 객체의 값이 변경된다. } 따라서 Period class를 불변으로 유지하려면 불변 필드인 Instant를 사용해야 한다. 방어적 복사 (defensive copy)외부 공격으로부터 class 불변식을 유지하려면 생성자에서 받은 가변 매개변수는 모두 방어적으로 복사해야 한다. 예시로든 Period class에 방어적 복사를 적용하면 다음과 같이 생성자에서 복사본을 필드로 가지게 만들고, 접근자에서도 복사본을 반환함으로서 클래스 불변식을 유지할 수 있다. 12345678910111213141516public Period(Date start, Date end) { this.start = new Date(start.getTime()); this.end = new Date(end.getTime()); if(this.start.compareTo(this.end) &gt; 0){ throw new IllegalArgumentException(start + &quot; after &quot; + end); }}public Date start(){ return new Date(start.getTime());}public Date end(){ return new Date(end.getTime());} 주의할점은 매개변수의 유효성을 검사하기전에 방어적 복사본을 만들고 나서, 이 복사본으로 유효성 검사를 해야한다는 점이다. 멀티쓰래드 환경에서 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순산에 다른 thread가 원본 객체를 수정할 위험이 있기 떄문이다. (이를 검사시점/사용시점(time-of-check/time-of-use) 공격 혹은 TOCTOU 공격이라고 한다.) clone method를 사용해서 복사하지 않은 이유는 매개변수가 client에 의해 확장되어 clone method가 악의적인 method로 overriding될 수 있기 때문이다. 따라서 매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안된다. 방어적 복사에 대한 고려사항매개변수를 방어적으로 복사하는 목적은 불변 객체를 만들기 위해서만은 아닌데, method든 생성자든 client가 제공한 객체의 참조를 내부의 자료구조에 보관할떄면 항상 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다. 만약 변경된다면 , 변경이 클래스의 동작에 영향을 끼치는지 여부를 판단해서 방어적 복사 여부를 결정하면 된다. 애매한 경우에는 방어적 복사를 수행하는게 좋다. 방어적 복사가 성능적인 이유로 사용이 불가능하다면 반환값이나, 매개변수를 수정하면 안됨을 문서화해야 한다. 방어적 복사를 생략해도 되는 상황은 해당 class와 client가 상호 신뢰할 수 있을떄, 혹은 불변식이 깨지더라도 그 영향이 오직 호출한 client로 국한될때로 한정해야 한다.","link":"/2022/01/27/2022-01-27-Item50/"},{"title":"Item45. Stream은 주의해서 사용하라","text":"Stream API 개념Stream API는 Jdk 8부터 다량의 데이터 처리 작업 (순차적,병렬적) 을 도와주기 위해 추가되었다. Stream API의 핵심 개념은 다음과 같다. Stream : 유한 또는 무한개의 데이터 원소 시퀀스이다. Stream pipeline : 원소들로부터 수행하는 각 연산단계를 표현하는 개념 Stream API 특징 데이터를 담고 있는 저장소가 아니다. Stream안의 데이터 원소들은 객체 참조나 기본 타입 값 (int,long,double 3가지 ) 이다 Functional in nature. 원본 데이터를 변경하지 않는다. Laziness-seeking.stream API는 2가지 연산으로 나뉜다. map,filer 와 같은 intermediate operation (중개 연산) , collect와 같은 terminal operation (종료 연산)이 있다.중개 연산은 stream을 반환하고 종료 연산은 stream 타입을 반환하지 않는다. 중개 연산은 lazy evalutation(지연 평가) 된다고 공식 문서에 적혀 있는데,이는 종료형 연산( 예를 들면 .collect(toList())) 이 오기전까지는 중개 연산이 실행자체가 되지 않기 떄문이다. 12345List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).stream().map((s) -&gt; { System.out.println(&quot;s = &quot; + s); return s.toUpperCase(); });// terminal operation이 수행되기 전까지 실행되지 않음 (lazy) Stream으로 처리되는 데이터는 오직 한번만 처리된다 (각각의 stream 내 operator를 한번씩만 지나간다. ) 스트림내 데이터 원소가 무제한일수도 있다. (short circuit method를 사용해서 제한할 수 있다. ) 병렬처리가 가능하다. 12345678// parallelStream : Jvm 이 병렬처리해줌 // 데이터가 적은 경우에 불필요하게 병렬처리시에는 thread context swithing overhead 가 있어 오히려 느려지는 경우도 있음foods.parallelStream().forEach((food)-&gt; System.out.println(&quot;current thread : &quot; + Thread.currentThread().getName()));/*current thread : ForkJoinPool.commonPool-worker-5 current thread : ForkJoinPool.commonPool-worker-19 current thread : main*/ 보다 자세한 stream에 대한 설명은 아래 reference 에서 확인할 수 있다. (https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html) Stream 적용 예시기존에 다음과 같이 anagram을 찾아서 출력해주는 프로그램이 있다고 가정하자, 아래 프로그램은 Stream API를 사용하지 않은 코드이다. 123456789101112131415161718192021222324private static void reportAnagrams(String[] args) throws FileNotFoundException { File dictionary = new File(args[0]); int minGroupSize = Integer.parseInt(args[1]); // 최소 길이 Map&lt;String, Set&lt;String&gt;&gt; groups = new HashMap&lt;&gt;(); try(Scanner s = new Scanner(dictionary)) { while (s.hasNext()) { String word = s.next(); groups.computeIfAbsent(orderByAlphabet(word), (unused) -&gt; new TreeSet&lt;&gt;()).add(word); } } for (Set&lt;String&gt; group : groups.values()) { if(group.size() &gt;= minGroupSize){ System.out.println(group.size() + &quot;: &quot; + group); } }}private static String orderByAlphabet(String s){ char[] a = s.toCharArray(); Arrays.sort(a); return new String(a);} 사용자는 매개변수로 파일과 , Anagram의 최소 단어 수를 넘겨주면 파일의 단어를 while loop를 돌면서 computeIfAbsent method를 호출한다.computeIfAbsent method는 키가 없으면 새로운 키를 집어넣고, 함수 객체를 실행해서 반환받은 값을 넣어준다. 그리고 값을 반환해준다.반면 키가 있다면 키에 매핑된 값을 반환한다. 123456789//computeIfAbsent API 학습테스트 @ParameterizedTest@CsvSource({&quot;inputStr&quot;})void testComputeIfAbsent(String input){ Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(input,input.length()); assertThat(map.computeIfAbsent(&quot;newKey&quot;,(key)-&gt;key.length())).isEqualTo(6); assertThat(map.computeIfAbsent(input,(key)-&gt;key.length())).isEqualTo(input.length());} computeIfAbsent method로 키(정렬된 단어)가 없다면 키를 집어넣고, 값으로 쓰일 빈 TreeSet을 반환해주고, TreeSet에 단어를 넣어준다. 마지막으로 for loop를 돌면서 사용자가 매개변수로 넘긴 Anagram 최소 단어 수보다 긴 Anagram만 출력해준다. 이를 Stream API를 과용하는 형태로 바꾸면 다음과 같다. 12345678910111213141516171819// stream API 활용 private static void reportAnagrams(String[] args) throws IOException { Path dictionary = Paths.get(args[0]); int minGroupSize = Integer.parseInt(args[1]); // 최소 길이 try(Stream&lt;String&gt; words = Files.lines(dictionary)){ words.collect( groupingBy( word -&gt; word.chars().sorted() .collect(StringBuilder::new , (sb,c) -&gt; sb.append((char) c) , StringBuilder::append).toString() ) ).values().stream() .filter(group-&gt;group.size() &gt;= minGroupSize) .map(group -&gt; group.size() + &quot;:&quot; + group) .forEach(System.out::println); }} 코드가 짧아지긴 했지만 Stream 를 과용해서 오히려 이해하기 힘들어졌다. Stream을 적절하게 활용한 예는 다음과 같다. 1234567891011private static void reportAnagrams(String[] args) throws IOException { Path dictionary = Paths.get(args[0]); int minGroupSize = Integer.parseInt(args[1]); // 최소 길이 try(Stream&lt;String&gt; words = Files.lines(dictionary)){ words.collect(groupingBy(word-&gt;alphabetSize(word))) .values().stream() .filter(group-&gt;group.size() &gt;= minGroupSize) .forEach(group -&gt; System.out.println(group.size() + &quot;:&quot; + group)); }} Stream vs 코드 블록 반복문stream pipeline은 주로 되풀이 되는 계산을 함수 객체로 표현한다. 반면 반복 코드에는 코드 블록을 사용해 표현한다. 두 방식의 차이점은 다음과 같다 코드 블록에서는 범위 안의 지역변수를 읽고 수정할 수 있다. 하지만 람다에서는 final이거나 effectively final인 변수만 읽을 수 있고, 지역변수를 수정하는 것은 불가능하다. 코드 블록에서는 return 문을 이용해 method를 빠져나가거나, break, continue 문 사용이 가능하고, 예외를 던질 수도 있다. 하지만 람다에서는 불가능하다. 따라서 위와 같은 코드 블록에서만 할 수 있는 일이 필요하다면 반복 코드를 사용해야 한다.또 데이터가 stream pipeline의 각 단계(연산)에서 나온 값들을 동시에 접근하고자 할떄도, stream을 사용하기 어렵다. stream은 한 원소를 다른 값에 매핑하고 나면 원래 값은 잃는 구조이기 때문이다. 어떨때 Stream을 써야하는가? 원소들의 sequence를 일관되게 변환한다. 원소들의 sequence를 필터링한다. 원소들의 sequence를 하나의 연산을 사용해서 결합한다. 원소들의 sequence를 collection에 모은다. 원소들의 sequence에서 특정 조건을 만족하는 원소를 찾는다. stream과 반복중에 어떤 쪽을 써야할지 애매한 경우도 있다 예를 들면 다음과 같이 카드의 숫자(rank)와 무늬(suit) 열거타입이 있고, 두조합으로 만들 수 있는 카드를 모두 반환하는 method가 있다고 가정하자 123456789101112131415161718// 반복 methodpublic static List&lt;Card&gt; newDeck(){ ArrayList&lt;Card&gt; result = new ArrayList&lt;&gt;(); for (Suit suit : Suit.values()) { for (Rank value : Rank.values()) { result.add(new Card(suit,rank)); } } return result;}// Stream APIprivate static List&lt;card&gt; newDeck(){ return Stream.of(Suit.values()) .flatMap(suit -&gt; Stream.of(Rank.values()) .map(rank -&gt; new Card(suit,rank))) .collect(toList();} 추가로 flatMap 중간 연산은 stream의 원소 각각을 하나의 stream으로 매핑한 다음, 그 stream들을 다시 하나의 stream으로 합친다. 이를 평탄화(flattening) 이라고 한다. 개인마다 반복문을 쓰거나, streamAPI를 사용하는 쪽으로 취향이 호불호가 갈린다. 협업 개발자와 익숙한 문법으로 선택하거나 , 둘 다 해보고 더 나은 족을 선택하는 방법도 있다.","link":"/2022/01/22/2022-01-22-Item45/"}],"tags":[],"categories":[{"name":"spring","slug":"spring","link":"/categories/spring/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"토비의 spring","slug":"spring/토비의-spring","link":"/categories/spring/%ED%86%A0%EB%B9%84%EC%9D%98-spring/"},{"name":"개발 상식","slug":"개발-상식","link":"/categories/%EA%B0%9C%EB%B0%9C-%EC%83%81%EC%8B%9D/"},{"name":"Effective Java 3&#x2F;E","slug":"Java/Effective-Java-3-E","link":"/categories/Java/Effective-Java-3-E/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Infrastructure","slug":"Infrastructure","link":"/categories/Infrastructure/"},{"name":"Nodejs","slug":"Nodejs","link":"/categories/Nodejs/"},{"name":"Core Concept","slug":"spring/Core-Concept","link":"/categories/spring/Core-Concept/"},{"name":"Data Structure","slug":"Data-Structure","link":"/categories/Data-Structure/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","link":"/categories/Computer-Science/Algorithm/"},{"name":"sorting","slug":"Algorithm/sorting","link":"/categories/Algorithm/sorting/"},{"name":"Graph","slug":"Algorithm/Graph","link":"/categories/Algorithm/Graph/"},{"name":"Batch","slug":"spring/Batch","link":"/categories/spring/Batch/"},{"name":"Kubernetes","slug":"Infrastructure/Kubernetes","link":"/categories/Infrastructure/Kubernetes/"},{"name":"express","slug":"Nodejs/express","link":"/categories/Nodejs/express/"},{"name":"kotlin","slug":"kotlin","link":"/categories/kotlin/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","link":"/categories/Computer-Science/Data-Structure/"},{"name":"Jpa","slug":"spring/Jpa","link":"/categories/spring/Jpa/"},{"name":"Jvm","slug":"Java/Jvm","link":"/categories/Java/Jvm/"},{"name":"Jpa","slug":"Java/Jpa","link":"/categories/Java/Jpa/"},{"name":"Junit","slug":"Java/Junit","link":"/categories/Java/Junit/"},{"name":"OS","slug":"Computer-Science/OS","link":"/categories/Computer-Science/OS/"},{"name":"Design Pattern","slug":"spring/Design-Pattern","link":"/categories/spring/Design-Pattern/"},{"name":"Network","slug":"Computer-Science/Network","link":"/categories/Computer-Science/Network/"},{"name":"Database","slug":"Computer-Science/Database","link":"/categories/Computer-Science/Database/"},{"name":"Git","slug":"개발-상식/Git","link":"/categories/%EA%B0%9C%EB%B0%9C-%EC%83%81%EC%8B%9D/Git/"},{"name":"Data structure","slug":"Computer-Science/Data-structure","link":"/categories/Computer-Science/Data-structure/"}]}