<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>EntityManagerFactory ,EntityManager, Persistent Context 주요 개념 - devcs</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="devcs"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="devcs"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Jpa 의 EntityManagerFactory ,EntityManager, Persistent Context 주요 개념을 알아보기전에 spring boot에서 Jpa 환경을 setting 해주었다.   spring boot에서는 &amp;#x2F;meta-inf&amp;#x2F;persistence.xml JPA 설정파일을 인식하지 않고, 기본으로 설정해준다. spring이 아닌 환경에"><meta property="og:type" content="blog"><meta property="og:title" content="EntityManagerFactory ,EntityManager, Persistent Context 주요 개념"><meta property="og:url" content="http://example.com/2022/01/03/2022-01-02-Jpa-emf-em-pc/"><meta property="og:site_name" content="devcs"><meta property="og:description" content="Jpa 의 EntityManagerFactory ,EntityManager, Persistent Context 주요 개념을 알아보기전에 spring boot에서 Jpa 환경을 setting 해주었다.   spring boot에서는 &amp;#x2F;meta-inf&amp;#x2F;persistence.xml JPA 설정파일을 인식하지 않고, 기본으로 설정해준다. spring이 아닌 환경에"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/images/jpa-basic-01.png"><meta property="og:image" content="http://example.com/images/jpa-basic-01.png"><meta property="og:image" content="http://example.com/images/jpa-basic-02.png"><meta property="article:published_time" content="2022-01-02T15:35:49.000Z"><meta property="article:modified_time" content="2022-01-04T15:48:11.057Z"><meta property="article:author" content="kcs"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/jpa-basic-01.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2022/01/03/2022-01-02-Jpa-emf-em-pc/"},"headline":"EntityManagerFactory ,EntityManager, Persistent Context 주요 개념","image":["http://example.com/images/jpa-basic-01.png","http://example.com/images/jpa-basic-01.png","http://example.com/images/jpa-basic-02.png"],"datePublished":"2022-01-02T15:35:49.000Z","dateModified":"2022-01-04T15:48:11.057Z","author":{"@type":"Person","name":"kcs"},"publisher":{"@type":"Organization","name":"devcs","logo":{"@type":"ImageObject"}},"description":"Jpa 의 EntityManagerFactory ,EntityManager, Persistent Context 주요 개념을 알아보기전에 spring boot에서 Jpa 환경을 setting 해주었다.   spring boot에서는 &#x2F;meta-inf&#x2F;persistence.xml JPA 설정파일을 인식하지 않고, 기본으로 설정해준다. spring이 아닌 환경에"}</script><link rel="canonical" href="http://example.com/2022/01/03/2022-01-02-Jpa-emf-em-pc/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/rainbow.css"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400&amp;family=Roboto" rel="stylesheet"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link id="dark" rel="stylesheet" href="/css/custom.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">devcs</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/">🌙</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/devcs96"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-02T15:35:49.000Z" title="2022. 1. 3. 오전 12:35:49">2022-01-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-01-04T15:48:11.057Z" title="2022. 1. 5. 오전 12:48:11">2022-01-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Jpa/">Jpa</a></span><span class="level-item">18 minutes read (About 2749 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">EntityManagerFactory ,EntityManager, Persistent Context 주요 개념</h1><div class="content"><p>Jpa 의 EntityManagerFactory ,EntityManager, Persistent Context 주요 개념을 알아보기전에 spring boot에서 Jpa 환경을 setting 해주었다.  </p>
<p>spring boot에서는 /meta-inf/persistence.xml JPA 설정파일을 인식하지 않고, 기본으로 설정해준다.</p>
<p>spring이 아닌 환경에서는 /META-INF/persistence.xml 파일을 설정해주어야 한다. </p>
<p>boot에서는 다음과 같이 EntityManagerFactory 와 EntityManager 를 주입받을 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PersistenceContext</span></span><br><span class="line">EntityManager em;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PersistenceUnit</span></span><br><span class="line">EntityManagerFactory emf;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JpaApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PersistenceUnit</span></span><br><span class="line">	EntityManagerFactory emf;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">basicJpa</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		EntityManager em = emf.createEntityManager();</span><br><span class="line">		EntityTransaction transaction = em.getTransaction();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			transaction.begin(); <span class="comment">// transaction 시작</span></span><br><span class="line">			<span class="comment">// 비즈니스 로직</span></span><br><span class="line">			transaction.commit();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">			transaction.rollback();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			em.close();</span><br><span class="line">		&#125;</span><br><span class="line">		emf.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>boot에서 자동으로 설정해준 Persistence class(Jpa 설정 정보)를 주입받아, EntityManagerFactory instance를 생성했다. </p>
<p>참고로 Jpa는 기본적으로 데이터 변경시 Transaction을 당연히 필요로 하며, transaction이 없는 경우는 예외를 던진다. (javax.persistence.TransactionRequiredException) </p>
<h2 id="EntityManagerFactory"><a href="#EntityManagerFactory" class="headerlink" title="EntityManagerFactory"></a>EntityManagerFactory</h2><ul>
<li><p>EntityManagerFactory 는 Persistence class로부터 Jpa를 동작시키기 위한 기반 객체를 만들고, Jpa 구현체에 따라서는 DB connection pool도 만든다</p>
</li>
<li><p>객체 생성 비용이 매우 큼으로, application 전체에 딱 한번만 생성하고 공유된다 (singleton)</p>
</li>
<li><p>DB 1개당 하나의 EntityManagerFactory가 생성된다. </p>
</li>
<li><p>multi-thread 상황에서 공유 가능하다 </p>
</li>
</ul>
<h2 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h2><p>다음으로 EntityManagerFactory에서 EntityManager를 생성하게 되는데, </p>
<p>EntityManager 가 사실상 Jpa 기능의 대부분을 제공한다.</p>
<ul>
<li><p>요청시(Thread별로)마다 EntityManagerFactory로부터 EntityManager가 생성된다. (Thread간에 공유하면 race condition 이 생길 수 있다. )</p>
</li>
<li><p> EntityManager는 내부적으로 DB connection을 가지고 DB와 통신하는데, DB 연결이 꼭 필요한 시점까지는 Connection을 가져오지 않는다. </p>
</li>
</ul>
<h2 id="Persistence-Context-영속성-컨텍스트"><a href="#Persistence-Context-영속성-컨텍스트" class="headerlink" title="Persistence Context (영속성 컨텍스트)"></a>Persistence Context (영속성 컨텍스트)</h2><blockquote>
Entity를 영구 저장하는 환경으로, EntityManager가 생성될떄 하나 만들어지고, EntityManager는 이 영속성 컨텍스트에 Entity를 보관하고 관리한다. 
</blockquote>

<span id="more"></span>

<p>여기서 Entity란 DB 테이블과 매핑한 Entity class를 말한다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="comment">// entity </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@Column(name = &quot;NAME&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음과 같이 em.persist(entity객체) 코드를 실행하면 entityManager는 해당 객체는 영속성 컨텍스트에 저장한다. (영속화한다)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em.persis(member);</span><br></pre></td></tr></table></figure>

<h2 id="Entity-생명주기"><a href="#Entity-생명주기" class="headerlink" title="Entity 생명주기"></a>Entity 생명주기</h2><p>영속성 컨텍스트에 저장된 엔티티는 다양한 생명주기를 갖는다.</p>
<ol>
<li>비영속 (new/transient) : 영속성 컨텍스트와 전혀 관련없는상태</li>
<li>영속: 영속성 컨텍스트에 저장된 상태</li>
<li>준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태로 영속성 컨텍스트내 준영속화된 entity 정보가 모두 제거된다. (ex) 1차 캐시 정보 , 내부 sql 저장소 ) </li>
<li>삭제 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">entityLifeCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Member member = <span class="keyword">new</span> Member(); <span class="comment">// 비영속 상태 : 영속성 컨텍스트와 무관한 상태</span></span><br><span class="line">        em.persist(member); <span class="comment">//  영속 상태 (em.find도 영속 상태 엔티티를 반환한다)</span></span><br><span class="line">        em.detach(member); <span class="comment">// 준영속 상태</span></span><br><span class="line">        em.remove(member); <span class="comment">// 삭제 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>추가로 준영속 상태는 entityManager가 다음과 같은 method를 호출했을때 모두 준영속 상태가 된다.</p>
<ol>
<li>em.detach(entity) : 특정 entity만 준영속화</li>
<li>em.clear():영속성 컨텍스트 내 모든 entity 준영속화</li>
<li>em.close():영속성 컨텍스트 종료 </li>
</ol>
<p>준영속화된 entity는 다음과 같이 영속화될수 있다. merge에 대해서는 동작방식이 persist와 약간 다른데, 아래에 정리하였다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entity nowAttachedEntity = em.merge(detachedEntity);</span><br></pre></td></tr></table></figure>
<h2 id="Persistent-Context의-특징"><a href="#Persistent-Context의-특징" class="headerlink" title="Persistent Context의 특징"></a>Persistent Context의 특징</h2><p>Persistent Context의 특징은 다음과 같다.</p>
<ol>
<li>1차 Caches</li>
<li>동일성 보장 </li>
<li>Write buffering</li>
<li>Dirty Checking (변경 감지)</li>
<li>Lazy Loading (지연 로딩)</li>
</ol>
<h2 id="1차-cache"><a href="#1차-cache" class="headerlink" title="1차 cache"></a>1차 cache</h2><p>영속성 컨텍스트는 DB에 쿼리문을 바로 날리는게 아니라 내부적으로 1차 Cache 에 먼저 저장한다.<br>이떄 @Id (DB의 PK값) 와 Entity 객체를 K-V 로 저장한다. </p>
<p>그렇다면 왜 1차 Cache에 먼저 저장할까? 이름에서 알 수 있듯이 Cache의 장점이다. 접근하기 빠른 더 상위 계층의 저장계층에 저장함으로서 DB까지 I/O query가 안나가고 application에서 영속성 상태의 Entity 객체를 찾아 올 수 있는 것이다. (성능상 장점)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Member member = <span class="keyword">new</span> Member();</span><br><span class="line">member.setId(<span class="string">&quot;testId&quot;</span>);</span><br><span class="line">em.persist(member); <span class="comment">// 1차 cache &lt;testId,member&gt;</span></span><br><span class="line">em.find(Member.class,<span class="string">&quot;testId&quot;</span>) <span class="comment">// DB에 I/O요청이 안나간다. </span></span><br></pre></td></tr></table></figure>


<p>따라서 EntityManger는 먼저 1차 Cache를 조회하고 , 1차 Cache에 Entity가 없다면 DB 에 I/O요청을 보낸다. DB에서 조회한 Entity도 먼저 1차 Cache에 저장하고 반환한다.  </p>
<h2 id="동일성-보장"><a href="#동일성-보장" class="headerlink" title="동일성 보장"></a>동일성 보장</h2><p>1차 Cache와 동일한 내용이다. 1차 Cache에 보관된 Entity 를 계속 find 요청해도 동일한 Entity가 반환된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EntityManager em = emf.createEntityManager();</span><br><span class="line">    EntityTransaction transaction = em.getTransaction();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        transaction.begin();</span><br><span class="line">        Member member = <span class="keyword">new</span> Member(); <span class="comment">// 비영속 상태 : 영속성 컨텍스트와 무관한 상태</span></span><br><span class="line">        member.setId(<span class="string">&quot;testId&quot;</span>);</span><br><span class="line">        em.persist(member); <span class="comment">//  영속 상태</span></span><br><span class="line">        Member foundMemberA = em.find(Member.class, <span class="string">&quot;testId&quot;</span>);</span><br><span class="line">        Member foundMemberB = em.find(Member.class, <span class="string">&quot;testId&quot;</span>);</span><br><span class="line">        Assertions.assertThat(foundMemberA == foundMemberB).isTrue(); <span class="comment">// 동일한 참조값을 가짐.</span></span><br><span class="line">        transaction.commit();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        transaction.rollback();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        em.close();</span><br><span class="line">    &#125;</span><br><span class="line">    emf.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Write-buffering"><a href="#Write-buffering" class="headerlink" title="Write buffering"></a>Write buffering</h2><p>EntityManager는 Trnasaction commit 전까지 내부 쿼리 저장소에 쿼리를 저장해둔다. 그리고 Transaction commit 시점에 한번에 데이터베이스에 쿼리를 보낸다 (flush) </p>
<ul>
<li>flush : 영속성 컨텍스트의 엔티티는 유지한 채  영속성 컨텍스트의 변경사항을 DB에 동기화하는 작업으로 EntityManager.flush() method 혹은 transaction commit 시점 혹은 JPQL 쿼리 반환 결과를 위해 JPQL 쿼리 실행시에도 자동으로 호출된다. </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Member member = <span class="keyword">new</span> Member(); <span class="comment">// 비영속 상태 : 영속성 컨텍스트와 무관한 상태</span></span><br><span class="line">member.setId(<span class="string">&quot;testId&quot;</span>);</span><br><span class="line">em.persist(member); <span class="comment">//  영속 상태</span></span><br><span class="line">member.setUsername(<span class="string">&quot;test1&quot;</span>); <span class="comment">//update</span></span><br><span class="line">member.setUsername(<span class="string">&quot;test2&quot;</span>); <span class="comment">//update</span></span><br><span class="line">transaction.commit(); <span class="comment">// 최종적으로는 snapshot과 비교후 1개의 update 쿼리가 나간다  </span></span><br></pre></td></tr></table></figure>

<p><img src="/images/jpa-basic-01.png"></p>
<p>이렇게 write buffering 하면 불필요한 쿼리를 줄일 수 있다 예를 들어 위와 같이 member에 대해 update 를 수행하였을떄 바로바로 update query가 나가지 않고, commit 시점에 snapshot과 비교해 한번의 update쿼리가 나간다 (dirty checking) . 이부분은 영속성컨텍스트의 또다른 특징으로 아래에 정리하였다. </p>
<p>+) 만약 성능 최적화를 위해 JPQL 쿼리 실행시에도 flsuh가 호출되지 않게하려면 다음과 같이 설정할 수 있다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> EntityManager em = emf.createEntityManager();</span><br><span class="line">em.setFlushMode(FlushModeType.COMMIT);</span><br></pre></td></tr></table></figure>

<h2 id="Dirty-Checking-변경-감지"><a href="#Dirty-Checking-변경-감지" class="headerlink" title="Dirty Checking (변경 감지)"></a>Dirty Checking (변경 감지)</h2><p>Jpa는 Entity를 영속화해서 영속성 컨텍스트에 보관할떄 최초의 상태를 복사해 저장해준다 (SNAPSHOT)</p>
<p>그리고 flush 시점에 SNAPSHOT과 Entity를 비교해서 변경된 Entity를 찾고 ,update query를 생성해서 EntityManager 내부 쿼리 저장소에 쿼리를 저장해두고 flush 시점에 한번에 커밋한다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">em.update(member) <span class="comment">// 존재하지 않는 코드</span></span><br><span class="line">member.setAge(<span class="number">23</span>);</span><br><span class="line">em.flush(); <span class="comment">// 최초 SNAPSHOT과 비교후 AGE가 변경되었음으로 </span></span><br><span class="line">            <span class="comment">//update쿼리를 쓰기지연 저장소에 보내고, 한꺼번에 커밋된다 (write buffering)</span></span><br></pre></td></tr></table></figure>

<p>Dirty checking 기능은 최초의 SNAPSHOT을 비교해서 update 쿼리 기능을 생성하는 것임으로 당연히 SNAPSHOT이 없는 영속 상택 아닌 Entity들은 적용되지 않는다. </p>
<ul>
<li>default로는 변경되지 않는 필드도 update된다. 아래의 코드는 userName 필드만 변경하고 있는데 실제로 나가는 쿼리를 보면 전체 필드에 대한 쿼리가 나간다. </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Member member = <span class="keyword">new</span> Member(); </span><br><span class="line">member.setId(<span class="string">&quot;testId&quot;</span>);</span><br><span class="line">em.persist(member); </span><br><span class="line">member.setUsername(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">member.setUsername(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">transaction.commit(); </span><br></pre></td></tr></table></figure>

<p><img src="/images/jpa-basic-01.png"></p>
<ul>
<li>I/O 요청시 데이터 전송량이 증가함에도 불구하고  이렇게 모든 필드에 대해 업데이트하는 이유는 무엇일까?</li>
</ul>
<ol>
<li>수정쿼리가 항상 동일함으로,application 로딩시점에 미리 수정쿼리를 생성해두고 binding 시킬 수 있다. </li>
<li>데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 parsing한 쿼리를 재사용할 수 있다. </li>
</ol>
<p> org.hibernate.annotations.DynamicUpdate 을 사용하면 변경되는 필드에 대해서만 쿼리가 나갈수도 있으나, 성능상이점을 얻는 정도는 약 30개이상의 필드가 존재할떄라고 한다. (ref - <a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-data-jpa-dynamicupdate">https://www.baeldung.com/spring-data-jpa-dynamicupdate</a> )</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;MEMBER&quot;)</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@DynamicUpdate</span> <span class="comment">// 동적으로 update sql 생성 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Lazy-Loading-지연로딩"><a href="#Lazy-Loading-지연로딩" class="headerlink" title="Lazy Loading (지연로딩)"></a>Lazy Loading (지연로딩)</h2><p>준영속 상태가 아닌 실제 Entity 객체 대신 proxy 객체를 반환받고, 해당 객체를 실제 사용할떄 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다. 이와 반대되는 개념이 즉시로딩 (eager loading)이 있는데, entity간 관계를 mapping하는 chapter에서 다시 정리하려고 한다. </p>
<h2 id="Merge-vs-Persist"><a href="#Merge-vs-Persist" class="headerlink" title="Merge vs Persist"></a>Merge vs Persist</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamMergeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceUnit</span></span><br><span class="line">    EntityManagerFactory emf;</span><br><span class="line"></span><br><span class="line">    <span class="function">Member <span class="title">createMember</span><span class="params">(String id,String username)</span></span>&#123;</span><br><span class="line">        EntityManager em = emf.createEntityManager();</span><br><span class="line">        EntityTransaction transaction = em.getTransaction();</span><br><span class="line">        transaction.begin();</span><br><span class="line">        Member member = <span class="keyword">new</span> Member();</span><br><span class="line">        member.setId(id);</span><br><span class="line">        member.setUsername(username);</span><br><span class="line">        em.persist(member);</span><br><span class="line">        transaction.commit();</span><br><span class="line"></span><br><span class="line">        em.close();<span class="comment">//영속성 컨텍스트가 종료됨</span></span><br><span class="line">        <span class="keyword">return</span> member; <span class="comment">// 영속 --&gt; 준영속 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeMember</span><span class="params">(Member member)</span></span>&#123;</span><br><span class="line">        EntityManager em = emf.createEntityManager();</span><br><span class="line">        EntityTransaction transaction = em.getTransaction();</span><br><span class="line">        transaction.begin();</span><br><span class="line"></span><br><span class="line">        Member mergeMember = em.merge(member);</span><br><span class="line"></span><br><span class="line">        transaction.commit();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;member.getUsername() = &quot;</span> + member.getUsername()); <span class="comment">// 준영속 상태</span></span><br><span class="line">        System.out.println(<span class="string">&quot;mergeMember.getUsername() = &quot;</span> + mergeMember.getUsername()); <span class="comment">//영속 상태</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;em.contains(member) = &quot;</span> + em.contains(member));</span><br><span class="line">        System.out.println(<span class="string">&quot;em.contains(mergeMember();) = &quot;</span> + em.contains(mergeMember));</span><br><span class="line">        em.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Member member = createMember(<span class="string">&quot;testId&quot;</span>, <span class="string">&quot;tester&quot;</span>); <span class="comment">// 준영속상태 </span></span><br><span class="line">        member.setUsername(<span class="string">&quot;changed&quot;</span>);</span><br><span class="line">        mergeMember(member);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol>
<li><p>createMember(…) method가 실행됨에따라 entitymanager가 transaction을 열고, 데이터를 변경하는데 member  entity를 영속화하고, commit()한다. commit 시점에 insert into Member query가 수행된다.</p>
</li>
<li><p>em.close() 호출함에따라 member는 영속성컨텍스트가 종료되어 이젠 준영속상태이다. </p>
</li>
<li><p>member.setUsername(“changed”)를 호출해도 준영속상태임으로 dirty checking되지 않고 ,mergeMember(…)의 parameter로 넘어간다. </p>
</li>
<li><p>새로운 entitymanager가 transaction을 다시 열고 , 준영속상태의 member를 merge 한다.</p>
</li>
</ol>
<p>merge 동작 방식은 다음과 같다. </p>
<ol>
<li>parameter로 넘어온 준영속상태의 entity key 값으로 1차cache에서 조회하고 , 1차 cache에 없다면 DB까지 가서 값을 가져오고, 1차 cache에 저장한다.</li>
<li>조회된 entity를 준영속상태의 entity 의 모든 값으로 변경한다. ***</li>
<li>영속 상태인 조회된 entity를 반환한다. </li>
</ol>
<p>정리하면 merge는 persist와 다르게 준영속상태의 entity를 영속화시킬떄 쓰이는데 , 모든 필드의 값을 덮어씌운다는게 차이점이다. </p>
<p>어쩄거나 영속 상태인 조회된 entity의 값이 변경되었으므로 commit시점에 다시 dirty checking이 일어난다. </p>
<p><img src="/images/jpa-basic-02.png"></p>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>Jpa는 Java 표준 ORM으로 요청시마다 EntityManagerFactory로부터 entity manager가 생성되고, 이 entity manager가 DB connection 을 가지고 와 요청을 수행한다. 이떄 entity manager는 논리적인 persistent context에 entity를 관리하는데, persistent context의 특징은 1차캐시/동일성 보장/write buffering/dirty checking/lazy loading이 있다.  </p>
</div><!--!--></article></div><!--!--><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "f533dcb993007345e1189c4215308a79",
            repo: "gittalk",
            owner: "devcs96",
            clientID: "ad3debd03c0e5f289948",
            clientSecret: "471b03d4771d8a3467d95e33fde1e2d8804d5da8",
            admin: ["devcs96"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/01/03/2022-01-03-Item31/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Item31. 한정적 와일드카드를 사용해 API 유연성을 높이라</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/01/02/2022-01-02-Jpa/"><span class="level-item">Jpa</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-2-tablet is-2-desktop is-2-widescreen  order-1"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Computer-Science/"><span class="level-start"><span class="level-item">Computer Science</span></span><span class="level-end"><span class="level-item tag">22</span></span></a><ul><li><a class="level is-mobile" href="/categories/Computer-Science/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Computer-Science/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Computer-Science/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Computer-Science/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/Computer-Science/Network/IT-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%85%EB%AC%B8/"><span class="level-start"><span class="level-item">IT 엔지니어를 위한 네트워크 입문</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Computer-Science/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">86</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Effective-Java-3-E/"><span class="level-start"><span class="level-item">Effective Java 3/E</span></span><span class="level-end"><span class="level-item tag">80</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Jpa/"><span class="level-start"><span class="level-item">Jpa</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Junit/"><span class="level-start"><span class="level-item">Junit</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Jvm/"><span class="level-start"><span class="level-item">Jvm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Nodejs/"><span class="level-start"><span class="level-item">Nodejs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Nodejs/express/"><span class="level-start"><span class="level-item">express</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/database/"><span class="level-start"><span class="level-item">database</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/database/oracle/"><span class="level-start"><span class="level-item">oracle</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/kotlin/"><span class="level-start"><span class="level-item">kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/"><span class="level-start"><span class="level-item">spring</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/spring/Batch/"><span class="level-start"><span class="level-item">Batch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/Core-Concept/"><span class="level-start"><span class="level-item">Core Concept</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/Jpa/"><span class="level-start"><span class="level-item">Jpa</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/%ED%86%A0%EB%B9%84%EC%9D%98-spring/"><span class="level-start"><span class="level-item">토비의 spring</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%EA%B0%9C%EB%B0%9C-%EC%83%81%EC%8B%9D/"><span class="level-start"><span class="level-item">개발 상식</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%EA%B0%9C%EB%B0%9C-%EC%83%81%EC%8B%9D/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-01T05:33:02.000Z">2022-06-01</time></p><p class="title"><a href="/2022/06/01/transaction-isolation-level/">Transaction 과 격리 수준</a></p><p class="categories"><a href="/categories/database/">database</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-30T15:41:54.000Z">2022-05-31</time></p><p class="title"><a href="/2022/05/31/plsql-pacakage-01/">PL/SQL - Package</a></p><p class="categories"><a href="/categories/database/">database</a> / <a href="/categories/database/oracle/">oracle</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-18T10:24:54.000Z">2022-05-18</time></p><p class="title"><a href="/2022/05/18/plsql-collection/">PLSQL - Collection</a></p><p class="categories"><a href="/categories/database/">database</a> / <a href="/categories/database/oracle/">oracle</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-17T12:17:59.000Z">2022-05-17</time></p><p class="title"><a href="/2022/05/17/plsql-record-01/">PLSQL - Record</a></p><p class="categories"><a href="/categories/database/">database</a> / <a href="/categories/database/oracle/">oracle</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-16T15:46:16.000Z">2022-05-17</time></p><p class="title"><a href="/2022/05/17/plsql-cursor-01/">PL/SQL - Cursor</a></p><p class="categories"><a href="/categories/database/">database</a> / <a href="/categories/database/oracle/">oracle</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">42</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">July 2021</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li></ul></div></div></div><!--!--></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>