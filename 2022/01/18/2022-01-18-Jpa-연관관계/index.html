<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>연관관계 매핑 - devcs</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="devcs"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="devcs"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="객체 연관관계와 테이블 연관관계의 차이점 객체는 참조(주소)값을 기준으로 연관관계를 맺는다.(단방향)ex) X-&amp;gt;Y , Y-&amp;gt;X 테이블은 외래키를 기준으로 연관관계를 맺는다. (JOIN operation , 양방향)ex) X JOIN Y 는 Y JOIN X 도 가능하다.   단방향 연관관계 두 entity 중 어느 한쪽만 다른 한쪽을 참조하는 경"><meta property="og:type" content="blog"><meta property="og:title" content="연관관계 매핑"><meta property="og:url" content="http://example.com/2022/01/18/2022-01-18-Jpa-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"><meta property="og:site_name" content="devcs"><meta property="og:description" content="객체 연관관계와 테이블 연관관계의 차이점 객체는 참조(주소)값을 기준으로 연관관계를 맺는다.(단방향)ex) X-&amp;gt;Y , Y-&amp;gt;X 테이블은 외래키를 기준으로 연관관계를 맺는다. (JOIN operation , 양방향)ex) X JOIN Y 는 Y JOIN X 도 가능하다.   단방향 연관관계 두 entity 중 어느 한쪽만 다른 한쪽을 참조하는 경"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:published_time" content="2022-01-17T15:55:07.000Z"><meta property="article:modified_time" content="2022-01-21T12:58:42.037Z"><meta property="article:author" content="kcs"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2022/01/18/2022-01-18-Jpa-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"},"headline":"연관관계 매핑","image":["http://example.com/img/og_image.png"],"datePublished":"2022-01-17T15:55:07.000Z","dateModified":"2022-01-21T12:58:42.037Z","author":{"@type":"Person","name":"kcs"},"publisher":{"@type":"Organization","name":"devcs","logo":{"@type":"ImageObject"}},"description":"객체 연관관계와 테이블 연관관계의 차이점 객체는 참조(주소)값을 기준으로 연관관계를 맺는다.(단방향)ex) X-&gt;Y , Y-&gt;X 테이블은 외래키를 기준으로 연관관계를 맺는다. (JOIN operation , 양방향)ex) X JOIN Y 는 Y JOIN X 도 가능하다.   단방향 연관관계 두 entity 중 어느 한쪽만 다른 한쪽을 참조하는 경"}</script><link rel="canonical" href="http://example.com/2022/01/18/2022-01-18-Jpa-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/rainbow.css"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400&amp;family=Roboto" rel="stylesheet"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link id="dark" rel="stylesheet" href="/css/custom.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">devcs</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/">🌙</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/devcs96"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-17T15:55:07.000Z" title="2022. 1. 18. 오전 12:55:07">2022-01-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-01-21T12:58:42.037Z" title="2022. 1. 21. 오후 9:58:42">2022-01-21</time></span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Jpa/">Jpa</a></span><span class="level-item">13 minutes read (About 1918 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">연관관계 매핑</h1><div class="content"><h2 id="객체-연관관계와-테이블-연관관계의-차이점"><a href="#객체-연관관계와-테이블-연관관계의-차이점" class="headerlink" title="객체 연관관계와 테이블 연관관계의 차이점"></a>객체 연관관계와 테이블 연관관계의 차이점</h2><ul>
<li>객체는 참조(주소)값을 기준으로 연관관계를 맺는다.(단방향)<br>ex) X-&gt;Y , Y-&gt;X</li>
<li>테이블은 외래키를 기준으로 연관관계를 맺는다. (JOIN operation , 양방향)<br>ex) X JOIN Y 는 Y JOIN X 도 가능하다. </li>
</ul>
<h2 id="단방향-연관관계"><a href="#단방향-연관관계" class="headerlink" title="단방향 연관관계"></a>단방향 연관관계</h2><ul>
<li>두 entity 중 어느 한쪽만 다른 한쪽을 참조하는 경우을 단방향이라고 한다. </li>
</ul>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//회원 entity</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;member_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 게시글 entity </span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Board</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;board_seq&quot;)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long seq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="comment">// 연관관계 </span></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;member_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Member member;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>예를 들어 회원이 여러개의 게시글을 사용할 수 있는 다대일(게시글 N : 회원 1) 상황을 고려하면 단방향에서는 회원-&gt;게시글을 참조하거나, 게시글-&gt;회원을 참조하거나 어느 한쪽만 참조하는 경우를 생각할 수 있다. 위 예시 코드는 게시글이 회원을 참조하는 상황을 가정하였다. </p>
<p>연관관계 매핑을 위한 annotation은 다음과 같이 사용되었다.</p>
<ul>
<li>@ManyToOne : 다대일 관계 매핑 </li>
<li>@JoinColumn : 외래키 매핑 , name 속성에 외래키 이름을 지정한다. 여기서는 member_id값이 외래키가 된다. </li>
</ul>
<h2 id="양방향-연관관계"><a href="#양방향-연관관계" class="headerlink" title="양방향 연관관계"></a>양방향 연관관계</h2><ul>
<li><p>두 entity간에 서로 참조하는 관계를 양방향 연관관계라고 한다. 위 예에서 Member -&gt; board는 일대다 연관관계이다. 일대다 연관관계에서 ‘다’측의 객체는 Collection (List,Set,Map…)  으로 매핑될 수 있다. (정확히 말하면 단방향 연관관계 2개를 application에서 양방향인 것 처럼 보이게 할 뿐이다.)</p>
</li>
<li><p>단방향 연관관계에 비해 갖는 장점은 반대 방향으로도 객체 그래프 탐색 기능이 추가되었다는 장점이 있다. 반면 단점으로는 연관관계를 매핑할때 객체에서 양쪽 방향을 모두 관리해야 된다는 단점이 있다. </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;member_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;member&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Board&gt; boardList =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>@OneToMany : 일대다 관계 </li>
<li>mappedBy 속성 : 양방향 매핑일떄 반대쪽 (Board) entity에서 자신이 매핑된 필드 이름 값 </li>
</ul>
<h2 id="연관관계의-주인"><a href="#연관관계의-주인" class="headerlink" title="연관관계의 주인"></a>연관관계의 주인</h2><p>양방향 연관관계에서는 주의할점이 있다. 두 연관관계중에 하나를 연관관계의 주인으로 정해야 한다는 것이다.<br>연관관계의 주인이라 함은 외래키를 가지고 있는 entity 를 말한다. 즉 외래키를 가지는 DB 와 매핑되는 Entity가 연관관계의 주인인 것이다.</p>
<p>연관관계의 주인이 아닌 entity가 mappedBy 속성을 사용해, 연관관계의 주인을 지정해야 한다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;member&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Board&gt; boardList =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Board</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 연관관계의 주인이다. </span></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;member_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Member member;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>정리하면 연관관계의 주인만이 DB에서 외래키를 가진 table과 매핑되고, 외래키를 관리한다 , 즉 저장하려면 연관관계의 주인을 통해서 이루어져야 한다. 반면 연관관계의 주인이 아닌 entity는 읽기만 가능하다.<br>따라서 연관관계(외래키)를 저장할떄에는 연관관계의 주인을 통해서만 저장할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 연관관계의 주인 board entity</span></span><br><span class="line">transaction.begin();</span><br><span class="line"></span><br><span class="line">Member member = <span class="keyword">new</span> Member(<span class="string">&quot;id1&quot;</span>, <span class="string">&quot;user1&quot;</span>);</span><br><span class="line">em.persist(member);</span><br><span class="line"></span><br><span class="line">Board boardA = <span class="keyword">new</span> Board(<span class="string">&quot;title1&quot;</span>,<span class="string">&quot;content1&quot;</span>,member);</span><br><span class="line">em.persist(boardA);</span><br><span class="line"></span><br><span class="line">Board boardB = <span class="keyword">new</span> Board(<span class="string">&quot;title2&quot;</span>,<span class="string">&quot;content2&quot;</span>,member);</span><br><span class="line">em.persist(boardB);</span><br></pre></td></tr></table></figure>

<p>다음과 같이 연관관계의 주인이 아닌 다대일에서 ‘일’ 쪽인 entity가 연관관계를 저장하면 예외는 터지지 않으나, DB에는 null값이 할당된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Board boardA = <span class="keyword">new</span> Board(<span class="string">&quot;title1&quot;</span>,<span class="string">&quot;content1&quot;</span>);</span><br><span class="line">em.persist(boardA);</span><br><span class="line"></span><br><span class="line">Board boardB = <span class="keyword">new</span> Board(<span class="string">&quot;title2&quot;</span>,<span class="string">&quot;content2&quot;</span>);</span><br><span class="line">em.persist(boardB);</span><br><span class="line"></span><br><span class="line">Member member = <span class="keyword">new</span> Member(<span class="string">&quot;id1&quot;</span>, <span class="string">&quot;user1&quot;</span>);</span><br><span class="line">member.getBoardList().add(boardA); <span class="comment">// null</span></span><br><span class="line">member.getBoardList().add(boardB); <span class="comment">// null</span></span><br><span class="line">em.persist(member);</span><br></pre></td></tr></table></figure>


<p>대개 연관관계는 다대일,일대다 등에서 ‘다’ 쪽이 연관관계의 주인이 된다. 그 이유는 DB 를 생각해도 당연하다. 따라서 @ManyToOne에는 애초에 mappedBy 속성이 없다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD&#125;)</span> </span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ManyToOne &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Class <span class="title">targetEntity</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">void</span>.class</span>;</span><br><span class="line">    CascadeType[] cascade() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">FetchType <span class="title">fetch</span><span class="params">()</span> <span class="keyword">default</span> EAGER</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>반면 OneToMany는 연관관계의 주인을 지정하는 mappedBy속성이 있는 것을 확인할 수 있다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OneToMany &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Class <span class="title">targetEntity</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">void</span>.class</span>;</span><br><span class="line">    CascadeType[] cascade() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">FetchType <span class="title">fetch</span><span class="params">()</span> <span class="keyword">default</span> LAZY</span>;</span><br><span class="line">    <span class="function">String <span class="title">mappedBy</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="양방향-연관관계의-주의점"><a href="#양방향-연관관계의-주의점" class="headerlink" title="양방향 연관관계의 주의점"></a>양방향 연관관계의 주의점</h2><ul>
<li><p>위 내용에 따르면, 연관관계의 주인이 외래키를 관리(저장)한다고 하였다. 따라서 객체 관점에서는 연관관계의 주인쪽에서만 연관관계의 주인이 아닌 entity 필드에 값을 넣어주고, 연관관계의 주인이 아닌 entity는 연관관계의 주인인 entity 필드에 값을 넣어줄 필요가 없을까? </p>
</li>
<li><p>JPA 기술 상으로는 문제가 없으나, 순수 객체의 관점에서는 불일치 상태가 된다. </p>
</li>
</ul>
<p>예를 들면 아래와 같은 테스트 코드에서 실제 DB에는 정상적으로 연관관계가 저장되었을지는 몰라도, 두 entity간에는 다른 정보를 가지고 있다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBiDirection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Member member = <span class="keyword">new</span> Member(<span class="string">&quot;id1&quot;</span>, <span class="string">&quot;user1&quot;</span>);</span><br><span class="line">    Board boardA = <span class="keyword">new</span> Board(<span class="string">&quot;title1&quot;</span>,<span class="string">&quot;content1&quot;</span>);</span><br><span class="line">    Board boardB = <span class="keyword">new</span> Board(<span class="string">&quot;title2&quot;</span>,<span class="string">&quot;content2&quot;</span>);</span><br><span class="line">    <span class="comment">// 연관관계 설정</span></span><br><span class="line">    boardA.setMember(member);</span><br><span class="line">    boardB.setMember(member);</span><br><span class="line"></span><br><span class="line">    assertThat(member.getBoardList().size()).isEqualTo(<span class="number">2</span>); <span class="comment">// fail!!! </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="연관관계-편의-메소드"><a href="#연관관계-편의-메소드" class="headerlink" title="연관관계 편의 메소드"></a>연관관계 편의 메소드</h2><ul>
<li>위와 같이 객체간의 불일치한 상태를 일치시켜주기 위해서 두 entity중에 하나에 한번에 양방향 관계를 설정해주는 연관관계 편의 method를 정의한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//연관관계편의 메소드 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoard</span><span class="params">(Board board)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.boardList.add(board);</span><br><span class="line">      board.setMember(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
테스트를 해보면 정상적으로 성공되는 것을 확인할 수 있다. 경우에 따라 기존의 연관관계를 삭제하고 연관관계를 추가해야하는 상황이 올수도 있으니, 이 또한 고려해야 한다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBiDirection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EntityManager em = emf.createEntityManager();</span><br><span class="line">    EntityTransaction transaction = em.getTransaction();</span><br><span class="line">    transaction.begin();</span><br><span class="line"></span><br><span class="line">    Member member = <span class="keyword">new</span> Member(<span class="string">&quot;id1&quot;</span>, <span class="string">&quot;user1&quot;</span>);</span><br><span class="line">    Board boardA = <span class="keyword">new</span> Board(<span class="string">&quot;title1&quot;</span>,<span class="string">&quot;content1&quot;</span>);</span><br><span class="line">    Board boardB = <span class="keyword">new</span> Board(<span class="string">&quot;title2&quot;</span>,<span class="string">&quot;content2&quot;</span>);</span><br><span class="line">    <span class="comment">// 연관관계 설정</span></span><br><span class="line">    member.addBoard(boardA);</span><br><span class="line">    member.addBoard(boardB);</span><br><span class="line">    assertThat(member.getBoardList().size()).isEqualTo(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>추가로 양방향 매핑시에 두 entity간에 toString이 서로를 순환참조할 수 있으므로, 대개는 entity에 toString method를 overriding  하진 않지만 (dto사용)<br>그래도 조심하자.</p>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul>
<li><p>단방향 매핑을 먼저 시도하고, 비즈니스 로직에 따라 양방향을 사용하도록 변경하자, 그 이유는 양방향을 매핑하면 객체에서 양쪽 방향을 모두 고려해야 되는데, 이는 코드도 복잡해지고 , 굳이 반대 방향으로 객체 그래프 탐색을 하지 않는다면 필요없는 기능이다. </p>
</li>
<li><p>양방향 매핑에서 외래키를 관리할 entity를 연관관계의 주인이라고 부르며 보통 다대일,일대다에서 ‘다’ 측의 entity이다.<br>(‘일’측을 연관관계의 주인으로 설정할 수는 있지만, DB 외래키를 가진 table과 다른 entity가 외래키를 관리하게 된다.)</p>
</li>
<li><p>양방향 매핑을 사용해야 한다면 , Entity 객체간에 연관관계를 맺어주는 연관관계 편의 method를 활용하자. 그래야 객체 관점에서도 일관성 있는 정보를 가지게 되며 테스트하기도 용이해진다. </p>
</li>
</ul>
</div><!--!--></article></div><!--!--><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "79a2bb2b205d61efa15e6793f1e6da11",
            repo: "gittalk",
            owner: "devcs96",
            clientID: "ad3debd03c0e5f289948",
            clientSecret: "471b03d4771d8a3467d95e33fde1e2d8804d5da8",
            admin: ["devcs96"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/01/18/2022-01-18-Item42/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Item42. 익명 클래스보다 람다를 사용하라</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/01/17/2022-01-17-Item41/"><span class="level-item">Item41. 정의하려는 것이 타입이라면 marker interface를 사용하라</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-2-tablet is-2-desktop is-2-widescreen  order-1"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Computer-Science/"><span class="level-start"><span class="level-item">Computer Science</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/Computer-Science/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Computer-Science/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Computer-Science/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Computer-Science/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/Computer-Science/Network/IT-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%85%EB%AC%B8/"><span class="level-start"><span class="level-item">IT 엔지니어를 위한 네트워크 입문</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Computer-Science/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Infrastructure/"><span class="level-start"><span class="level-item">Infrastructure</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Infrastructure/Kubernetes/"><span class="level-start"><span class="level-item">Kubernetes</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">80</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Effective-Java-3-E/"><span class="level-start"><span class="level-item">Effective Java 3/E</span></span><span class="level-end"><span class="level-item tag">74</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Jpa/"><span class="level-start"><span class="level-item">Jpa</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Junit/"><span class="level-start"><span class="level-item">Junit</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Jvm/"><span class="level-start"><span class="level-item">Jvm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Nodejs/"><span class="level-start"><span class="level-item">Nodejs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Nodejs/express/"><span class="level-start"><span class="level-item">express</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/kotlin/"><span class="level-start"><span class="level-item">kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/"><span class="level-start"><span class="level-item">spring</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/spring/Batch/"><span class="level-start"><span class="level-item">Batch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/Core-Concept/"><span class="level-start"><span class="level-item">Core Concept</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/Jpa/"><span class="level-start"><span class="level-item">Jpa</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/%ED%86%A0%EB%B9%84%EC%9D%98-spring/"><span class="level-start"><span class="level-item">토비의 spring</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%EA%B0%9C%EB%B0%9C-%EC%83%81%EC%8B%9D/"><span class="level-start"><span class="level-item">개발 상식</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%EA%B0%9C%EB%B0%9C-%EC%83%81%EC%8B%9D/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-28T09:47:56.000Z">2022-03-28</time></p><p class="title"><a href="/2022/03/28/Item79/">Item79. 과도한 동기화는 피하라</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/Effective-Java-3-E/">Effective Java 3/E</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-27T08:37:43.000Z">2022-03-27</time></p><p class="title"><a href="/2022/03/27/Item81/">Item81. wait와 notify보다는 동시성 유틸리티를 애용하라</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/Effective-Java-3-E/">Effective Java 3/E</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-20T15:32:48.000Z">2022-03-21</time></p><p class="title"><a href="/2022/03/21/Item78/">Item78. 공유 중인 가변 데이터는 동기화해 사용하라</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/Effective-Java-3-E/">Effective Java 3/E</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-20T09:30:09.000Z">2022-03-20</time></p><p class="title"><a href="/2022/03/20/Item77/">Item77. 예외를 무시하지 말자</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/Effective-Java-3-E/">Effective Java 3/E</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-13T09:40:33.000Z">2022-03-13</time></p><p class="title"><a href="/2022/03/13/Item76/">Item76. 가능한 한 실패 원자적으로 만들라</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/Effective-Java-3-E/">Effective Java 3/E</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">42</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">July 2021</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li></ul></div></div></div><!--!--></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>